["^ ","~:output",["^ ","~:js","goog.provide('cats.protocols');\r\ngoog.require('cljs.core');\r\n\r\n/**\r\n * A marker protocol for identifying the valid context types.\r\n * @interface\r\n */\r\ncats.protocols.Context = function(){};\r\n\r\n\r\n/**\r\n * Abstraction that establishes a concrete type as a member of a context.\r\n * \r\n *   A great example is the Maybe monad type Just. It implements\r\n *   this abstraction to establish that Just is part of\r\n *   the Maybe monad.\r\n * @interface\r\n */\r\ncats.protocols.Contextual = function(){};\r\n\r\n/**\r\n * Get the context associated with the type.\r\n */\r\ncats.protocols._get_context = (function cats$protocols$_get_context(_){\r\nif((((!((_ == null)))) && ((!((_.cats$protocols$Contextual$_get_context$arity$1 == null)))))){\r\nreturn _.cats$protocols$Contextual$_get_context$arity$1(_);\r\n} else {\r\nvar x__4487__auto__ = (((_ == null))?null:_);\r\nvar m__4488__auto__ = (cats.protocols._get_context[goog.typeOf(x__4487__auto__)]);\r\nif((!((m__4488__auto__ == null)))){\r\nreturn (m__4488__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4488__auto__.cljs$core$IFn$_invoke$arity$1(_) : m__4488__auto__.call(null,_));\r\n} else {\r\nvar m__4485__auto__ = (cats.protocols._get_context[\"_\"]);\r\nif((!((m__4485__auto__ == null)))){\r\nreturn (m__4485__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4485__auto__.cljs$core$IFn$_invoke$arity$1(_) : m__4485__auto__.call(null,_));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"Contextual.-get-context\",_);\r\n}\r\n}\r\n}\r\n});\r\n\r\n\r\n/**\r\n * An abstraction to make a type printable in a platform\r\n *   independent manner.\r\n * @interface\r\n */\r\ncats.protocols.Printable = function(){};\r\n\r\n/**\r\n * Get the repl ready representation of the object.\r\n */\r\ncats.protocols._repr = (function cats$protocols$_repr(_){\r\nif((((!((_ == null)))) && ((!((_.cats$protocols$Printable$_repr$arity$1 == null)))))){\r\nreturn _.cats$protocols$Printable$_repr$arity$1(_);\r\n} else {\r\nvar x__4487__auto__ = (((_ == null))?null:_);\r\nvar m__4488__auto__ = (cats.protocols._repr[goog.typeOf(x__4487__auto__)]);\r\nif((!((m__4488__auto__ == null)))){\r\nreturn (m__4488__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4488__auto__.cljs$core$IFn$_invoke$arity$1(_) : m__4488__auto__.call(null,_));\r\n} else {\r\nvar m__4485__auto__ = (cats.protocols._repr[\"_\"]);\r\nif((!((m__4485__auto__ == null)))){\r\nreturn (m__4485__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4485__auto__.cljs$core$IFn$_invoke$arity$1(_) : m__4485__auto__.call(null,_));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"Printable.-repr\",_);\r\n}\r\n}\r\n}\r\n});\r\n\r\n\r\n/**\r\n * A structure with an associative binary operation.\r\n * @interface\r\n */\r\ncats.protocols.Semigroup = function(){};\r\n\r\n/**\r\n * An associative addition operation.\r\n */\r\ncats.protocols._mappend = (function cats$protocols$_mappend(s,sv,sv_SINGLEQUOTE_){\r\nif((((!((s == null)))) && ((!((s.cats$protocols$Semigroup$_mappend$arity$3 == null)))))){\r\nreturn s.cats$protocols$Semigroup$_mappend$arity$3(s,sv,sv_SINGLEQUOTE_);\r\n} else {\r\nvar x__4487__auto__ = (((s == null))?null:s);\r\nvar m__4488__auto__ = (cats.protocols._mappend[goog.typeOf(x__4487__auto__)]);\r\nif((!((m__4488__auto__ == null)))){\r\nreturn (m__4488__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4488__auto__.cljs$core$IFn$_invoke$arity$3(s,sv,sv_SINGLEQUOTE_) : m__4488__auto__.call(null,s,sv,sv_SINGLEQUOTE_));\r\n} else {\r\nvar m__4485__auto__ = (cats.protocols._mappend[\"_\"]);\r\nif((!((m__4485__auto__ == null)))){\r\nreturn (m__4485__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4485__auto__.cljs$core$IFn$_invoke$arity$3(s,sv,sv_SINGLEQUOTE_) : m__4485__auto__.call(null,s,sv,sv_SINGLEQUOTE_));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"Semigroup.-mappend\",s);\r\n}\r\n}\r\n}\r\n});\r\n\r\n\r\n/**\r\n * A Semigroup which has an identity element with respect to an associative binary operation.\r\n * @interface\r\n */\r\ncats.protocols.Monoid = function(){};\r\n\r\n/**\r\n * The identity element for the given monoid.\r\n */\r\ncats.protocols._mempty = (function cats$protocols$_mempty(s){\r\nif((((!((s == null)))) && ((!((s.cats$protocols$Monoid$_mempty$arity$1 == null)))))){\r\nreturn s.cats$protocols$Monoid$_mempty$arity$1(s);\r\n} else {\r\nvar x__4487__auto__ = (((s == null))?null:s);\r\nvar m__4488__auto__ = (cats.protocols._mempty[goog.typeOf(x__4487__auto__)]);\r\nif((!((m__4488__auto__ == null)))){\r\nreturn (m__4488__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4488__auto__.cljs$core$IFn$_invoke$arity$1(s) : m__4488__auto__.call(null,s));\r\n} else {\r\nvar m__4485__auto__ = (cats.protocols._mempty[\"_\"]);\r\nif((!((m__4485__auto__ == null)))){\r\nreturn (m__4485__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4485__auto__.cljs$core$IFn$_invoke$arity$1(s) : m__4485__auto__.call(null,s));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"Monoid.-mempty\",s);\r\n}\r\n}\r\n}\r\n});\r\n\r\n\r\n/**\r\n * A type class to extract the\r\n *   value from a monad context.\r\n * @interface\r\n */\r\ncats.protocols.Extract = function(){};\r\n\r\n/**\r\n * Extract the value from monad context.\r\n */\r\ncats.protocols._extract = (function cats$protocols$_extract(mv){\r\nif((((!((mv == null)))) && ((!((mv.cats$protocols$Extract$_extract$arity$1 == null)))))){\r\nreturn mv.cats$protocols$Extract$_extract$arity$1(mv);\r\n} else {\r\nvar x__4487__auto__ = (((mv == null))?null:mv);\r\nvar m__4488__auto__ = (cats.protocols._extract[goog.typeOf(x__4487__auto__)]);\r\nif((!((m__4488__auto__ == null)))){\r\nreturn (m__4488__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4488__auto__.cljs$core$IFn$_invoke$arity$1(mv) : m__4488__auto__.call(null,mv));\r\n} else {\r\nvar m__4485__auto__ = (cats.protocols._extract[\"_\"]);\r\nif((!((m__4485__auto__ == null)))){\r\nreturn (m__4485__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4485__auto__.cljs$core$IFn$_invoke$arity$1(mv) : m__4485__auto__.call(null,mv));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"Extract.-extract\",mv);\r\n}\r\n}\r\n}\r\n});\r\n\r\n\r\n/**\r\n * A data type that can be mapped over without altering its context.\r\n * @interface\r\n */\r\ncats.protocols.Functor = function(){};\r\n\r\n/**\r\n * Applies function f to the value(s) inside the context of the functor fv.\r\n */\r\ncats.protocols._fmap = (function cats$protocols$_fmap(ftor,f,fv){\r\nif((((!((ftor == null)))) && ((!((ftor.cats$protocols$Functor$_fmap$arity$3 == null)))))){\r\nreturn ftor.cats$protocols$Functor$_fmap$arity$3(ftor,f,fv);\r\n} else {\r\nvar x__4487__auto__ = (((ftor == null))?null:ftor);\r\nvar m__4488__auto__ = (cats.protocols._fmap[goog.typeOf(x__4487__auto__)]);\r\nif((!((m__4488__auto__ == null)))){\r\nreturn (m__4488__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4488__auto__.cljs$core$IFn$_invoke$arity$3(ftor,f,fv) : m__4488__auto__.call(null,ftor,f,fv));\r\n} else {\r\nvar m__4485__auto__ = (cats.protocols._fmap[\"_\"]);\r\nif((!((m__4485__auto__ == null)))){\r\nreturn (m__4485__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4485__auto__.cljs$core$IFn$_invoke$arity$3(ftor,f,fv) : m__4485__auto__.call(null,ftor,f,fv));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"Functor.-fmap\",ftor);\r\n}\r\n}\r\n}\r\n});\r\n\r\n\r\n/**\r\n * A 'Functor' of two arguments.\r\n * @interface\r\n */\r\ncats.protocols.Bifunctor = function(){};\r\n\r\n/**\r\n * Map over both arguments at the same time.\r\n */\r\ncats.protocols._bimap = (function cats$protocols$_bimap(btor,f,g,bv){\r\nif((((!((btor == null)))) && ((!((btor.cats$protocols$Bifunctor$_bimap$arity$4 == null)))))){\r\nreturn btor.cats$protocols$Bifunctor$_bimap$arity$4(btor,f,g,bv);\r\n} else {\r\nvar x__4487__auto__ = (((btor == null))?null:btor);\r\nvar m__4488__auto__ = (cats.protocols._bimap[goog.typeOf(x__4487__auto__)]);\r\nif((!((m__4488__auto__ == null)))){\r\nreturn (m__4488__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4488__auto__.cljs$core$IFn$_invoke$arity$4(btor,f,g,bv) : m__4488__auto__.call(null,btor,f,g,bv));\r\n} else {\r\nvar m__4485__auto__ = (cats.protocols._bimap[\"_\"]);\r\nif((!((m__4485__auto__ == null)))){\r\nreturn (m__4485__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4485__auto__.cljs$core$IFn$_invoke$arity$4(btor,f,g,bv) : m__4485__auto__.call(null,btor,f,g,bv));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"Bifunctor.-bimap\",btor);\r\n}\r\n}\r\n}\r\n});\r\n\r\n\r\n/**\r\n * The Applicative abstraction.\r\n * @interface\r\n */\r\ncats.protocols.Applicative = function(){};\r\n\r\n/**\r\n * Applies the function(s) inside af's context to the value(s)\r\n *   inside av's context while preserving the context.\r\n */\r\ncats.protocols._fapply = (function cats$protocols$_fapply(app,af,av){\r\nif((((!((app == null)))) && ((!((app.cats$protocols$Applicative$_fapply$arity$3 == null)))))){\r\nreturn app.cats$protocols$Applicative$_fapply$arity$3(app,af,av);\r\n} else {\r\nvar x__4487__auto__ = (((app == null))?null:app);\r\nvar m__4488__auto__ = (cats.protocols._fapply[goog.typeOf(x__4487__auto__)]);\r\nif((!((m__4488__auto__ == null)))){\r\nreturn (m__4488__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4488__auto__.cljs$core$IFn$_invoke$arity$3(app,af,av) : m__4488__auto__.call(null,app,af,av));\r\n} else {\r\nvar m__4485__auto__ = (cats.protocols._fapply[\"_\"]);\r\nif((!((m__4485__auto__ == null)))){\r\nreturn (m__4485__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4485__auto__.cljs$core$IFn$_invoke$arity$3(app,af,av) : m__4485__auto__.call(null,app,af,av));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"Applicative.-fapply\",app);\r\n}\r\n}\r\n}\r\n});\r\n\r\n/**\r\n * Takes any context or monadic value `app` and any value `v`, and puts\r\n *   the value `v` in the most minimal context (normally `mempty`) of same type of `app`\r\n */\r\ncats.protocols._pure = (function cats$protocols$_pure(app,v){\r\nif((((!((app == null)))) && ((!((app.cats$protocols$Applicative$_pure$arity$2 == null)))))){\r\nreturn app.cats$protocols$Applicative$_pure$arity$2(app,v);\r\n} else {\r\nvar x__4487__auto__ = (((app == null))?null:app);\r\nvar m__4488__auto__ = (cats.protocols._pure[goog.typeOf(x__4487__auto__)]);\r\nif((!((m__4488__auto__ == null)))){\r\nreturn (m__4488__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4488__auto__.cljs$core$IFn$_invoke$arity$2(app,v) : m__4488__auto__.call(null,app,v));\r\n} else {\r\nvar m__4485__auto__ = (cats.protocols._pure[\"_\"]);\r\nif((!((m__4485__auto__ == null)))){\r\nreturn (m__4485__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4485__auto__.cljs$core$IFn$_invoke$arity$2(app,v) : m__4485__auto__.call(null,app,v));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"Applicative.-pure\",app);\r\n}\r\n}\r\n}\r\n});\r\n\r\n\r\n/**\r\n * Abstraction of data structures that can be folded to a summary value.\r\n * @interface\r\n */\r\ncats.protocols.Foldable = function(){};\r\n\r\n/**\r\n * Left-associative fold of a structure.\r\n */\r\ncats.protocols._foldl = (function cats$protocols$_foldl(fctx,f,z,xs){\r\nif((((!((fctx == null)))) && ((!((fctx.cats$protocols$Foldable$_foldl$arity$4 == null)))))){\r\nreturn fctx.cats$protocols$Foldable$_foldl$arity$4(fctx,f,z,xs);\r\n} else {\r\nvar x__4487__auto__ = (((fctx == null))?null:fctx);\r\nvar m__4488__auto__ = (cats.protocols._foldl[goog.typeOf(x__4487__auto__)]);\r\nif((!((m__4488__auto__ == null)))){\r\nreturn (m__4488__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4488__auto__.cljs$core$IFn$_invoke$arity$4(fctx,f,z,xs) : m__4488__auto__.call(null,fctx,f,z,xs));\r\n} else {\r\nvar m__4485__auto__ = (cats.protocols._foldl[\"_\"]);\r\nif((!((m__4485__auto__ == null)))){\r\nreturn (m__4485__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4485__auto__.cljs$core$IFn$_invoke$arity$4(fctx,f,z,xs) : m__4485__auto__.call(null,fctx,f,z,xs));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"Foldable.-foldl\",fctx);\r\n}\r\n}\r\n}\r\n});\r\n\r\n/**\r\n * Right-associative fold of a structure.\r\n */\r\ncats.protocols._foldr = (function cats$protocols$_foldr(fctx,f,z,xs){\r\nif((((!((fctx == null)))) && ((!((fctx.cats$protocols$Foldable$_foldr$arity$4 == null)))))){\r\nreturn fctx.cats$protocols$Foldable$_foldr$arity$4(fctx,f,z,xs);\r\n} else {\r\nvar x__4487__auto__ = (((fctx == null))?null:fctx);\r\nvar m__4488__auto__ = (cats.protocols._foldr[goog.typeOf(x__4487__auto__)]);\r\nif((!((m__4488__auto__ == null)))){\r\nreturn (m__4488__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4488__auto__.cljs$core$IFn$_invoke$arity$4(fctx,f,z,xs) : m__4488__auto__.call(null,fctx,f,z,xs));\r\n} else {\r\nvar m__4485__auto__ = (cats.protocols._foldr[\"_\"]);\r\nif((!((m__4485__auto__ == null)))){\r\nreturn (m__4485__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4485__auto__.cljs$core$IFn$_invoke$arity$4(fctx,f,z,xs) : m__4485__auto__.call(null,fctx,f,z,xs));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"Foldable.-foldr\",fctx);\r\n}\r\n}\r\n}\r\n});\r\n\r\n\r\n/**\r\n * Abstraction of data structures that can be traversed from left to right\r\n *   performing an action on every element.\r\n * @interface\r\n */\r\ncats.protocols.Traversable = function(){};\r\n\r\n/**\r\n * Map each element to an Applicative, evaluate the applicatives from left\r\n *   to right and collect the results.\r\n */\r\ncats.protocols._traverse = (function cats$protocols$_traverse(tctx,f,tv){\r\nif((((!((tctx == null)))) && ((!((tctx.cats$protocols$Traversable$_traverse$arity$3 == null)))))){\r\nreturn tctx.cats$protocols$Traversable$_traverse$arity$3(tctx,f,tv);\r\n} else {\r\nvar x__4487__auto__ = (((tctx == null))?null:tctx);\r\nvar m__4488__auto__ = (cats.protocols._traverse[goog.typeOf(x__4487__auto__)]);\r\nif((!((m__4488__auto__ == null)))){\r\nreturn (m__4488__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4488__auto__.cljs$core$IFn$_invoke$arity$3(tctx,f,tv) : m__4488__auto__.call(null,tctx,f,tv));\r\n} else {\r\nvar m__4485__auto__ = (cats.protocols._traverse[\"_\"]);\r\nif((!((m__4485__auto__ == null)))){\r\nreturn (m__4485__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4485__auto__.cljs$core$IFn$_invoke$arity$3(tctx,f,tv) : m__4485__auto__.call(null,tctx,f,tv));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"Traversable.-traverse\",tctx);\r\n}\r\n}\r\n}\r\n});\r\n\r\n\r\n/**\r\n * The Monad abstraction.\r\n * @interface\r\n */\r\ncats.protocols.Monad = function(){};\r\n\r\ncats.protocols._mreturn = (function cats$protocols$_mreturn(m,v){\r\nif((((!((m == null)))) && ((!((m.cats$protocols$Monad$_mreturn$arity$2 == null)))))){\r\nreturn m.cats$protocols$Monad$_mreturn$arity$2(m,v);\r\n} else {\r\nvar x__4487__auto__ = (((m == null))?null:m);\r\nvar m__4488__auto__ = (cats.protocols._mreturn[goog.typeOf(x__4487__auto__)]);\r\nif((!((m__4488__auto__ == null)))){\r\nreturn (m__4488__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4488__auto__.cljs$core$IFn$_invoke$arity$2(m,v) : m__4488__auto__.call(null,m,v));\r\n} else {\r\nvar m__4485__auto__ = (cats.protocols._mreturn[\"_\"]);\r\nif((!((m__4485__auto__ == null)))){\r\nreturn (m__4485__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4485__auto__.cljs$core$IFn$_invoke$arity$2(m,v) : m__4485__auto__.call(null,m,v));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"Monad.-mreturn\",m);\r\n}\r\n}\r\n}\r\n});\r\n\r\ncats.protocols._mbind = (function cats$protocols$_mbind(m,mv,f){\r\nif((((!((m == null)))) && ((!((m.cats$protocols$Monad$_mbind$arity$3 == null)))))){\r\nreturn m.cats$protocols$Monad$_mbind$arity$3(m,mv,f);\r\n} else {\r\nvar x__4487__auto__ = (((m == null))?null:m);\r\nvar m__4488__auto__ = (cats.protocols._mbind[goog.typeOf(x__4487__auto__)]);\r\nif((!((m__4488__auto__ == null)))){\r\nreturn (m__4488__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4488__auto__.cljs$core$IFn$_invoke$arity$3(m,mv,f) : m__4488__auto__.call(null,m,mv,f));\r\n} else {\r\nvar m__4485__auto__ = (cats.protocols._mbind[\"_\"]);\r\nif((!((m__4485__auto__ == null)))){\r\nreturn (m__4485__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4485__auto__.cljs$core$IFn$_invoke$arity$3(m,mv,f) : m__4485__auto__.call(null,m,mv,f));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"Monad.-mbind\",m);\r\n}\r\n}\r\n}\r\n});\r\n\r\n\r\n/**\r\n * A complement abstraction for monad that\r\n *   supports the notion of an identity element.\r\n * @interface\r\n */\r\ncats.protocols.MonadZero = function(){};\r\n\r\n/**\r\n * The identity element for the given monadzero.\r\n */\r\ncats.protocols._mzero = (function cats$protocols$_mzero(m){\r\nif((((!((m == null)))) && ((!((m.cats$protocols$MonadZero$_mzero$arity$1 == null)))))){\r\nreturn m.cats$protocols$MonadZero$_mzero$arity$1(m);\r\n} else {\r\nvar x__4487__auto__ = (((m == null))?null:m);\r\nvar m__4488__auto__ = (cats.protocols._mzero[goog.typeOf(x__4487__auto__)]);\r\nif((!((m__4488__auto__ == null)))){\r\nreturn (m__4488__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4488__auto__.cljs$core$IFn$_invoke$arity$1(m) : m__4488__auto__.call(null,m));\r\n} else {\r\nvar m__4485__auto__ = (cats.protocols._mzero[\"_\"]);\r\nif((!((m__4485__auto__ == null)))){\r\nreturn (m__4485__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4485__auto__.cljs$core$IFn$_invoke$arity$1(m) : m__4485__auto__.call(null,m));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"MonadZero.-mzero\",m);\r\n}\r\n}\r\n}\r\n});\r\n\r\n\r\n/**\r\n * A complement abstraction for Monad that\r\n *   supports the notion of addition.\r\n * @interface\r\n */\r\ncats.protocols.MonadPlus = function(){};\r\n\r\n/**\r\n * An associative addition operation.\r\n */\r\ncats.protocols._mplus = (function cats$protocols$_mplus(m,mv,mv_SINGLEQUOTE_){\r\nif((((!((m == null)))) && ((!((m.cats$protocols$MonadPlus$_mplus$arity$3 == null)))))){\r\nreturn m.cats$protocols$MonadPlus$_mplus$arity$3(m,mv,mv_SINGLEQUOTE_);\r\n} else {\r\nvar x__4487__auto__ = (((m == null))?null:m);\r\nvar m__4488__auto__ = (cats.protocols._mplus[goog.typeOf(x__4487__auto__)]);\r\nif((!((m__4488__auto__ == null)))){\r\nreturn (m__4488__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4488__auto__.cljs$core$IFn$_invoke$arity$3(m,mv,mv_SINGLEQUOTE_) : m__4488__auto__.call(null,m,mv,mv_SINGLEQUOTE_));\r\n} else {\r\nvar m__4485__auto__ = (cats.protocols._mplus[\"_\"]);\r\nif((!((m__4485__auto__ == null)))){\r\nreturn (m__4485__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4485__auto__.cljs$core$IFn$_invoke$arity$3(m,mv,mv_SINGLEQUOTE_) : m__4485__auto__.call(null,m,mv,mv_SINGLEQUOTE_));\r\n} else {\r\nthrow cljs.core.missing_protocol(\"MonadPlus.-mplus\",m);\r\n}\r\n}\r\n}\r\n});\r\n\r\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:doc","A collection of protocols upon which the cats abstractions are built.\n\n  NOTE: Functions of this namespace are not intended to be used directly.\n  It is considered internal api.","~:file","cats/protocols.cljc","~:line",26,"~:column",5,"~:end-line",26,"~:end-column",19],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$react-dom","~$module$node_modules$react_dom$index"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$cats.protocols","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$cljs.core","^L","~$goog","^M"],"~:seen",["^E",[]],"~:uses",null,"~:require-macros",["^ ","^L","^L"],"~:form",["~#list",["~$ns","^G","A collection of protocols upon which the cats abstractions are built.\n\n  NOTE: Functions of this namespace are not intended to be used directly.\n  It is considered internal api."]],"~:flags",["^ "],"~:js-deps",["^ "],"~:deps",["^M","^L"]],"^I","^G","~:resource-id",["~:shadow.build.classpath/resource","cats/protocols.cljc"],"~:compiled-at",1579687555569,"~:resource-name","cats/protocols.cljc","~:warnings",[],"~:source",";; Copyright (c) 2014-2016 Andrey Antukh <niwi@niwi.nz>\n;; Copyright (c) 2014-2016 Alejandro GÃ³mez <alejandro@dialelo.com>\n;; All rights reserved.\n;;\n;; Redistribution and use in source and binary forms, with or without\n;; modification, are permitted provided that the following conditions\n;; are met:\n;;\n;; 1. Redistributions of source code must retain the above copyright\n;;    notice, this list of conditions and the following disclaimer.\n;; 2. Redistributions in binary form must reproduce the above copyright\n;;    notice, this list of conditions and the following disclaimer in the\n;;    documentation and/or other materials provided with the distribution.\n;;\n;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n;; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n;; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n;; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n;; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n;; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n(ns cats.protocols\n  \"A collection of protocols upon which the cats abstractions are built.\n\n  NOTE: Functions of this namespace are not intended to be used directly.\n  It is considered internal api.\")\n\n(defprotocol Context\n  \"A marker protocol for identifying the valid context types.\")\n\n(defprotocol Contextual\n  \"Abstraction that establishes a concrete type as a member of a context.\n\n  A great example is the Maybe monad type Just. It implements\n  this abstraction to establish that Just is part of\n  the Maybe monad.\"\n  (-get-context [_] \"Get the context associated with the type.\"))\n\n(defprotocol Printable\n  \"An abstraction to make a type printable in a platform\n  independent manner.\"\n  (-repr ^String [_] \"Get the repl ready representation of the object.\"))\n\n(defprotocol Semigroup\n  \"A structure with an associative binary operation.\"\n  (-mappend [s sv sv'] \"An associative addition operation.\"))\n\n(defprotocol Monoid\n  \"A Semigroup which has an identity element with respect to an associative binary operation.\"\n  (-mempty [s] \"The identity element for the given monoid.\"))\n\n(defprotocol Extract\n  \"A type class to extract the\n  value from a monad context.\"\n  (-extract [mv] \"Extract the value from monad context.\"))\n\n(defprotocol Functor\n  \"A data type that can be mapped over without altering its context.\"\n  (-fmap [ftor f fv] \"Applies function f to the value(s) inside the context of the functor fv.\"))\n\n(defprotocol Bifunctor\n  \"A 'Functor' of two arguments.\"\n  (-bimap  [btor f g bv] \"Map over both arguments at the same time.\"))\n\n(defprotocol Applicative\n  \"The Applicative abstraction.\"\n  (-fapply [app af av]\n    \"Applies the function(s) inside af's context to the value(s)\n     inside av's context while preserving the context.\")\n  (-pure [app v]\n    \"Takes any context or monadic value `app` and any value `v`, and puts\n     the value `v` in the most minimal context (normally `mempty`) of same type of `app`\"))\n\n(defprotocol Foldable\n  \"Abstraction of data structures that can be folded to a summary value.\"\n  (-foldl [fctx f z xs] \"Left-associative fold of a structure.\")\n  (-foldr [fctx f z xs] \"Right-associative fold of a structure.\"))\n\n(defprotocol Traversable\n  \"Abstraction of data structures that can be traversed from left to right\n  performing an action on every element.\"\n  (-traverse [tctx f tv]\n    \"Map each element to an Applicative, evaluate the applicatives from left\n     to right and collect the results.\"))\n\n(defprotocol Monad\n  \"The Monad abstraction.\"\n  (-mreturn [m v])\n  (-mbind [m mv f]))\n\n(defprotocol MonadZero\n  \"A complement abstraction for monad that\n  supports the notion of an identity element.\"\n  (-mzero [m] \"The identity element for the given monadzero.\"))\n\n(defprotocol MonadPlus\n  \"A complement abstraction for Monad that\n  supports the notion of addition.\"\n  (-mplus [m mv mv'] \"An associative addition operation.\"))\n","~:reader-features",["^E",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["cats.protocols/Context","x__4487__auto__","m__4488__auto__","cats.protocols/-get-context","goog/typeOf","m__4485__auto__","cljs.core/missing-protocol","cats.protocols/Contextual","_","cats.protocols/-repr","cats.protocols/Printable","cats.protocols/-mappend","cats.protocols/Semigroup","s","sv","sv'","cats.protocols/-mempty","cats.protocols/Monoid","cats.protocols/-extract","cats.protocols/Extract","mv","cats.protocols/-fmap","cats.protocols/Functor","ftor","f","fv","cats.protocols/-bimap","cats.protocols/Bifunctor","btor","g","bv","cats.protocols/-fapply","cats.protocols/-pure","cats.protocols/Applicative","app","af","av","v","cats.protocols/-foldl","cats.protocols/-foldr","cats.protocols/Foldable","fctx","z","xs","cats.protocols/-traverse","cats.protocols/Traversable","tctx","tv","cats.protocols/-mreturn","cats.protocols/-mbind","cats.protocols/Monad","m","cats.protocols/-mzero","cats.protocols/MonadZero","cats.protocols/-mplus","cats.protocols/MonadPlus","mv'"]]],"~:cache-keys",["~#cmap",[["^X","goog/dom/tagname.js"],[1579687410012,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^E",[]],"~:deps-syms",["^M","~$goog.dom.HtmlElement"]]],["^X","goog/math/math.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","~$goog.array","~$goog.asserts"]]],["^X","goog/html/trustedtypes.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M"]]],["^X","goog/labs/useragent/browser.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1>","~$goog.labs.userAgent.util","~$goog.object","~$goog.string.internal"]]],["^X","goog/html/safeurl.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1?","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^1B"]]],["^X","goog/array/array.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1?"]]],["^X","goog/debug/error.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M"]]],["^X","cats/protocols.cljc"],[1579687471496,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^L"]]],["^X","goog/dom/nodetype.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M"]]],["^X","goog/string/typedstring.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M"]]],["^X","goog/object/object.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M"]]],["^X","goog/dom/asserts.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1?"]]],"~:SHADOW-TIMESTAMP",[1579687469000,1579687405000],["^X","goog/math/long.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1?","~$goog.reflect"]]],["^X","goog/html/trustedresourceurl.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1?","~$goog.html.trustedtypes","^1E","^1F","^1G","^1H"]]],["^X","goog/string/internal.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M"]]],["^X","goog/functions/functions.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M"]]],["^X","goog/html/safestyle.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1>","^1?","~$goog.html.SafeUrl","^1G","^1H","^1B"]]],["^X","goog/dom/safe.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1?","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","~$goog.html.SafeScript","~$goog.html.SafeStyle","^1L","^1D","~$goog.html.uncheckedconversions","^1G","^1B"]]],["^X","goog/structs/map.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^X","goog/html/safehtml.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1>","^1?","~$goog.dom.TagName","~$goog.dom.tags","^1P","^1Q","~$goog.html.SafeStyleSheet","^1L","^1D","^1K","^1E","^1F","~$goog.labs.userAgent.browser","^1A","^1G","^1H","^1B"]]],["^X","goog/dom/tags.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1A"]]],["^X","goog/asserts/asserts.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^X","goog/uri/uri.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1>","^1?","~$goog.string","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^X","goog/i18n/bidi.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M"]]],["^X","goog/fs/url.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M"]]],["^X","goog/base.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",[]]],["^X","goog/structs/structs.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1>","^1A"]]],["^X","goog/string/string.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","~$goog.dom.safe","^1R","^1G","^1B"]]],["^X","goog/reflect/reflect.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M"]]],["^X","goog/labs/useragent/util.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1B"]]],["^X","goog/string/stringbuffer.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M"]]],["^X","goog/iter/iter.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1>","^1?","^1N","~$goog.math"]]],["^X","goog/html/uncheckedconversions.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1?","^1O","^1P","^1Q","^1W","^1L","^1D","^1G","^1B"]]],["^X","goog/dom/htmlelement.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M"]]],["^X","cljs/core.cljs"],[1579687405264,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["~$goog.math.Long","~$goog.math.Integer","^1[","^1A","^1>","~$goog.Uri","~$goog.string.StringBuffer"]]],["^X","goog/html/safescript.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1?","^1K","^1G","^1H"]]],["^X","goog/html/safestylesheet.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1>","^1?","^1Q","^1A","^1G","^1H","^1B"]]],["^X","goog/math/integer.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1J"]]],["^X","goog/uri/utils.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1>","^1?","^1["]]],["^X","goog/string/const.js"],[1579687410012,"^19",["^ ","^1:",null,"^1;",["^E",[]],"^1<",["^M","^1?","^1H"]]]]],"~:clj-info",["^ ","jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/source_map.clj",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/default_data_readers.clj",1579687401000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/source_map/base64.clj",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/set.clj",1579687402000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/string.clj",1579687402000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/analyzer.cljc",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/java/io.clj",1579687402000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/tagged_literals.cljc",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/util.cljc",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/compiler.cljc",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/source_map/base64_vlq.clj",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/core.clj",1579687402000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/impl/errors.clj",1579687401000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader.clj",1579687401000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/externs.clj",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/impl/inspect.clj",1579687401000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/js_deps.cljc",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/reader_types.clj",1579687401000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/data.json/0.2.6/data.json-0.2.6.jar!/clojure/data/json.clj",1579687401000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/edn.clj",1579687402000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/pprint.clj",1579687402000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/instant.clj",1579687402000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/core.cljc",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/env.cljc",1579687405000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","A collection of protocols upon which the cats abstractions are built.\n\n  NOTE: Functions of this namespace are not intended to be used directly.\n  It is considered internal api.","^7","cats/protocols.cljc","^8",26,"^9",5,"^:",26,"^;",19],"^<",["^ ","^=","^>","^?","^@","^A","^B"],"~:shadow/protocol-prefixes",["^E",["cats$protocols$MonadPlus$","cats$protocols$Semigroup$","cats$protocols$Bifunctor$","cats$protocols$Extract$","cats$protocols$Foldable$","cats$protocols$Monad$","cats$protocols$Functor$","cats$protocols$Printable$","cats$protocols$MonadZero$","cats$protocols$Applicative$","cats$protocols$Contextual$","cats$protocols$Monoid$","cats$protocols$Traversable$"]],"^C",null,"^D",["^E",[]],"^F","^G","^J",null,"^K",["^ ","^L","^L","^M","^M"],"^N",["^E",[]],"^O",null,"~:defs",["^ ","~$Monad",["^ ","^5",["^ ","~:protocol-symbol",true,"^7","cats/protocols.cljc","^;",19,"^9",14,"^8",90,"~:protocol-info",["^ ","~:methods",["^ ","~$-mreturn",[["~$m","~$v"]],"~$-mbind",[["~$m","~$mv","~$f"]]]],"^:",90,"~:sigs",["^ ","~:-mreturn",["^ ","^F","^2[","~:arglists",["^R",[["~$m","~$v"]]],"^6",null],"~:-mbind",["^ ","^F","^30","^34",["^R",[["~$m","^31","~$f"]]],"^6",null]],"^6","The Monad abstraction.","~:jsdoc",["^R",["@interface"]]],"^2X",true,"^F","~$cats.protocols/Monad","^7","cats/protocols.cljc","^;",19,"^9",1,"^8",90,"^2Y",["^ ","^2Z",["^ ","^2[",[["~$m","~$v"]],"^30",[["~$m","^31","~$f"]]]],"~:info",null,"^:",90,"~:tag","~$any","^32",["^ ","^33",["^ ","^F","^2[","^34",["^R",[["~$m","~$v"]]],"^6",null],"^35",["^ ","^F","^30","^34",["^R",[["~$m","^31","~$f"]]],"^6",null]],"~:impls",["^E",[]],"^6","The Monad abstraction.","^36",["^R",["@interface"]]],"~$Functor",["^ ","^5",["^ ","^2X",true,"^7","cats/protocols.cljc","^;",21,"^9",14,"^8",61,"^2Y",["^ ","^2Z",["^ ","~$-fmap",[["~$ftor","~$f","~$fv"]]]],"^:",61,"^32",["^ ","~:-fmap",["^ ","^F","^3=","^34",["^R",[["^3>","~$f","^3?"]]],"^6","Applies function f to the value(s) inside the context of the functor fv."]],"^6","A data type that can be mapped over without altering its context.","^36",["^R",["@interface"]]],"^2X",true,"^F","~$cats.protocols/Functor","^7","cats/protocols.cljc","^;",21,"^9",1,"^8",61,"^2Y",["^ ","^2Z",["^ ","^3=",[["^3>","~$f","^3?"]]]],"^38",null,"^:",61,"^39","^3:","^32",["^ ","^3@",["^ ","^F","^3=","^34",["^R",[["^3>","~$f","^3?"]]],"^6","Applies function f to the value(s) inside the context of the functor fv."]],"^3;",["^E",[]],"^6","A data type that can be mapped over without altering its context.","^36",["^R",["@interface"]]],"~$-mempty",["^ ","~:protocol-inline",null,"^5",["^ ","^7","cats/protocols.cljc","^8",54,"^9",4,"^:",54,"^;",11,"~:protocol","~$cats.protocols/Monoid","^6","The identity element for the given monoid.","^34",["^R",["~$quote",["^R",[["~$s"]]]]]],"^3D","^3E","^F","~$cats.protocols/-mempty","^7","cats/protocols.cljc","^;",11,"~:method-params",["^R",[["~$s"]]],"~:protocol-impl",null,"~:arglists-meta",["^R",[null,null]],"^9",1,"~:variadic?",false,"^8",52,"~:ret-tag","^3:","^:",54,"~:max-fixed-arity",1,"~:fn-var",true,"^34",["^R",["^3F",["^R",[["~$s"]]]]],"^6","The identity element for the given monoid."],"~$-fapply",["^ ","^3C",null,"^5",["^ ","^7","cats/protocols.cljc","^8",71,"^9",4,"^:",71,"^;",11,"^3D","~$cats.protocols/Applicative","^6","Applies the function(s) inside af's context to the value(s)\n     inside av's context while preserving the context.","^34",["^R",["^3F",["^R",[["~$app","~$af","~$av"]]]]]],"^3D","^3P","^F","~$cats.protocols/-fapply","^7","cats/protocols.cljc","^;",11,"^3H",["^R",[["^3Q","^3R","^3S"]]],"^3I",null,"^3J",["^R",[null,null]],"^9",1,"^3K",false,"^8",69,"^3L","^3:","^:",71,"^3M",3,"^3N",true,"^34",["^R",["^3F",["^R",[["^3Q","^3R","^3S"]]]]],"^6","Applies the function(s) inside af's context to the value(s)\n     inside av's context while preserving the context."],"~$Applicative",["^ ","^5",["^ ","^2X",true,"^7","cats/protocols.cljc","^;",25,"^9",14,"^8",69,"^2Y",["^ ","^2Z",["^ ","^3O",[["^3Q","^3R","^3S"]],"~$-pure",[["^3Q","~$v"]]]],"^:",69,"^32",["^ ","~:-fapply",["^ ","^F","^3O","^34",["^R",[["^3Q","^3R","^3S"]]],"^6","Applies the function(s) inside af's context to the value(s)\n     inside av's context while preserving the context."],"~:-pure",["^ ","^F","^3V","^34",["^R",[["^3Q","~$v"]]],"^6","Takes any context or monadic value `app` and any value `v`, and puts\n     the value `v` in the most minimal context (normally `mempty`) of same type of `app`"]],"^6","The Applicative abstraction.","^36",["^R",["@interface"]]],"^2X",true,"^F","^3P","^7","cats/protocols.cljc","^;",25,"^9",1,"^8",69,"^2Y",["^ ","^2Z",["^ ","^3O",[["^3Q","^3R","^3S"]],"^3V",[["^3Q","~$v"]]]],"^38",null,"^:",69,"^39","^3:","^32",["^ ","^3W",["^ ","^F","^3O","^34",["^R",[["^3Q","^3R","^3S"]]],"^6","Applies the function(s) inside af's context to the value(s)\n     inside av's context while preserving the context."],"^3X",["^ ","^F","^3V","^34",["^R",[["^3Q","~$v"]]],"^6","Takes any context or monadic value `app` and any value `v`, and puts\n     the value `v` in the most minimal context (normally `mempty`) of same type of `app`"]],"^3;",["^E",[]],"^6","The Applicative abstraction.","^36",["^R",["@interface"]]],"~$-foldl",["^ ","^3C",null,"^5",["^ ","^7","cats/protocols.cljc","^8",80,"^9",4,"^:",80,"^;",10,"^3D","~$cats.protocols/Foldable","^6","Left-associative fold of a structure.","^34",["^R",["^3F",["^R",[["~$fctx","~$f","~$z","~$xs"]]]]]],"^3D","^3Z","^F","~$cats.protocols/-foldl","^7","cats/protocols.cljc","^;",10,"^3H",["^R",[["^3[","~$f","~$z","^40"]]],"^3I",null,"^3J",["^R",[null,null]],"^9",1,"^3K",false,"^8",78,"^3L","^3:","^:",80,"^3M",4,"^3N",true,"^34",["^R",["^3F",["^R",[["^3[","~$f","~$z","^40"]]]]],"^6","Left-associative fold of a structure."],"~$Bifunctor",["^ ","^5",["^ ","^2X",true,"^7","cats/protocols.cljc","^;",23,"^9",14,"^8",65,"^2Y",["^ ","^2Z",["^ ","~$-bimap",[["~$btor","~$f","~$g","~$bv"]]]],"^:",65,"^32",["^ ","~:-bimap",["^ ","^F","^43","^34",["^R",[["^44","~$f","~$g","^45"]]],"^6","Map over both arguments at the same time."]],"^6","A 'Functor' of two arguments.","^36",["^R",["@interface"]]],"^2X",true,"^F","~$cats.protocols/Bifunctor","^7","cats/protocols.cljc","^;",23,"^9",1,"^8",65,"^2Y",["^ ","^2Z",["^ ","^43",[["^44","~$f","~$g","^45"]]]],"^38",null,"^:",65,"^39","^3:","^32",["^ ","^46",["^ ","^F","^43","^34",["^R",[["^44","~$f","~$g","^45"]]],"^6","Map over both arguments at the same time."]],"^3;",["^E",[]],"^6","A 'Functor' of two arguments.","^36",["^R",["@interface"]]],"^30",["^ ","^3C",null,"^5",["^ ","^7","cats/protocols.cljc","^8",93,"^9",4,"^:",93,"^;",10,"^3D","^37","^6",null,"^34",["^R",["^3F",["^R",[["~$m","^31","~$f"]]]]]],"^3D","^37","^F","~$cats.protocols/-mbind","^7","cats/protocols.cljc","^;",10,"^3H",["^R",[["~$m","^31","~$f"]]],"^3I",null,"^3J",["^R",[null,null]],"^9",1,"^3K",false,"^8",90,"^3L","^3:","^:",93,"^3M",3,"^3N",true,"^34",["^R",["^3F",["^R",[["~$m","^31","~$f"]]]]],"^6",null],"~$Printable",["^ ","^5",["^ ","^2X",true,"^7","cats/protocols.cljc","^;",23,"^9",14,"^8",43,"^2Y",["^ ","^2Z",["^ ","~$-repr",[["~$_"]]]],"^:",43,"^32",["^ ","~:-repr",["^ ","^F","^4:","^34",["^R",[["~$_"]]],"^6","Get the repl ready representation of the object."]],"^6","An abstraction to make a type printable in a platform\n  independent manner.","^36",["^R",["@interface"]]],"^2X",true,"^F","~$cats.protocols/Printable","^7","cats/protocols.cljc","^;",23,"^9",1,"^8",43,"^2Y",["^ ","^2Z",["^ ","^4:",[["~$_"]]]],"^38",null,"^:",43,"^39","^3:","^32",["^ ","^4;",["^ ","^F","^4:","^34",["^R",[["~$_"]]],"^6","Get the repl ready representation of the object."]],"^3;",["^E",[]],"^6","An abstraction to make a type printable in a platform\n  independent manner.","^36",["^R",["@interface"]]],"~$Contextual",["^ ","^5",["^ ","^2X",true,"^7","cats/protocols.cljc","^;",24,"^9",14,"^8",35,"^2Y",["^ ","^2Z",["^ ","~$-get-context",[["~$_"]]]],"^:",35,"^32",["^ ","~:-get-context",["^ ","^F","^4>","^34",["^R",[["~$_"]]],"^6","Get the context associated with the type."]],"^6","Abstraction that establishes a concrete type as a member of a context.\n\n  A great example is the Maybe monad type Just. It implements\n  this abstraction to establish that Just is part of\n  the Maybe monad.","^36",["^R",["@interface"]]],"^2X",true,"^F","~$cats.protocols/Contextual","^7","cats/protocols.cljc","^;",24,"^9",1,"^8",35,"^2Y",["^ ","^2Z",["^ ","^4>",[["~$_"]]]],"^38",null,"^:",35,"^39","^3:","^32",["^ ","^4?",["^ ","^F","^4>","^34",["^R",[["~$_"]]],"^6","Get the context associated with the type."]],"^3;",["^E",[]],"^6","Abstraction that establishes a concrete type as a member of a context.\n\n  A great example is the Maybe monad type Just. It implements\n  this abstraction to establish that Just is part of\n  the Maybe monad.","^36",["^R",["@interface"]]],"~$-traverse",["^ ","^3C",null,"^5",["^ ","^7","cats/protocols.cljc","^8",86,"^9",4,"^:",86,"^;",13,"^3D","~$cats.protocols/Traversable","^6","Map each element to an Applicative, evaluate the applicatives from left\n     to right and collect the results.","^34",["^R",["^3F",["^R",[["~$tctx","~$f","~$tv"]]]]]],"^3D","^4B","^F","~$cats.protocols/-traverse","^7","cats/protocols.cljc","^;",13,"^3H",["^R",[["^4C","~$f","^4D"]]],"^3I",null,"^3J",["^R",[null,null]],"^9",1,"^3K",false,"^8",83,"^3L","^3:","^:",86,"^3M",3,"^3N",true,"^34",["^R",["^3F",["^R",[["^4C","~$f","^4D"]]]]],"^6","Map each element to an Applicative, evaluate the applicatives from left\n     to right and collect the results."],"~$-foldr",["^ ","^3C",null,"^5",["^ ","^7","cats/protocols.cljc","^8",81,"^9",4,"^:",81,"^;",10,"^3D","^3Z","^6","Right-associative fold of a structure.","^34",["^R",["^3F",["^R",[["^3[","~$f","~$z","^40"]]]]]],"^3D","^3Z","^F","~$cats.protocols/-foldr","^7","cats/protocols.cljc","^;",10,"^3H",["^R",[["^3[","~$f","~$z","^40"]]],"^3I",null,"^3J",["^R",[null,null]],"^9",1,"^3K",false,"^8",78,"^3L","^3:","^:",81,"^3M",4,"^3N",true,"^34",["^R",["^3F",["^R",[["^3[","~$f","~$z","^40"]]]]],"^6","Right-associative fold of a structure."],"~$-extract",["^ ","^3C",null,"^5",["^ ","^7","cats/protocols.cljc","^8",59,"^9",4,"^:",59,"^;",12,"^3D","~$cats.protocols/Extract","^6","Extract the value from monad context.","^34",["^R",["^3F",["^R",[["^31"]]]]]],"^3D","^4I","^F","~$cats.protocols/-extract","^7","cats/protocols.cljc","^;",12,"^3H",["^R",[["^31"]]],"^3I",null,"^3J",["^R",[null,null]],"^9",1,"^3K",false,"^8",56,"^3L","^3:","^:",59,"^3M",1,"^3N",true,"^34",["^R",["^3F",["^R",[["^31"]]]]],"^6","Extract the value from monad context."],"~$MonadPlus",["^ ","^5",["^ ","^2X",true,"^7","cats/protocols.cljc","^;",23,"^9",14,"^8",100,"^2Y",["^ ","^2Z",["^ ","~$-mplus",[["~$m","^31","~$mv'"]]]],"^:",100,"^32",["^ ","~:-mplus",["^ ","^F","^4L","^34",["^R",[["~$m","^31","^4M"]]],"^6","An associative addition operation."]],"^6","A complement abstraction for Monad that\n  supports the notion of addition.","^36",["^R",["@interface"]]],"^2X",true,"^F","~$cats.protocols/MonadPlus","^7","cats/protocols.cljc","^;",23,"^9",1,"^8",100,"^2Y",["^ ","^2Z",["^ ","^4L",[["~$m","^31","^4M"]]]],"^38",null,"^:",100,"^39","^3:","^32",["^ ","^4N",["^ ","^F","^4L","^34",["^R",[["~$m","^31","^4M"]]],"^6","An associative addition operation."]],"^3;",["^E",[]],"^6","A complement abstraction for Monad that\n  supports the notion of addition.","^36",["^R",["@interface"]]],"^4:",["^ ","^3C",null,"^5",["^ ","^7","cats/protocols.cljc","^8",46,"^9",4,"^:",46,"^;",9,"^3D","^4<","^6","Get the repl ready representation of the object.","^34",["^R",["^3F",["^R",[["~$_"]]]]]],"^3D","^4<","^F","~$cats.protocols/-repr","^7","cats/protocols.cljc","^;",9,"^3H",["^R",[["~$_"]]],"^3I",null,"^3J",["^R",[null,null]],"^9",1,"^3K",false,"^8",43,"^3L","^3:","^:",46,"^3M",1,"^3N",true,"^34",["^R",["^3F",["^R",[["~$_"]]]]],"^6","Get the repl ready representation of the object."],"~$-mzero",["^ ","^3C",null,"^5",["^ ","^7","cats/protocols.cljc","^8",98,"^9",4,"^:",98,"^;",10,"^3D","~$cats.protocols/MonadZero","^6","The identity element for the given monadzero.","^34",["^R",["^3F",["^R",[["~$m"]]]]]],"^3D","^4R","^F","~$cats.protocols/-mzero","^7","cats/protocols.cljc","^;",10,"^3H",["^R",[["~$m"]]],"^3I",null,"^3J",["^R",[null,null]],"^9",1,"^3K",false,"^8",95,"^3L","^3:","^:",98,"^3M",1,"^3N",true,"^34",["^R",["^3F",["^R",[["~$m"]]]]],"^6","The identity element for the given monadzero."],"^2[",["^ ","^3C",null,"^5",["^ ","^7","cats/protocols.cljc","^8",92,"^9",4,"^:",92,"^;",12,"^3D","^37","^6",null,"^34",["^R",["^3F",["^R",[["~$m","~$v"]]]]]],"^3D","^37","^F","~$cats.protocols/-mreturn","^7","cats/protocols.cljc","^;",12,"^3H",["^R",[["~$m","~$v"]]],"^3I",null,"^3J",["^R",[null,null]],"^9",1,"^3K",false,"^8",90,"^3L","^3:","^:",92,"^3M",2,"^3N",true,"^34",["^R",["^3F",["^R",[["~$m","~$v"]]]]],"^6",null],"^3V",["^ ","^3C",null,"^5",["^ ","^7","cats/protocols.cljc","^8",74,"^9",4,"^:",74,"^;",9,"^3D","^3P","^6","Takes any context or monadic value `app` and any value `v`, and puts\n     the value `v` in the most minimal context (normally `mempty`) of same type of `app`","^34",["^R",["^3F",["^R",[["^3Q","~$v"]]]]]],"^3D","^3P","^F","~$cats.protocols/-pure","^7","cats/protocols.cljc","^;",9,"^3H",["^R",[["^3Q","~$v"]]],"^3I",null,"^3J",["^R",[null,null]],"^9",1,"^3K",false,"^8",69,"^3L","^3:","^:",74,"^3M",2,"^3N",true,"^34",["^R",["^3F",["^R",[["^3Q","~$v"]]]]],"^6","Takes any context or monadic value `app` and any value `v`, and puts\n     the value `v` in the most minimal context (normally `mempty`) of same type of `app`"],"^3=",["^ ","^3C",null,"^5",["^ ","^7","cats/protocols.cljc","^8",63,"^9",4,"^:",63,"^;",9,"^3D","^3A","^6","Applies function f to the value(s) inside the context of the functor fv.","^34",["^R",["^3F",["^R",[["^3>","~$f","^3?"]]]]]],"^3D","^3A","^F","~$cats.protocols/-fmap","^7","cats/protocols.cljc","^;",9,"^3H",["^R",[["^3>","~$f","^3?"]]],"^3I",null,"^3J",["^R",[null,null]],"^9",1,"^3K",false,"^8",61,"^3L","^3:","^:",63,"^3M",3,"^3N",true,"^34",["^R",["^3F",["^R",[["^3>","~$f","^3?"]]]]],"^6","Applies function f to the value(s) inside the context of the functor fv."],"~$MonadZero",["^ ","^5",["^ ","^2X",true,"^7","cats/protocols.cljc","^;",23,"^9",14,"^8",95,"^2Y",["^ ","^2Z",["^ ","^4Q",[["~$m"]]]],"^:",95,"^32",["^ ","~:-mzero",["^ ","^F","^4Q","^34",["^R",[["~$m"]]],"^6","The identity element for the given monadzero."]],"^6","A complement abstraction for monad that\n  supports the notion of an identity element.","^36",["^R",["@interface"]]],"^2X",true,"^F","^4R","^7","cats/protocols.cljc","^;",23,"^9",1,"^8",95,"^2Y",["^ ","^2Z",["^ ","^4Q",[["~$m"]]]],"^38",null,"^:",95,"^39","^3:","^32",["^ ","^4X",["^ ","^F","^4Q","^34",["^R",[["~$m"]]],"^6","The identity element for the given monadzero."]],"^3;",["^E",[]],"^6","A complement abstraction for monad that\n  supports the notion of an identity element.","^36",["^R",["@interface"]]],"~$Semigroup",["^ ","^5",["^ ","^2X",true,"^7","cats/protocols.cljc","^;",23,"^9",14,"^8",48,"^2Y",["^ ","^2Z",["^ ","~$-mappend",[["~$s","~$sv","~$sv'"]]]],"^:",48,"^32",["^ ","~:-mappend",["^ ","^F","^4Z","^34",["^R",[["~$s","^4[","^50"]]],"^6","An associative addition operation."]],"^6","A structure with an associative binary operation.","^36",["^R",["@interface"]]],"^2X",true,"^F","~$cats.protocols/Semigroup","^7","cats/protocols.cljc","^;",23,"^9",1,"^8",48,"^2Y",["^ ","^2Z",["^ ","^4Z",[["~$s","^4[","^50"]]]],"^38",null,"^:",48,"^39","^3:","^32",["^ ","^51",["^ ","^F","^4Z","^34",["^R",[["~$s","^4[","^50"]]],"^6","An associative addition operation."]],"^3;",["^E",[]],"^6","A structure with an associative binary operation.","^36",["^R",["@interface"]]],"~$Traversable",["^ ","^5",["^ ","^2X",true,"^7","cats/protocols.cljc","^;",25,"^9",14,"^8",83,"^2Y",["^ ","^2Z",["^ ","^4A",[["^4C","~$f","^4D"]]]],"^:",83,"^32",["^ ","~:-traverse",["^ ","^F","^4A","^34",["^R",[["^4C","~$f","^4D"]]],"^6","Map each element to an Applicative, evaluate the applicatives from left\n     to right and collect the results."]],"^6","Abstraction of data structures that can be traversed from left to right\n  performing an action on every element.","^36",["^R",["@interface"]]],"^2X",true,"^F","^4B","^7","cats/protocols.cljc","^;",25,"^9",1,"^8",83,"^2Y",["^ ","^2Z",["^ ","^4A",[["^4C","~$f","^4D"]]]],"^38",null,"^:",83,"^39","^3:","^32",["^ ","^54",["^ ","^F","^4A","^34",["^R",[["^4C","~$f","^4D"]]],"^6","Map each element to an Applicative, evaluate the applicatives from left\n     to right and collect the results."]],"^3;",["^E",[]],"^6","Abstraction of data structures that can be traversed from left to right\n  performing an action on every element.","^36",["^R",["@interface"]]],"~$Monoid",["^ ","^5",["^ ","^2X",true,"^7","cats/protocols.cljc","^;",20,"^9",14,"^8",52,"^2Y",["^ ","^2Z",["^ ","^3B",[["~$s"]]]],"^:",52,"^32",["^ ","~:-mempty",["^ ","^F","^3B","^34",["^R",[["~$s"]]],"^6","The identity element for the given monoid."]],"^6","A Semigroup which has an identity element with respect to an associative binary operation.","^36",["^R",["@interface"]]],"^2X",true,"^F","^3E","^7","cats/protocols.cljc","^;",20,"^9",1,"^8",52,"^2Y",["^ ","^2Z",["^ ","^3B",[["~$s"]]]],"^38",null,"^:",52,"^39","^3:","^32",["^ ","^56",["^ ","^F","^3B","^34",["^R",[["~$s"]]],"^6","The identity element for the given monoid."]],"^3;",["^E",[]],"^6","A Semigroup which has an identity element with respect to an associative binary operation.","^36",["^R",["@interface"]]],"~$Context",["^ ","^5",["^ ","^2X",true,"^7","cats/protocols.cljc","^;",21,"^9",14,"^8",32,"^2Y",["^ ","^2Z",["^ "]],"^:",32,"^32",["^ "],"^6","A marker protocol for identifying the valid context types.","^36",["^R",["@interface"]]],"^2X",true,"^F","~$cats.protocols/Context","^7","cats/protocols.cljc","^;",21,"^9",1,"^8",32,"^2Y",["^ ","^2Z",["^ "]],"^38",null,"^:",32,"^39","^3:","^32",["^ "],"^3;",["^E",[]],"^6","A marker protocol for identifying the valid context types.","^36",["^R",["@interface"]]],"~$Extract",["^ ","^5",["^ ","^2X",true,"^7","cats/protocols.cljc","^;",21,"^9",14,"^8",56,"^2Y",["^ ","^2Z",["^ ","^4H",[["^31"]]]],"^:",56,"^32",["^ ","~:-extract",["^ ","^F","^4H","^34",["^R",[["^31"]]],"^6","Extract the value from monad context."]],"^6","A type class to extract the\n  value from a monad context.","^36",["^R",["@interface"]]],"^2X",true,"^F","^4I","^7","cats/protocols.cljc","^;",21,"^9",1,"^8",56,"^2Y",["^ ","^2Z",["^ ","^4H",[["^31"]]]],"^38",null,"^:",56,"^39","^3:","^32",["^ ","^5:",["^ ","^F","^4H","^34",["^R",[["^31"]]],"^6","Extract the value from monad context."]],"^3;",["^E",[]],"^6","A type class to extract the\n  value from a monad context.","^36",["^R",["@interface"]]],"~$Foldable",["^ ","^5",["^ ","^2X",true,"^7","cats/protocols.cljc","^;",22,"^9",14,"^8",78,"^2Y",["^ ","^2Z",["^ ","^3Y",[["^3[","~$f","~$z","^40"]],"^4F",[["^3[","~$f","~$z","^40"]]]],"^:",78,"^32",["^ ","~:-foldl",["^ ","^F","^3Y","^34",["^R",[["^3[","~$f","~$z","^40"]]],"^6","Left-associative fold of a structure."],"~:-foldr",["^ ","^F","^4F","^34",["^R",[["^3[","~$f","~$z","^40"]]],"^6","Right-associative fold of a structure."]],"^6","Abstraction of data structures that can be folded to a summary value.","^36",["^R",["@interface"]]],"^2X",true,"^F","^3Z","^7","cats/protocols.cljc","^;",22,"^9",1,"^8",78,"^2Y",["^ ","^2Z",["^ ","^3Y",[["^3[","~$f","~$z","^40"]],"^4F",[["^3[","~$f","~$z","^40"]]]],"^38",null,"^:",78,"^39","^3:","^32",["^ ","^5<",["^ ","^F","^3Y","^34",["^R",[["^3[","~$f","~$z","^40"]]],"^6","Left-associative fold of a structure."],"^5=",["^ ","^F","^4F","^34",["^R",[["^3[","~$f","~$z","^40"]]],"^6","Right-associative fold of a structure."]],"^3;",["^E",[]],"^6","Abstraction of data structures that can be folded to a summary value.","^36",["^R",["@interface"]]],"^4Z",["^ ","^3C",null,"^5",["^ ","^7","cats/protocols.cljc","^8",50,"^9",4,"^:",50,"^;",12,"^3D","^52","^6","An associative addition operation.","^34",["^R",["^3F",["^R",[["~$s","^4[","^50"]]]]]],"^3D","^52","^F","~$cats.protocols/-mappend","^7","cats/protocols.cljc","^;",12,"^3H",["^R",[["~$s","^4[","^50"]]],"^3I",null,"^3J",["^R",[null,null]],"^9",1,"^3K",false,"^8",48,"^3L","^3:","^:",50,"^3M",3,"^3N",true,"^34",["^R",["^3F",["^R",[["~$s","^4[","^50"]]]]],"^6","An associative addition operation."],"^43",["^ ","^3C",null,"^5",["^ ","^7","cats/protocols.cljc","^8",67,"^9",4,"^:",67,"^;",10,"^3D","^47","^6","Map over both arguments at the same time.","^34",["^R",["^3F",["^R",[["^44","~$f","~$g","^45"]]]]]],"^3D","^47","^F","~$cats.protocols/-bimap","^7","cats/protocols.cljc","^;",10,"^3H",["^R",[["^44","~$f","~$g","^45"]]],"^3I",null,"^3J",["^R",[null,null]],"^9",1,"^3K",false,"^8",65,"^3L","^3:","^:",67,"^3M",4,"^3N",true,"^34",["^R",["^3F",["^R",[["^44","~$f","~$g","^45"]]]]],"^6","Map over both arguments at the same time."],"^4L",["^ ","^3C",null,"^5",["^ ","^7","cats/protocols.cljc","^8",103,"^9",4,"^:",103,"^;",10,"^3D","^4O","^6","An associative addition operation.","^34",["^R",["^3F",["^R",[["~$m","^31","^4M"]]]]]],"^3D","^4O","^F","~$cats.protocols/-mplus","^7","cats/protocols.cljc","^;",10,"^3H",["^R",[["~$m","^31","^4M"]]],"^3I",null,"^3J",["^R",[null,null]],"^9",1,"^3K",false,"^8",100,"^3L","^3:","^:",103,"^3M",3,"^3N",true,"^34",["^R",["^3F",["^R",[["~$m","^31","^4M"]]]]],"^6","An associative addition operation."],"^4>",["^ ","^3C",null,"^5",["^ ","^7","cats/protocols.cljc","^8",41,"^9",4,"^:",41,"^;",16,"^3D","^4@","^6","Get the context associated with the type.","^34",["^R",["^3F",["^R",[["~$_"]]]]]],"^3D","^4@","^F","~$cats.protocols/-get-context","^7","cats/protocols.cljc","^;",16,"^3H",["^R",[["~$_"]]],"^3I",null,"^3J",["^R",[null,null]],"^9",1,"^3K",false,"^8",35,"^3L","^3:","^:",41,"^3M",1,"^3N",true,"^34",["^R",["^3F",["^R",[["~$_"]]]]],"^6","Get the context associated with the type."]],"^P",["^ ","^L","^L"],"^T",["^ "],"^U",["^ "],"^V",["^M","^L"]],"^I","^G","~:ns-specs",["^ "],"~:ns-spec-vars",["^E",[]],"~:compiler-options",["^18",[["^5D","~:static-fns"],true,["^5D","~:shadow-tweaks"],null,["^5D","~:elide-asserts"],false,["^5D","~:optimize-constants"],null,["^5D","^["],null,["^5D","~:external-config"],null,["^5D","~:tooling-config"],null,["^5D","~:emit-constants"],null,["^5D","~:load-tests"],null,["^5D","~:form-size-threshold"],null,["^5D","~:infer-externs"],"~:auto",["^5D","^11"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^5D","~:fn-invoke-direct"],null,["^5D","~:source-map"],"/dev/null"]]]