["^ ","~:output",["^ ","~:js","goog.provide('cats.core');\r\ngoog.require('cljs.core');\r\ngoog.require('cats.protocols');\r\ngoog.require('clojure.set');\r\ngoog.require('cats.context');\r\ncats.core.mempty = (function cats$core$mempty(var_args){\r\nvar G__39738 = arguments.length;\r\nswitch (G__39738) {\r\ncase 0:\r\nreturn cats.core.mempty.cljs$core$IFn$_invoke$arity$0();\r\n\r\nbreak;\r\ncase 1:\r\nreturn cats.core.mempty.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(cats.core.mempty.cljs$core$IFn$_invoke$arity$0 = (function (){\r\nreturn cats.protocols._mempty(cats.context.infer.cljs$core$IFn$_invoke$arity$0());\r\n}));\r\n\r\n(cats.core.mempty.cljs$core$IFn$_invoke$arity$1 = (function (ctx){\r\nreturn cats.protocols._mempty(ctx);\r\n}));\r\n\r\n(cats.core.mempty.cljs$lang$maxFixedArity = 1);\r\n\r\ncats.core.mappend = (function cats$core$mappend(var_args){\r\nvar args__4795__auto__ = [];\r\nvar len__4789__auto___39988 = arguments.length;\r\nvar i__4790__auto___39989 = (0);\r\nwhile(true){\r\nif((i__4790__auto___39989 < len__4789__auto___39988)){\r\nargs__4795__auto__.push((arguments[i__4790__auto___39989]));\r\n\r\nvar G__39990 = (i__4790__auto___39989 + (1));\r\ni__4790__auto___39989 = G__39990;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\nvar argseq__4796__auto__ = ((((0) < args__4795__auto__.length))?(new cljs.core.IndexedSeq(args__4795__auto__.slice((0)),(0),null)):null);\r\nreturn cats.core.mappend.cljs$core$IFn$_invoke$arity$variadic(argseq__4796__auto__);\r\n});\r\n\r\n(cats.core.mappend.cljs$core$IFn$_invoke$arity$variadic = (function (svs){\r\nif(cljs.core.seq(svs)){\r\n} else {\r\nthrow (new Error(\"Assert failed: (seq svs)\"));\r\n}\r\n\r\nvar ctx = cats.context.infer.cljs$core$IFn$_invoke$arity$1(cljs.core.first(svs));\r\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(cats.protocols._mappend,ctx),svs);\r\n}));\r\n\r\n(cats.core.mappend.cljs$lang$maxFixedArity = (0));\r\n\r\n/** @this {Function} */\r\n(cats.core.mappend.cljs$lang$applyTo = (function (seq39741){\r\nvar self__4777__auto__ = this;\r\nreturn self__4777__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq39741));\r\n}));\r\n\r\n/**\r\n * Given any value `v`, return it wrapped in\r\n *   the default/effect-free context.\r\n * \r\n *   This is a multi-arity function that with arity `pure/1`\r\n *   uses the dynamic scope to resolve the current\r\n *   context. With `pure/2`, you can force a specific context\r\n *   value.\r\n * \r\n *   Example:\r\n * \r\n *    (with-context either/context\r\n *      (pure 1))\r\n *    ;; => #<Right [1]>\r\n * \r\n *    (pure either/context 1)\r\n *    ;; => #<Right [1]>\r\n *   \r\n */\r\ncats.core.pure = (function cats$core$pure(var_args){\r\nvar G__39754 = arguments.length;\r\nswitch (G__39754) {\r\ncase 1:\r\nreturn cats.core.pure.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\r\n\r\nbreak;\r\ncase 2:\r\nreturn cats.core.pure.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(cats.core.pure.cljs$core$IFn$_invoke$arity$1 = (function (v){\r\nreturn cats.core.pure.cljs$core$IFn$_invoke$arity$2(cats.context.infer.cljs$core$IFn$_invoke$arity$0(),v);\r\n}));\r\n\r\n(cats.core.pure.cljs$core$IFn$_invoke$arity$2 = (function (ctx,v){\r\nreturn cats.protocols._pure(ctx,v);\r\n}));\r\n\r\n(cats.core.pure.cljs$lang$maxFixedArity = 2);\r\n\r\n/**\r\n * This is a monad version of `pure` and works\r\n *   identically to it.\r\n */\r\ncats.core.return$ = (function cats$core$return(var_args){\r\nvar G__39759 = arguments.length;\r\nswitch (G__39759) {\r\ncase 1:\r\nreturn cats.core.return$.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\r\n\r\nbreak;\r\ncase 2:\r\nreturn cats.core.return$.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(cats.core.return$.cljs$core$IFn$_invoke$arity$1 = (function (v){\r\nreturn cats.core.return$.cljs$core$IFn$_invoke$arity$2(cats.context.infer.cljs$core$IFn$_invoke$arity$0(),v);\r\n}));\r\n\r\n(cats.core.return$.cljs$core$IFn$_invoke$arity$2 = (function (ctx,v){\r\nreturn cats.protocols._mreturn(ctx,v);\r\n}));\r\n\r\n(cats.core.return$.cljs$lang$maxFixedArity = 2);\r\n\r\n/**\r\n * Given a monadic value `mv` and a function `f`,\r\n *   apply `f` to the unwrapped value of `mv`.\r\n * \r\n *    (bind (either/right 1) (fn [v]\r\n *                             (return (inc v))))\r\n *    ;; => #<Right [2]>\r\n * \r\n *   For convenience, you may prefer to use the `mlet` macro,\r\n *   which provides a beautiful, `let`-like syntax for\r\n *   composing operations with the `bind` function.\r\n */\r\ncats.core.bind = (function cats$core$bind(mv,f){\r\nvar ctx = cats.context.infer.cljs$core$IFn$_invoke$arity$1(mv);\r\nreturn cats.protocols._mbind(ctx,mv,(function (v){\r\nif(cats.context.context_QMARK_(ctx)){\r\n} else {\r\ncats.context.throw_illegal_argument(\"The provided context does not implements Context.\");\r\n}\r\n\r\nvar _STAR_context_STAR__orig_val__39761 = cats.context._STAR_context_STAR_;\r\nvar _STAR_context_STAR__temp_val__39762 = ctx;\r\n(cats.context._STAR_context_STAR_ = _STAR_context_STAR__temp_val__39762);\r\n\r\ntry{return (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(v) : f.call(null,v));\r\n}finally {(cats.context._STAR_context_STAR_ = _STAR_context_STAR__orig_val__39761);\r\n}}));\r\n});\r\ncats.core.mzero = (function cats$core$mzero(var_args){\r\nvar G__39767 = arguments.length;\r\nswitch (G__39767) {\r\ncase 0:\r\nreturn cats.core.mzero.cljs$core$IFn$_invoke$arity$0();\r\n\r\nbreak;\r\ncase 1:\r\nreturn cats.core.mzero.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(cats.core.mzero.cljs$core$IFn$_invoke$arity$0 = (function (){\r\nreturn cats.protocols._mzero(cats.context.infer.cljs$core$IFn$_invoke$arity$0());\r\n}));\r\n\r\n(cats.core.mzero.cljs$core$IFn$_invoke$arity$1 = (function (ctx){\r\nreturn cats.protocols._mzero(ctx);\r\n}));\r\n\r\n(cats.core.mzero.cljs$lang$maxFixedArity = 1);\r\n\r\ncats.core.mplus = (function cats$core$mplus(var_args){\r\nvar args__4795__auto__ = [];\r\nvar len__4789__auto___40002 = arguments.length;\r\nvar i__4790__auto___40003 = (0);\r\nwhile(true){\r\nif((i__4790__auto___40003 < len__4789__auto___40002)){\r\nargs__4795__auto__.push((arguments[i__4790__auto___40003]));\r\n\r\nvar G__40004 = (i__4790__auto___40003 + (1));\r\ni__4790__auto___40003 = G__40004;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\nvar argseq__4796__auto__ = ((((0) < args__4795__auto__.length))?(new cljs.core.IndexedSeq(args__4795__auto__.slice((0)),(0),null)):null);\r\nreturn cats.core.mplus.cljs$core$IFn$_invoke$arity$variadic(argseq__4796__auto__);\r\n});\r\n\r\n(cats.core.mplus.cljs$core$IFn$_invoke$arity$variadic = (function (mvs){\r\nif(cljs.core.seq(mvs)){\r\n} else {\r\nthrow (new Error(\"Assert failed: (seq mvs)\"));\r\n}\r\n\r\nvar ctx = cats.context.infer.cljs$core$IFn$_invoke$arity$1(cljs.core.first(mvs));\r\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(cats.protocols._mplus,ctx),mvs);\r\n}));\r\n\r\n(cats.core.mplus.cljs$lang$maxFixedArity = (0));\r\n\r\n/** @this {Function} */\r\n(cats.core.mplus.cljs$lang$applyTo = (function (seq39769){\r\nvar self__4777__auto__ = this;\r\nreturn self__4777__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq39769));\r\n}));\r\n\r\ncats.core.guard = (function cats$core$guard(b){\r\nif(cljs.core.truth_(b)){\r\nreturn cats.core.return$.cljs$core$IFn$_invoke$arity$1(true);\r\n} else {\r\nreturn cats.core.mzero.cljs$core$IFn$_invoke$arity$0();\r\n}\r\n});\r\n/**\r\n * Remove one level of monadic structure.\r\n *   This is the same as `(bind mv identity)`.\r\n */\r\ncats.core.join = (function cats$core$join(mv){\r\nreturn cats.core.bind(mv,cljs.core.identity);\r\n});\r\n/**\r\n * Apply a function `f` to the value wrapped in functor `fv`,\r\n *   preserving the context type.\r\n */\r\ncats.core.fmap = (function cats$core$fmap(var_args){\r\nvar G__39774 = arguments.length;\r\nswitch (G__39774) {\r\ncase 1:\r\nreturn cats.core.fmap.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\r\n\r\nbreak;\r\ncase 2:\r\nreturn cats.core.fmap.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(cats.core.fmap.cljs$core$IFn$_invoke$arity$1 = (function (f){\r\nreturn (function (fv){\r\nreturn cats.core.fmap.cljs$core$IFn$_invoke$arity$2(f,fv);\r\n});\r\n}));\r\n\r\n(cats.core.fmap.cljs$core$IFn$_invoke$arity$2 = (function (f,fv){\r\nvar ctx = cats.context.infer.cljs$core$IFn$_invoke$arity$1(fv);\r\nif(cats.context.context_QMARK_(ctx)){\r\n} else {\r\ncats.context.throw_illegal_argument(\"The provided context does not implements Context.\");\r\n}\r\n\r\nvar _STAR_context_STAR__orig_val__39775 = cats.context._STAR_context_STAR_;\r\nvar _STAR_context_STAR__temp_val__39776 = ctx;\r\n(cats.context._STAR_context_STAR_ = _STAR_context_STAR__temp_val__39776);\r\n\r\ntry{return cats.protocols._fmap(ctx,f,fv);\r\n}finally {(cats.context._STAR_context_STAR_ = _STAR_context_STAR__orig_val__39775);\r\n}}));\r\n\r\n(cats.core.fmap.cljs$lang$maxFixedArity = 2);\r\n\r\n/**\r\n * Map over both arguments at the same time.\r\n * \r\n *   Given functions `f` and `g` and a value wrapped in a bifunctor `bv`,\r\n *   apply `f` to a first argument or `g` to a second argument.\r\n * \r\n *    (bimap dec inc (either/right 1)\r\n *    ;; => #<Right 2>\r\n * \r\n *    (bimap dec inc (either/left 1)\r\n *    ;; => #<Left 0>\r\n */\r\ncats.core.bimap = (function cats$core$bimap(var_args){\r\nvar G__39780 = arguments.length;\r\nswitch (G__39780) {\r\ncase 2:\r\nreturn cats.core.bimap.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ncase 3:\r\nreturn cats.core.bimap.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(cats.core.bimap.cljs$core$IFn$_invoke$arity$2 = (function (f,g){\r\nreturn (function (bv){\r\nreturn cats.core.bimap.cljs$core$IFn$_invoke$arity$3(f,g,bv);\r\n});\r\n}));\r\n\r\n(cats.core.bimap.cljs$core$IFn$_invoke$arity$3 = (function (f,g,bv){\r\nvar ctx = cats.context.infer.cljs$core$IFn$_invoke$arity$1(bv);\r\nif(cats.context.context_QMARK_(ctx)){\r\n} else {\r\ncats.context.throw_illegal_argument(\"The provided context does not implements Context.\");\r\n}\r\n\r\nvar _STAR_context_STAR__orig_val__39784 = cats.context._STAR_context_STAR_;\r\nvar _STAR_context_STAR__temp_val__39785 = ctx;\r\n(cats.context._STAR_context_STAR_ = _STAR_context_STAR__temp_val__39785);\r\n\r\ntry{return cats.protocols._bimap(ctx,f,g,bv);\r\n}finally {(cats.context._STAR_context_STAR_ = _STAR_context_STAR__orig_val__39784);\r\n}}));\r\n\r\n(cats.core.bimap.cljs$lang$maxFixedArity = 3);\r\n\r\n/**\r\n * Map covariantly over the first argument.\r\n * \r\n *   Given a function `f` and a value wrapped in a bifunctor `bv`,\r\n *   apply `f` to the first argument, if present, otherwise leave `bv` unchanged.\r\n * \r\n *    (left-map dec (either/right 1)\r\n *    ;; => #<Right 1>\r\n * \r\n *    (left-map dec (either/left 1)\r\n *    ;; => #<Left 0>\r\n */\r\ncats.core.left_map = (function cats$core$left_map(var_args){\r\nvar G__39787 = arguments.length;\r\nswitch (G__39787) {\r\ncase 1:\r\nreturn cats.core.left_map.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\r\n\r\nbreak;\r\ncase 2:\r\nreturn cats.core.left_map.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(cats.core.left_map.cljs$core$IFn$_invoke$arity$1 = (function (f){\r\nreturn (function (bv){\r\nreturn cats.core.left_map.cljs$core$IFn$_invoke$arity$2(f,bv);\r\n});\r\n}));\r\n\r\n(cats.core.left_map.cljs$core$IFn$_invoke$arity$2 = (function (f,bv){\r\nreturn cats.core.bimap.cljs$core$IFn$_invoke$arity$3(f,cljs.core.identity,bv);\r\n}));\r\n\r\n(cats.core.left_map.cljs$lang$maxFixedArity = 2);\r\n\r\n/**\r\n * Map covariantly over the second argument.\r\n * \r\n *   Given a function `g` and a value wrapped in a bifunctor `bv`,\r\n *   apply `g` to the second argument, if present, otherwise leave `bv` unchanged.\r\n * \r\n *    (right-map inc (either/right 1)\r\n *    ;; => #<Right 2>\r\n * \r\n *    (right-map inc (either/left 1)\r\n *    ;; => #<Left 1>\r\n */\r\ncats.core.right_map = (function cats$core$right_map(var_args){\r\nvar G__39789 = arguments.length;\r\nswitch (G__39789) {\r\ncase 1:\r\nreturn cats.core.right_map.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\r\n\r\nbreak;\r\ncase 2:\r\nreturn cats.core.right_map.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(cats.core.right_map.cljs$core$IFn$_invoke$arity$1 = (function (g){\r\nreturn (function (bv){\r\nreturn cats.core.right_map.cljs$core$IFn$_invoke$arity$2(g,bv);\r\n});\r\n}));\r\n\r\n(cats.core.right_map.cljs$core$IFn$_invoke$arity$2 = (function (g,bv){\r\nreturn cats.core.bimap.cljs$core$IFn$_invoke$arity$3(cljs.core.identity,g,bv);\r\n}));\r\n\r\n(cats.core.right_map.cljs$lang$maxFixedArity = 2);\r\n\r\n/**\r\n * Given a function wrapped in a monadic context `af`,\r\n *   and a value wrapped in a monadic context `av`,\r\n *   apply the unwrapped function to the unwrapped value\r\n *   and return the result, wrapped in the same context as `av`.\r\n * \r\n *   This function is variadic, so it can be used like\r\n *   a Haskell-style left-associative fapply.\r\n */\r\ncats.core.fapply = (function cats$core$fapply(var_args){\r\nvar args__4795__auto__ = [];\r\nvar len__4789__auto___40023 = arguments.length;\r\nvar i__4790__auto___40024 = (0);\r\nwhile(true){\r\nif((i__4790__auto___40024 < len__4789__auto___40023)){\r\nargs__4795__auto__.push((arguments[i__4790__auto___40024]));\r\n\r\nvar G__40028 = (i__4790__auto___40024 + (1));\r\ni__4790__auto___40024 = G__40028;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\nvar argseq__4796__auto__ = ((((1) < args__4795__auto__.length))?(new cljs.core.IndexedSeq(args__4795__auto__.slice((1)),(0),null)):null);\r\nreturn cats.core.fapply.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4796__auto__);\r\n});\r\n\r\n(cats.core.fapply.cljs$core$IFn$_invoke$arity$variadic = (function (af,avs){\r\nif(cljs.core.seq(avs)){\r\n} else {\r\nthrow (new Error(\"Assert failed: (seq avs)\"));\r\n}\r\n\r\nvar ctx = cats.context.infer.cljs$core$IFn$_invoke$arity$1(af);\r\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(cats.protocols._fapply,ctx),af,avs);\r\n}));\r\n\r\n(cats.core.fapply.cljs$lang$maxFixedArity = (1));\r\n\r\n/** @this {Function} */\r\n(cats.core.fapply.cljs$lang$applyTo = (function (seq39790){\r\nvar G__39791 = cljs.core.first(seq39790);\r\nvar seq39790__$1 = cljs.core.next(seq39790);\r\nvar self__4776__auto__ = this;\r\nreturn self__4776__auto__.cljs$core$IFn$_invoke$arity$variadic(G__39791,seq39790__$1);\r\n}));\r\n\r\n/**\r\n * Given an expression and a monadic value,\r\n *   if the expression is logical true, return the monadic value.\r\n *   Otherwise, return nil in a monadic context.\r\n */\r\ncats.core.when = (function cats$core$when(var_args){\r\nvar G__39807 = arguments.length;\r\nswitch (G__39807) {\r\ncase 2:\r\nreturn cats.core.when.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ncase 3:\r\nreturn cats.core.when.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(cats.core.when.cljs$core$IFn$_invoke$arity$2 = (function (b,mv){\r\nreturn cats.core.when.cljs$core$IFn$_invoke$arity$3(cats.context.infer.cljs$core$IFn$_invoke$arity$1(mv),b,mv);\r\n}));\r\n\r\n(cats.core.when.cljs$core$IFn$_invoke$arity$3 = (function (ctx,b,mv){\r\nif(cljs.core.truth_(b)){\r\nreturn mv;\r\n} else {\r\nreturn cats.core.pure.cljs$core$IFn$_invoke$arity$2(ctx,null);\r\n}\r\n}));\r\n\r\n(cats.core.when.cljs$lang$maxFixedArity = 3);\r\n\r\n/**\r\n * Given an expression and a monadic value,\r\n *   if the expression is not logical true, return the monadic value.\r\n *   Otherwise, return nil in a monadic context.\r\n */\r\ncats.core.unless = (function cats$core$unless(var_args){\r\nvar G__39817 = arguments.length;\r\nswitch (G__39817) {\r\ncase 2:\r\nreturn cats.core.unless.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ncase 3:\r\nreturn cats.core.unless.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(cats.core.unless.cljs$core$IFn$_invoke$arity$2 = (function (b,mv){\r\nreturn cats.core.when.cljs$core$IFn$_invoke$arity$2(cljs.core.not(b),mv);\r\n}));\r\n\r\n(cats.core.unless.cljs$core$IFn$_invoke$arity$3 = (function (ctx,b,mv){\r\nreturn cats.core.when.cljs$core$IFn$_invoke$arity$3(ctx,cljs.core.not(b),mv);\r\n}));\r\n\r\n(cats.core.unless.cljs$lang$maxFixedArity = 3);\r\n\r\ncats.core.deps = (function cats$core$deps(expr,syms){\r\nif((((expr instanceof cljs.core.Symbol)) && (cljs.core.contains_QMARK_(syms,expr)))){\r\nreturn (new cljs.core.List(null,expr,null,(1),null));\r\n} else {\r\nif(cljs.core.seq_QMARK_(expr)){\r\nreturn cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic((function (p1__39821_SHARP_){\r\nreturn (cats.core.deps.cljs$core$IFn$_invoke$arity$2 ? cats.core.deps.cljs$core$IFn$_invoke$arity$2(p1__39821_SHARP_,syms) : cats.core.deps.call(null,p1__39821_SHARP_,syms));\r\n}),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([expr], 0));\r\n} else {\r\nreturn cljs.core.List.EMPTY;\r\n\r\n}\r\n}\r\n});\r\ncats.core.rename_sym = (function cats$core$rename_sym(expr,renames){\r\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$3(renames,expr,expr);\r\n});\r\ncats.core.rename = (function cats$core$rename(expr,renames){\r\nif((expr instanceof cljs.core.Symbol)){\r\nreturn cats.core.rename_sym(expr,renames);\r\n} else {\r\nif(cljs.core.seq_QMARK_(expr)){\r\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__39827_SHARP_){\r\nreturn (cats.core.rename.cljs$core$IFn$_invoke$arity$2 ? cats.core.rename.cljs$core$IFn$_invoke$arity$2(p1__39827_SHARP_,renames) : cats.core.rename.call(null,p1__39827_SHARP_,renames));\r\n}),expr);\r\n} else {\r\nreturn expr;\r\n\r\n}\r\n}\r\n});\r\ncats.core.dedupe_symbols_STAR_ = (function cats$core$dedupe_symbols_STAR_(sym__GT_ap,body){\r\nvar renamer = (function cats$core$dedupe_symbols_STAR__$_renamer(p__39856,p__39857){\r\nvar map__39858 = p__39856;\r\nvar map__39858__$1 = (((((!((map__39858 == null))))?(((((map__39858.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__39858.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__39858):map__39858);\r\nvar summ = map__39858__$1;\r\nvar body__$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__39858__$1,new cljs.core.Keyword(null,\"body\",\"body\",-2049205669));\r\nvar syms = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__39858__$1,new cljs.core.Keyword(null,\"syms\",\"syms\",-1575891762));\r\nvar aps = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__39858__$1,new cljs.core.Keyword(null,\"aps\",\"aps\",265109554));\r\nvar seen = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__39858__$1,new cljs.core.Keyword(null,\"seen\",\"seen\",-518999789));\r\nvar renames = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__39858__$1,new cljs.core.Keyword(null,\"renames\",\"renames\",343278368));\r\nvar vec__39859 = p__39857;\r\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__39859,(0),null);\r\nvar ap = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__39859,(1),null);\r\nvar ap_SINGLEQUOTE_ = cats.core.rename(ap,renames);\r\nvar new_aps = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(aps,ap_SINGLEQUOTE_);\r\nif(cljs.core.truth_((seen.cljs$core$IFn$_invoke$arity$1 ? seen.cljs$core$IFn$_invoke$arity$1(s) : seen.call(null,s)))){\r\nvar s_SINGLEQUOTE_ = cljs.core.gensym.cljs$core$IFn$_invoke$arity$0();\r\nvar new_syms = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(syms,s_SINGLEQUOTE_);\r\nvar new_seen = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(seen,s_SINGLEQUOTE_);\r\nvar new_renames = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(renames,s,s_SINGLEQUOTE_);\r\nvar new_body = cats.core.rename(body__$1,new_renames);\r\nreturn new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(null,\"syms\",\"syms\",-1575891762),new_syms,new cljs.core.Keyword(null,\"aps\",\"aps\",265109554),new_aps,new cljs.core.Keyword(null,\"seen\",\"seen\",-518999789),new_seen,new cljs.core.Keyword(null,\"renames\",\"renames\",343278368),new_renames,new cljs.core.Keyword(null,\"body\",\"body\",-2049205669),new_body], null);\r\n} else {\r\nvar new_syms = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(syms,s);\r\nvar new_seen = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(seen,s);\r\nreturn new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(null,\"syms\",\"syms\",-1575891762),new_syms,new cljs.core.Keyword(null,\"aps\",\"aps\",265109554),new_aps,new cljs.core.Keyword(null,\"seen\",\"seen\",-518999789),new_seen,new cljs.core.Keyword(null,\"renames\",\"renames\",343278368),renames,new cljs.core.Keyword(null,\"body\",\"body\",-2049205669),body__$1], null);\r\n}\r\n});\r\nvar summ = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(renamer,new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(null,\"syms\",\"syms\",-1575891762),cljs.core.PersistentVector.EMPTY,new cljs.core.Keyword(null,\"aps\",\"aps\",265109554),cljs.core.PersistentVector.EMPTY,new cljs.core.Keyword(null,\"seen\",\"seen\",-518999789),cljs.core.PersistentHashSet.EMPTY,new cljs.core.Keyword(null,\"renames\",\"renames\",343278368),cljs.core.PersistentArrayMap.EMPTY,new cljs.core.Keyword(null,\"body\",\"body\",-2049205669),body], null),sym__GT_ap);\r\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.mapv.cljs$core$IFn$_invoke$arity$3(cljs.core.vector,new cljs.core.Keyword(null,\"syms\",\"syms\",-1575891762).cljs$core$IFn$_invoke$arity$1(summ),new cljs.core.Keyword(null,\"aps\",\"aps\",265109554).cljs$core$IFn$_invoke$arity$1(summ)),new cljs.core.Keyword(null,\"body\",\"body\",-2049205669).cljs$core$IFn$_invoke$arity$1(summ)], null);\r\n});\r\ncats.core.dedupe_symbols = (function cats$core$dedupe_symbols(bindings,body){\r\nvar syms = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.first,bindings);\r\nvar aps = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.second,bindings);\r\nvar sym__GT_ap = cljs.core.mapv.cljs$core$IFn$_invoke$arity$3(cljs.core.vector,syms,aps);\r\nreturn cats.core.dedupe_symbols_STAR_(sym__GT_ap,body);\r\n});\r\ncats.core.dependency_map = (function cats$core$dependency_map(sym__GT_ap){\r\nvar syms = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.first,sym__GT_ap);\r\nvar symset = cljs.core.set(syms);\r\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,(function (){var iter__4582__auto__ = (function cats$core$dependency_map_$_iter__39871(s__39872){\r\nreturn (new cljs.core.LazySeq(null,(function (){\r\nvar s__39872__$1 = s__39872;\r\nwhile(true){\r\nvar temp__5735__auto__ = cljs.core.seq(s__39872__$1);\r\nif(temp__5735__auto__){\r\nvar s__39872__$2 = temp__5735__auto__;\r\nif(cljs.core.chunked_seq_QMARK_(s__39872__$2)){\r\nvar c__4580__auto__ = cljs.core.chunk_first(s__39872__$2);\r\nvar size__4581__auto__ = cljs.core.count(c__4580__auto__);\r\nvar b__39874 = cljs.core.chunk_buffer(size__4581__auto__);\r\nif((function (){var i__39873 = (0);\r\nwhile(true){\r\nif((i__39873 < size__4581__auto__)){\r\nvar vec__39877 = cljs.core._nth.cljs$core$IFn$_invoke$arity$2(c__4580__auto__,i__39873);\r\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__39877,(0),null);\r\nvar ap = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__39877,(1),null);\r\nvar ds = cljs.core.set(cats.core.deps(ap,symset));\r\ncljs.core.chunk_append(b__39874,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [s,ds], null));\r\n\r\nvar G__40045 = (i__39873 + (1));\r\ni__39873 = G__40045;\r\ncontinue;\r\n} else {\r\nreturn true;\r\n}\r\nbreak;\r\n}\r\n})()){\r\nreturn cljs.core.chunk_cons(cljs.core.chunk(b__39874),cats$core$dependency_map_$_iter__39871(cljs.core.chunk_rest(s__39872__$2)));\r\n} else {\r\nreturn cljs.core.chunk_cons(cljs.core.chunk(b__39874),null);\r\n}\r\n} else {\r\nvar vec__39884 = cljs.core.first(s__39872__$2);\r\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__39884,(0),null);\r\nvar ap = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__39884,(1),null);\r\nvar ds = cljs.core.set(cats.core.deps(ap,symset));\r\nreturn cljs.core.cons(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [s,ds], null),cats$core$dependency_map_$_iter__39871(cljs.core.rest(s__39872__$2)));\r\n}\r\n} else {\r\nreturn null;\r\n}\r\nbreak;\r\n}\r\n}),null,null));\r\n});\r\nreturn iter__4582__auto__(sym__GT_ap);\r\n})());\r\n});\r\ncats.core.remove_deps = (function cats$core$remove_deps(deps,symset){\r\nvar removed = (function (){var iter__4582__auto__ = (function cats$core$remove_deps_$_iter__39887(s__39888){\r\nreturn (new cljs.core.LazySeq(null,(function (){\r\nvar s__39888__$1 = s__39888;\r\nwhile(true){\r\nvar temp__5735__auto__ = cljs.core.seq(s__39888__$1);\r\nif(temp__5735__auto__){\r\nvar s__39888__$2 = temp__5735__auto__;\r\nif(cljs.core.chunked_seq_QMARK_(s__39888__$2)){\r\nvar c__4580__auto__ = cljs.core.chunk_first(s__39888__$2);\r\nvar size__4581__auto__ = cljs.core.count(c__4580__auto__);\r\nvar b__39890 = cljs.core.chunk_buffer(size__4581__auto__);\r\nif((function (){var i__39889 = (0);\r\nwhile(true){\r\nif((i__39889 < size__4581__auto__)){\r\nvar vec__39891 = cljs.core._nth.cljs$core$IFn$_invoke$arity$2(c__4580__auto__,i__39889);\r\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__39891,(0),null);\r\nvar depset = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__39891,(1),null);\r\ncljs.core.chunk_append(b__39890,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [s,clojure.set.difference.cljs$core$IFn$_invoke$arity$2(depset,symset)], null));\r\n\r\nvar G__40049 = (i__39889 + (1));\r\ni__39889 = G__40049;\r\ncontinue;\r\n} else {\r\nreturn true;\r\n}\r\nbreak;\r\n}\r\n})()){\r\nreturn cljs.core.chunk_cons(cljs.core.chunk(b__39890),cats$core$remove_deps_$_iter__39887(cljs.core.chunk_rest(s__39888__$2)));\r\n} else {\r\nreturn cljs.core.chunk_cons(cljs.core.chunk(b__39890),null);\r\n}\r\n} else {\r\nvar vec__39898 = cljs.core.first(s__39888__$2);\r\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__39898,(0),null);\r\nvar depset = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__39898,(1),null);\r\nreturn cljs.core.cons(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [s,clojure.set.difference.cljs$core$IFn$_invoke$arity$2(depset,symset)], null),cats$core$remove_deps_$_iter__39887(cljs.core.rest(s__39888__$2)));\r\n}\r\n} else {\r\nreturn null;\r\n}\r\nbreak;\r\n}\r\n}),null,null));\r\n});\r\nreturn iter__4582__auto__(deps);\r\n})();\r\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.empty(deps),removed);\r\n});\r\ncats.core.topo_sort_STAR_ = (function cats$core$topo_sort_STAR_(deps,seen,batches,current){\r\nwhile(true){\r\nif(cljs.core.empty_QMARK_(deps)){\r\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(batches,current);\r\n} else {\r\nvar dep = cljs.core.first(deps);\r\nvar vec__39904 = dep;\r\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__39904,(0),null);\r\nvar dependencies = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__39904,(1),null);\r\nvar dependant_QMARK_ = cljs.core.some(dependencies,seen);\r\nif((dependant_QMARK_ == null)){\r\nvar G__40053 = cljs.core.subvec.cljs$core$IFn$_invoke$arity$2(deps,(1));\r\nvar G__40054 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(seen,s);\r\nvar G__40055 = batches;\r\nvar G__40056 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(current,s);\r\ndeps = G__40053;\r\nseen = G__40054;\r\nbatches = G__40055;\r\ncurrent = G__40056;\r\ncontinue;\r\n} else {\r\nvar G__40057 = cats.core.remove_deps(cljs.core.subvec.cljs$core$IFn$_invoke$arity$2(deps,(1)),cljs.core.set(current));\r\nvar G__40058 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(seen,s);\r\nvar G__40059 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(batches,current);\r\nvar G__40060 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [s], null);\r\ndeps = G__40057;\r\nseen = G__40058;\r\nbatches = G__40059;\r\ncurrent = G__40060;\r\ncontinue;\r\n}\r\n}\r\nbreak;\r\n}\r\n});\r\ncats.core.topo_sort = (function cats$core$topo_sort(deps){\r\nvar syms = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentHashSet.EMPTY,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.first,deps));\r\nreturn cats.core.topo_sort_STAR_(deps,cljs.core.PersistentHashSet.EMPTY,cljs.core.PersistentVector.EMPTY,cljs.core.PersistentVector.EMPTY);\r\n});\r\ncats.core.bindings__GT_batches = (function cats$core$bindings__GT_batches(bindings){\r\nvar syms = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.first,bindings);\r\nvar aps = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.second,bindings);\r\nvar sym__GT_ap = cljs.core.mapv.cljs$core$IFn$_invoke$arity$3(cljs.core.vector,syms,aps);\r\nvar sorted_deps = cats.core.topo_sort(cats.core.dependency_map(sym__GT_ap));\r\nreturn sorted_deps;\r\n});\r\ncats.core.alet_STAR_ = (function cats$core$alet_STAR_(batches,env,body){\r\nvar fb = cljs.core.first(batches);\r\nvar rb = cljs.core.rest(batches);\r\nvar fs = cljs.core.first(fb);\r\nvar fa = cljs.core.get.cljs$core$IFn$_invoke$arity$2(env,fs);\r\nvar code = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (acc,syms){\r\nvar fs__$1 = cljs.core.first(syms);\r\nvar fa__$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(env,fs__$1);\r\nvar rs = cljs.core.rest(syms);\r\nvar faps = cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__39910_SHARP_){\r\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(env,p1__39910_SHARP_);\r\n}),rs);\r\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(syms),(1))){\r\nreturn cljs.core.sequence.cljs$core$IFn$_invoke$arity$1(cljs.core.seq(cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic((new cljs.core.List(null,new cljs.core.Symbol(\"cats.core\",\"fmap\",\"cats.core/fmap\",1968944844,null),null,(1),null)),(new cljs.core.List(null,cljs.core.sequence.cljs$core$IFn$_invoke$arity$1(cljs.core.seq(cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic((new cljs.core.List(null,new cljs.core.Symbol(\"cljs.core\",\"fn\",\"cljs.core/fn\",-1065745098,null),null,(1),null)),(new cljs.core.List(null,cljs.core.vec(cljs.core.sequence.cljs$core$IFn$_invoke$arity$1(cljs.core.seq(cljs.core.concat.cljs$core$IFn$_invoke$arity$1((new cljs.core.List(null,fs__$1,null,(1),null)))))),null,(1),null)),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(new cljs.core.List(null,acc,null,(1),null))], 0)))),null,(1),null)),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(new cljs.core.List(null,fa__$1,null,(1),null))], 0))));\r\n} else {\r\nvar cf = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (f,sym){\r\nreturn cljs.core.sequence.cljs$core$IFn$_invoke$arity$1(cljs.core.seq(cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic((new cljs.core.List(null,new cljs.core.Symbol(\"cljs.core\",\"fn\",\"cljs.core/fn\",-1065745098,null),null,(1),null)),(new cljs.core.List(null,cljs.core.vec(cljs.core.sequence.cljs$core$IFn$_invoke$arity$1(cljs.core.seq(cljs.core.concat.cljs$core$IFn$_invoke$arity$1((new cljs.core.List(null,sym,null,(1),null)))))),null,(1),null)),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(new cljs.core.List(null,f,null,(1),null))], 0))));\r\n}),acc,cljs.core.reverse(syms));\r\nreturn cljs.core.sequence.cljs$core$IFn$_invoke$arity$1(cljs.core.seq(cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic((new cljs.core.List(null,new cljs.core.Symbol(\"cats.core\",\"fapply\",\"cats.core/fapply\",1894900497,null),null,(1),null)),(new cljs.core.List(null,cljs.core.sequence.cljs$core$IFn$_invoke$arity$1(cljs.core.seq(cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic((new cljs.core.List(null,new cljs.core.Symbol(\"cats.core\",\"fmap\",\"cats.core/fmap\",1968944844,null),null,(1),null)),(new cljs.core.List(null,cf,null,(1),null)),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(new cljs.core.List(null,fa__$1,null,(1),null))], 0)))),null,(1),null)),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([faps], 0))));\r\n}\r\n}),cljs.core.sequence.cljs$core$IFn$_invoke$arity$1(cljs.core.seq(cljs.core.concat.cljs$core$IFn$_invoke$arity$2((new cljs.core.List(null,new cljs.core.Symbol(null,\"do\",\"do\",1686842252,null),null,(1),null)),body))),cljs.core.reverse(batches));\r\nvar join_count = (cljs.core.count(batches) - (1));\r\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (acc,_){\r\nreturn cljs.core.sequence.cljs$core$IFn$_invoke$arity$1(cljs.core.seq(cljs.core.concat.cljs$core$IFn$_invoke$arity$2((new cljs.core.List(null,new cljs.core.Symbol(\"cats.core\",\"join\",\"cats.core/join\",1184708213,null),null,(1),null)),(new cljs.core.List(null,acc,null,(1),null)))));\r\n}),code,cljs.core.range.cljs$core$IFn$_invoke$arity$1(join_count));\r\n});\r\ncats.core.arglists = (function cats$core$arglists(var$){\r\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(cljs.core.meta(var$),new cljs.core.Keyword(null,\"arglists\",\"arglists\",1661989754));\r\n});\r\ncats.core.single_arity_QMARK_ = (function cats$core$single_arity_QMARK_(var$){\r\nvar args = cats.core.arglists(var$);\r\nreturn ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(args),(1))) && (cljs.core.not(cljs.core.some(new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Symbol(null,\"&\",\"&\",-2144855648,null),null], null), null),cljs.core.first(args)))));\r\n});\r\ncats.core.arity = (function cats$core$arity(var$){\r\nif(cats.core.single_arity_QMARK_(var$)){\r\n} else {\r\nthrow (new Error(\"Assert failed: (single-arity? var)\"));\r\n}\r\n\r\nreturn cljs.core.count(cljs.core.first(cats.core.arglists(var$)));\r\n});\r\n/**\r\n * Given a collection of monadic values, collect\r\n *   their values in a seq returned in the monadic context.\r\n * \r\n *    (require '[cats.context :as ctx]\r\n *             '[cats.monad.maybe :as maybe]\r\n *             '[cats.core :as m])\r\n * \r\n *    (m/sequence [(maybe/just 2) (maybe/just 3)])\r\n *    ;; => #<Just [[2, 3]]>\r\n * \r\n *    (m/sequence [(maybe/nothing) (maybe/just 3)])\r\n *    ;; => #<Nothing>\r\n * \r\n *    (ctx/with-context maybe/context\r\n *      (m/sequence []))\r\n *    ;; => #<Just [()]>\r\n *   \r\n */\r\ncats.core.sequence = (function cats$core$sequence(mvs){\r\nif(cljs.core.empty_QMARK_(mvs)){\r\nreturn cats.core.return$.cljs$core$IFn$_invoke$arity$1(cljs.core.List.EMPTY);\r\n} else {\r\nvar ctx = cats.context.infer.cljs$core$IFn$_invoke$arity$1(cljs.core.first(mvs));\r\nif(cats.context.context_QMARK_(ctx)){\r\n} else {\r\ncats.context.throw_illegal_argument(\"The provided context does not implements Context.\");\r\n}\r\n\r\nvar _STAR_context_STAR__orig_val__39936 = cats.context._STAR_context_STAR_;\r\nvar _STAR_context_STAR__temp_val__39937 = ctx;\r\n(cats.context._STAR_context_STAR_ = _STAR_context_STAR__temp_val__39937);\r\n\r\ntry{return cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (mvs__$1,mv){\r\nreturn cats.core.bind(mv,(function (v){\r\nreturn cats.core.bind(mvs__$1,(function (vs){\r\nreturn cats.core.return$.cljs$core$IFn$_invoke$arity$1(cljs.core.cons(v,vs));\r\n}));\r\n}));\r\n}),cats.core.return$.cljs$core$IFn$_invoke$arity$1(cljs.core.List.EMPTY),cljs.core.reverse(mvs));\r\n}finally {(cats.context._STAR_context_STAR_ = _STAR_context_STAR__orig_val__39936);\r\n}}\r\n});\r\n/**\r\n * Given a function `mf` that takes a value and puts it into a\r\n *   monadic context, and a collection, map `mf` over the collection,\r\n *   calling `sequence` on the results.\r\n * \r\n *    (require '[cats.context :as ctx]\r\n *             '[cats.monad.maybe :as maybe]\r\n *             '[cats.core :as m])\r\n * \r\n *    (m/mapseq maybe/just [2 3])\r\n *    ;=> <Just [[2 3]]>\r\n * \r\n *    (m/mapseq (fn [v]\r\n *                (if (odd? v)\r\n *                  (maybe/just v)\r\n *                  (maybe/nothing)))\r\n *              [1 2])\r\n *    ;; => #<Nothing>\r\n * \r\n *    (ctx/with-context maybe/context\r\n *      (mapseq #(maybe/just (* % 2)) []))\r\n *    ;; => #<Just [()]>\r\n *   \r\n */\r\ncats.core.mapseq = (function cats$core$mapseq(mf,coll){\r\nreturn cats.core.sequence(cljs.core.map.cljs$core$IFn$_invoke$arity$2(mf,coll));\r\n});\r\n/**\r\n * Same as `mapseq` but with the arguments flipped.\r\n * \r\n *   Let's see a little example:\r\n * \r\n *    (m/forseq [2 3] maybe/just)\r\n *    ;; => <Just [[2 3]]>\r\n * \r\n *   Yet an other example that fails:\r\n * \r\n *    (m/forseq [1 2]\r\n *              (fn [v]\r\n *                (if (odd? v)\r\n *                  (maybe/just v)\r\n *                  (maybe/nothing))))\r\n *    ;; => <Nothing>\r\n *   \r\n */\r\ncats.core.forseq = (function cats$core$forseq(vs,mf){\r\nreturn cats.core.mapseq(mf,vs);\r\n});\r\n/**\r\n * Apply a predicate to a value in a `MonadZero` instance,\r\n *   returning the identity element when the predicate does not hold.\r\n * \r\n *   Otherwise, return the instance unchanged.\r\n * \r\n *    (require '[cats.monad.maybe :as maybe])\r\n *    (require '[cats.core :as m])\r\n * \r\n *    (m/filter (partial < 2) (maybe/just 3))\r\n *    ;=> <Just [3]>\r\n * \r\n *    (m/filter (partial < 4) (maybe/just 3))\r\n *    ;=> <Nothing>\r\n *   \r\n */\r\ncats.core.filter = (function cats$core$filter(p,mv){\r\nreturn cats.core.bind(mv,(function (v){\r\nreturn cats.core.bind(cats.core.guard((p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(v) : p.call(null,v))),(function (G__39939){\r\nreturn cats.core.return$.cljs$core$IFn$_invoke$arity$1(v);\r\n}));\r\n}));\r\n});\r\n/**\r\n * A Haskell-style `fmap` alias.\r\n */\r\ncats.core._LT_$_GT_ = cats.core.fmap;\r\n/**\r\n * A Haskell-style `fapply` alias.\r\n */\r\ncats.core._LT__STAR__GT_ = cats.core.fapply;\r\n/**\r\n * Perform a Haskell-style left-associative bind.\r\n * \r\n *   Let's see it in action:\r\n * \r\n *    (>>= (just 1) (comp just inc) (comp just inc))\r\n *    ;; => #<Just [3]>\r\n *   \r\n */\r\ncats.core._GT__GT__EQ_ = (function cats$core$_GT__GT__EQ_(var_args){\r\nvar G__39948 = arguments.length;\r\nswitch (G__39948) {\r\ncase 2:\r\nreturn cats.core._GT__GT__EQ_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ndefault:\r\nvar args_arr__4810__auto__ = [];\r\nvar len__4789__auto___40078 = arguments.length;\r\nvar i__4790__auto___40079 = (0);\r\nwhile(true){\r\nif((i__4790__auto___40079 < len__4789__auto___40078)){\r\nargs_arr__4810__auto__.push((arguments[i__4790__auto___40079]));\r\n\r\nvar G__40080 = (i__4790__auto___40079 + (1));\r\ni__4790__auto___40079 = G__40080;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\nvar argseq__4811__auto__ = (new cljs.core.IndexedSeq(args_arr__4810__auto__.slice((2)),(0),null));\r\nreturn cats.core._GT__GT__EQ_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4811__auto__);\r\n\r\n}\r\n});\r\n\r\n(cats.core._GT__GT__EQ_.cljs$core$IFn$_invoke$arity$2 = (function (mv,f){\r\nreturn cats.core.bind(mv,f);\r\n}));\r\n\r\n(cats.core._GT__GT__EQ_.cljs$core$IFn$_invoke$arity$variadic = (function (mv,f,fs){\r\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cats.core.bind,mv,cljs.core.cons(f,fs));\r\n}));\r\n\r\n/** @this {Function} */\r\n(cats.core._GT__GT__EQ_.cljs$lang$applyTo = (function (seq39945){\r\nvar G__39946 = cljs.core.first(seq39945);\r\nvar seq39945__$1 = cljs.core.next(seq39945);\r\nvar G__39947 = cljs.core.first(seq39945__$1);\r\nvar seq39945__$2 = cljs.core.next(seq39945__$1);\r\nvar self__4776__auto__ = this;\r\nreturn self__4776__auto__.cljs$core$IFn$_invoke$arity$variadic(G__39946,G__39947,seq39945__$2);\r\n}));\r\n\r\n(cats.core._GT__GT__EQ_.cljs$lang$maxFixedArity = (2));\r\n\r\n/**\r\n * Perform a Haskell-style left-associative bind,\r\n *   ignoring the values produced by the monadic computations.\r\n */\r\ncats.core._GT__GT_ = (function cats$core$_GT__GT_(var_args){\r\nvar G__39953 = arguments.length;\r\nswitch (G__39953) {\r\ncase 2:\r\nreturn cats.core._GT__GT_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ndefault:\r\nvar args_arr__4810__auto__ = [];\r\nvar len__4789__auto___40084 = arguments.length;\r\nvar i__4790__auto___40085 = (0);\r\nwhile(true){\r\nif((i__4790__auto___40085 < len__4789__auto___40084)){\r\nargs_arr__4810__auto__.push((arguments[i__4790__auto___40085]));\r\n\r\nvar G__40087 = (i__4790__auto___40085 + (1));\r\ni__4790__auto___40085 = G__40087;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\nvar argseq__4811__auto__ = (new cljs.core.IndexedSeq(args_arr__4810__auto__.slice((2)),(0),null));\r\nreturn cats.core._GT__GT_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4811__auto__);\r\n\r\n}\r\n});\r\n\r\n(cats.core._GT__GT_.cljs$core$IFn$_invoke$arity$2 = (function (mv,mv_SINGLEQUOTE_){\r\nreturn cats.core.bind(mv,(function (_){\r\nreturn mv_SINGLEQUOTE_;\r\n}));\r\n}));\r\n\r\n(cats.core._GT__GT_.cljs$core$IFn$_invoke$arity$variadic = (function (mv,mv_SINGLEQUOTE_,mvs){\r\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cats.core._GT__GT_,mv,cljs.core.cons(mv_SINGLEQUOTE_,mvs));\r\n}));\r\n\r\n/** @this {Function} */\r\n(cats.core._GT__GT_.cljs$lang$applyTo = (function (seq39950){\r\nvar G__39951 = cljs.core.first(seq39950);\r\nvar seq39950__$1 = cljs.core.next(seq39950);\r\nvar G__39952 = cljs.core.first(seq39950__$1);\r\nvar seq39950__$2 = cljs.core.next(seq39950__$1);\r\nvar self__4776__auto__ = this;\r\nreturn self__4776__auto__.cljs$core$IFn$_invoke$arity$variadic(G__39951,G__39952,seq39950__$2);\r\n}));\r\n\r\n(cats.core._GT__GT_.cljs$lang$maxFixedArity = (2));\r\n\r\n/**\r\n * Same as the two argument version of `>>=` but with the\r\n *   arguments flipped.\r\n */\r\ncats.core._EQ__LT__LT_ = (function cats$core$_EQ__LT__LT_(f,mv){\r\nreturn cats.core._GT__GT__EQ_.cljs$core$IFn$_invoke$arity$2(mv,f);\r\n});\r\n/**\r\n * Left-to-right composition of monads.\r\n */\r\ncats.core._GT__EQ__GT_ = (function cats$core$_GT__EQ__GT_(mf,mg,x){\r\nif(cats.context.context_QMARK_(cats.context.infer.cljs$core$IFn$_invoke$arity$1(mf))){\r\n} else {\r\ncats.context.throw_illegal_argument(\"The provided context does not implements Context.\");\r\n}\r\n\r\nvar _STAR_context_STAR__orig_val__39954 = cats.context._STAR_context_STAR_;\r\nvar _STAR_context_STAR__temp_val__39955 = cats.context.infer.cljs$core$IFn$_invoke$arity$1(mf);\r\n(cats.context._STAR_context_STAR_ = _STAR_context_STAR__temp_val__39955);\r\n\r\ntry{return cats.core.bind((mf.cljs$core$IFn$_invoke$arity$1 ? mf.cljs$core$IFn$_invoke$arity$1(x) : mf.call(null,x)),(function (a){\r\nreturn cats.core.bind((mg.cljs$core$IFn$_invoke$arity$1 ? mg.cljs$core$IFn$_invoke$arity$1(a) : mg.call(null,a)),(function (b){\r\nreturn cats.core.return$.cljs$core$IFn$_invoke$arity$1(b);\r\n}));\r\n}));\r\n}finally {(cats.context._STAR_context_STAR_ = _STAR_context_STAR__orig_val__39954);\r\n}});\r\n/**\r\n * Right-to-left composition of monads.\r\n *   Same as `>=>` with its first two arguments flipped.\r\n */\r\ncats.core._LT__EQ__LT_ = (function cats$core$_LT__EQ__LT_(mg,mf,x){\r\nif(cats.context.context_QMARK_(cats.context.infer.cljs$core$IFn$_invoke$arity$1(mf))){\r\n} else {\r\ncats.context.throw_illegal_argument(\"The provided context does not implements Context.\");\r\n}\r\n\r\nvar _STAR_context_STAR__orig_val__39962 = cats.context._STAR_context_STAR_;\r\nvar _STAR_context_STAR__temp_val__39963 = cats.context.infer.cljs$core$IFn$_invoke$arity$1(mf);\r\n(cats.context._STAR_context_STAR_ = _STAR_context_STAR__temp_val__39963);\r\n\r\ntry{return cats.core.bind((mf.cljs$core$IFn$_invoke$arity$1 ? mf.cljs$core$IFn$_invoke$arity$1(x) : mf.call(null,x)),(function (a){\r\nreturn cats.core.bind((mg.cljs$core$IFn$_invoke$arity$1 ? mg.cljs$core$IFn$_invoke$arity$1(a) : mg.call(null,a)),(function (b){\r\nreturn cats.core.return$.cljs$core$IFn$_invoke$arity$1(b);\r\n}));\r\n}));\r\n}finally {(cats.context._STAR_context_STAR_ = _STAR_context_STAR__orig_val__39962);\r\n}});\r\n/**\r\n * Generic function to unwrap/extract\r\n *   the inner value of a container.\r\n */\r\ncats.core.extract = (function cats$core$extract(v){\r\nreturn cats.protocols._extract(v);\r\n});\r\ncats.core._LT__GT_ = cats.core.mappend;\r\n/**\r\n * Perform a right-associative fold on the data structure.\r\n */\r\ncats.core.foldr = (function cats$core$foldr(f,z,xs){\r\nvar ctx = cats.protocols._get_context(xs);\r\nif(cats.context.context_QMARK_(ctx)){\r\n} else {\r\ncats.context.throw_illegal_argument(\"The provided context does not implements Context.\");\r\n}\r\n\r\nvar _STAR_context_STAR__orig_val__39965 = cats.context._STAR_context_STAR_;\r\nvar _STAR_context_STAR__temp_val__39966 = ctx;\r\n(cats.context._STAR_context_STAR_ = _STAR_context_STAR__temp_val__39966);\r\n\r\ntry{return cats.protocols._foldr(ctx,f,z,xs);\r\n}finally {(cats.context._STAR_context_STAR_ = _STAR_context_STAR__orig_val__39965);\r\n}});\r\n/**\r\n * Perform a left-associative fold on the data structure.\r\n */\r\ncats.core.foldl = (function cats$core$foldl(f,z,xs){\r\nvar ctx = cats.protocols._get_context(xs);\r\nif(cats.context.context_QMARK_(ctx)){\r\n} else {\r\ncats.context.throw_illegal_argument(\"The provided context does not implements Context.\");\r\n}\r\n\r\nvar _STAR_context_STAR__orig_val__39968 = cats.context._STAR_context_STAR_;\r\nvar _STAR_context_STAR__temp_val__39969 = ctx;\r\n(cats.context._STAR_context_STAR_ = _STAR_context_STAR__temp_val__39969);\r\n\r\ntry{return cats.protocols._foldl(ctx,f,z,xs);\r\n}finally {(cats.context._STAR_context_STAR_ = _STAR_context_STAR__orig_val__39968);\r\n}});\r\n/**\r\n * Given an optional monadic context, a function that takes two non-monadic\r\n *   arguments and returns a value inside the given monadic context, an initial\r\n *   value, and a collection of values, perform a left-associative fold.\r\n * \r\n *    (require '[cats.context :as ctx]\r\n *             '[cats.core :as m]\r\n *             '[cats.monad.maybe :as maybe])\r\n * \r\n *    (defn m-div [x y]\r\n *      (if (zero? y)\r\n *        (maybe/nothing)\r\n *        (maybe/just (/ x y))))\r\n * \r\n *    (m/foldm m-div 1 [1 2 3])\r\n *    (m/foldm maybe/context m-div 1 [1 2 3])\r\n *    ;; => #<Just 1/6>\r\n * \r\n *    (m/foldm maybe/context m-div 1 [1 0 3])\r\n *    ;; => #<Nothing>\r\n * \r\n *    (foldm m-div 1 [])\r\n *    ;; => Exception\r\n * \r\n *    (m/foldm maybe/context m-div 1 [])\r\n *    (ctx/with-context maybe/context\r\n *      (foldm m-div 1 []))\r\n *    ;; => #<Just 1>\r\n *   \r\n */\r\ncats.core.foldm = (function cats$core$foldm(var_args){\r\nvar G__39974 = arguments.length;\r\nswitch (G__39974) {\r\ncase 3:\r\nreturn cats.core.foldm.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\r\n\r\nbreak;\r\ncase 4:\r\nreturn cats.core.foldm.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(cats.core.foldm.cljs$core$IFn$_invoke$arity$3 = (function (f,z,xs){\r\nif(cljs.core.empty_QMARK_(xs)){\r\nreturn cats.core.return$.cljs$core$IFn$_invoke$arity$1(z);\r\n} else {\r\nvar vec__39976 = xs;\r\nvar seq__39977 = cljs.core.seq(vec__39976);\r\nvar first__39978 = cljs.core.first(seq__39977);\r\nvar seq__39977__$1 = cljs.core.next(seq__39977);\r\nvar h = first__39978;\r\nvar t = seq__39977__$1;\r\nreturn cats.core.bind((f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(z,h) : f.call(null,z,h)),(function (z_SINGLEQUOTE_){\r\nif(cljs.core.empty_QMARK_(t)){\r\nreturn cats.core.return$.cljs$core$IFn$_invoke$arity$1(z_SINGLEQUOTE_);\r\n} else {\r\nreturn cats.core.foldm.cljs$core$IFn$_invoke$arity$3(f,z_SINGLEQUOTE_,t);\r\n}\r\n}));\r\n}\r\n}));\r\n\r\n(cats.core.foldm.cljs$core$IFn$_invoke$arity$4 = (function (ctx,f,z,xs){\r\nif(cljs.core.empty_QMARK_(xs)){\r\nreturn cats.core.return$.cljs$core$IFn$_invoke$arity$2(ctx,z);\r\n} else {\r\nreturn cats.core.foldm.cljs$core$IFn$_invoke$arity$3(f,z,xs);\r\n}\r\n}));\r\n\r\n(cats.core.foldm.cljs$lang$maxFixedArity = 4);\r\n\r\n/**\r\n * Map each element of a structure to an action, evaluate these\r\n *   actions from left to right, and collect the results.\r\n * \r\n *    (defn inc-if-even\r\n *      [n]\r\n *      (if (even? n)\r\n *        (maybe/just (inc n))\r\n *        (maybe/nothing)))\r\n * \r\n *    (ctx/with-context maybe/context\r\n *      (m/traverse inc-if-even [2 4]))\r\n *    ;; => #<Just [3 4]>\r\n *   \r\n */\r\ncats.core.traverse = (function cats$core$traverse(var_args){\r\nvar G__39984 = arguments.length;\r\nswitch (G__39984) {\r\ncase 2:\r\nreturn cats.core.traverse.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ncase 3:\r\nreturn cats.core.traverse.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(cats.core.traverse.cljs$core$IFn$_invoke$arity$2 = (function (f,tv){\r\nreturn cats.protocols._traverse(cats.protocols._get_context(tv),f,tv);\r\n}));\r\n\r\n(cats.core.traverse.cljs$core$IFn$_invoke$arity$3 = (function (ctx,f,tv){\r\nif(cats.context.context_QMARK_(ctx)){\r\n} else {\r\ncats.context.throw_illegal_argument(\"The provided context does not implements Context.\");\r\n}\r\n\r\nvar _STAR_context_STAR__orig_val__39985 = cats.context._STAR_context_STAR_;\r\nvar _STAR_context_STAR__temp_val__39986 = ctx;\r\n(cats.context._STAR_context_STAR_ = _STAR_context_STAR__temp_val__39986);\r\n\r\ntry{return cats.protocols._traverse(cats.protocols._get_context(tv),f,tv);\r\n}finally {(cats.context._STAR_context_STAR_ = _STAR_context_STAR__orig_val__39985);\r\n}}));\r\n\r\n(cats.core.traverse.cljs$lang$maxFixedArity = 3);\r\n\r\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:doc","Category Theory abstractions for Clojure","~:file","cats/core.cljc","~:line",26,"~:column",5,"~:end-line",26,"~:end-column",14],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$react-dom","~$module$node_modules$react_dom$index"],"~:use-macros",["^ ","~$mlet","~$cats.core","~$alet","^E"],"~:excludes",["~#set",["~$when","~$unless","~$filter","~$sequence"]],"~:macros",["^ ","~$as-ap->",["^ ","~:arglists",["~#list",[["~$expr","~$name","~$&","~$forms"]]],"^6","Thread like `as->`, within an applicative idiom.\n   See `cats.labs.sugar/ap->` for more in-depth discussion.","^8",540,"^9",1,"^7","cats/core.cljc","~:name","~$cats.core/as-ap->","~:ns","^E","~:macro",true],"^F",["^ ","^O",["^P",[["~$bindings","~$&","~$body"]]],"^6","Applicative composition macro similar to Clojure's\n     `let`. This macro facilitates composition of applicative\n     computations using `fmap` and `fapply` and evaluating\n     applicative values in parallel.\n\n     Let's see an example to understand how it works.\n     This code uses fmap for executing computations inside\n     an applicative context:\n\n       (fmap (fn [a] (inc a)) (just 1))\n       ;=> #<Just [2]>\n\n     Now see how this code can be made clearer\n     by using the alet macro:\n\n       (alet [a (just 1)]\n         (inc a))\n       ;=> #<Just [2]>\n\n     Let's look at a more complex example, imagine we have\n     dependencies between applicative values:\n\n       (join\n         (fapply\n          (fmap\n            (fn [a]\n              (fn [b]\n                (fmap (fn [c] (inc c))\n                      (just (+ a b)))))\n            (just 1))\n          (just 2)))\n       ;=> #<Just [4]>\n\n     This is greatly simplified using `alet`:\n\n       (alet [a (just 1)\n              b (just 2)\n              c (just (+ a b))]\n         (inc c))\n      ;=> #<Just [4]>\n\n     The intent of the code is much clearer and evaluates `a` and `b`\n     at the same time, then proceeds to evaluate `c` when all the values\n     it depends on are available. This evaluation strategy is specially\n     helpful for asynchronous applicatives.","^8",404,"^9",4,"^7","cats/core.cljc","^T","~$cats.core/alet","^V","^E","^W",true],"~$->=",["^ ","^O",["^P",[["^Q","~$&","^S"]]],"^6","Like `->`, but with monadic binding instead of pure application.\n   A mnemonic for the name is a pun on `>>=`, the monadic bind operator,\n   and clojure's regular arrow macros.\n\n   You can think of it as generalizing the `some->` thread macro\n   to all Monads instead of just Maybe.\n\n   Alternatively, if you think of the regular thread macro as\n   sugar for `let`:\n\n   (-> :a b (c (other args)) d)\n   =>\n   (let [res (b :a)\n         res (c res (other args))\n         res (d res)]\n     res)\n\n   Then `->=` is sugar for cats.core/mlet:\n\n   (->= m-a b (c (other args)) d)\n   (mlet [res m-a\n          res (c res (other args))\n          res (d res)]\n     (return res))\n\n   Note that extra args in this context are assumed pure, and will\n   be evaluated along with the function itself; this also matches\n   the behavior of `some->` wrt extra args.\n\n   Threading through pure functions is somewhat awkward, but can be done:\n\n   (->= m-a\n        monadic-fn\n        (-> pure-fn\n            other-pure-fn\n            m/return)\n        other-monadic-fn)","^8",552,"^9",1,"^7","cats/core.cljc","^T","~$cats.core/->=","^V","^E","^W",true],"~$ap->",["^ ","^O",["^P",[["~$x","~$&","^S"]]],"^6","Thread like `->`, within an applicative idiom.\n\n  Compare:\n\n  (macroexpand-1 `(-> a b c (d e f)))\n  => (d (c (b a) e f)\n\n  with:\n\n  (macroexpand-1 `(ap-> a b c (d e f))\n  => (ap d (ap c (ap b a) e f))\n  ","^8",504,"^9",1,"^7","cats/core.cljc","^T","~$cats.core/ap->","^V","^E","^W",true],"~$lift-a",["^ ","^O",["^P",[["~$f"],["~$n","~$f"]]],"^6","Lift a function with a given fixed arity to an applicative context.\n\n         (def app+ (lift-a 2 +))\n\n         (app+ (maybe/just 1) (maybe/just 2))\n         ;; => <Just 3>\n\n         (app+ (maybe/just 1) (maybe/nothing))\n         ;; => <Nothing>\n\n         (app+ [0 2 4] [1 2])\n         ;; => [1 2 3 4 5 6]\n     ","^8",728,"^9",4,"^7","cats/core.cljc","^T","~$cats.core/lift-a","^V","^E","^W",true],"~$lift-m",["^ ","^O",["^P",[["~$f"],["~$n","~$f"]]],"^6","Lift a function with a given fixed arity to a monadic context.\n\n         (def monad+ (lift-m 2 +))\n\n         (monad+ (maybe/just 1) (maybe/just 2))\n         ;; => <Just [3]>\n\n         (monad+ (maybe/just 1) (maybe/nothing))\n         ;; => <Nothing>\n\n         (monad+ [0 2 4] [1 2])\n         ;; => [1 2 3 4 5 6]\n     ","^8",693,"^9",4,"^7","cats/core.cljc","^T","~$cats.core/lift-m","^V","^E","^W",true],"~$as->=",["^ ","^O",["^P",[["^Q","^R","~$&","^S"]]],"^6","Like `as->`, but with monadic binding instead of pure application.\n   See `cats.labs.sugar/->=` for more in-depth discussion.","^8",607,"^9",1,"^7","cats/core.cljc","^T","~$cats.core/as->=","^V","^E","^W",true],"~$->>=",["^ ","^O",["^P",[["^Q","~$&","^S"]]],"^6","Like ->>, but with monadic binding instead of pure application.\n   See `cats.labs.sugar/->=` for more in-depth discussion.","^8",597,"^9",1,"^7","cats/core.cljc","^T","~$cats.core/->>=","^V","^E","^W",true],"~$ap->>",["^ ","^O",["^P",[["~$x","~$&","^S"]]],"^6","Thread like `->>`, within an applicative idiom.\n   See `cats.labs.sugar/ap->` for more in-depth discussion.","^8",527,"^9",1,"^7","cats/core.cljc","^T","~$cats.core/ap->>","^V","^E","^W",true],"~$curry",["^ ","^O",["^P",[["~$f"],["~$n","~$f"]]],"^6","Given either a fixed arity function or an arity and a function,\n     return another which is curried.\n\n     With inferred arity (function must have one fixed arity):\n\n         (defn add2 [x y] (+ x y))\n         (def cadd2 (curry add2))\n\n         ((cadd2 1) 3)\n         ;; => 4\n\n         (cadd2 1 3)\n         ;; => 4\n\n     With given arity:\n\n         (def c+ (curry 3 +))\n\n         ((c+ 1 2) 3)\n         ;; => 6\n\n         ((((c+) 1) 2) 3)\n         ;; => 6\n     ","^8",652,"^9",4,"^7","cats/core.cljc","^T","~$cats.core/curry","^V","^E","^W",true],"~$curry*",["^ ","^O",["^P",[["~$args","^Y"]]],"^8",635,"^9",4,"^7","cats/core.cljc","^T","~$cats.core/curry*","^V","^E","^W",true],"~$curry-lift-m",["^ ","^O",["^P",[["~$n","~$f"]]],"^6","Composition of `curry` and `lift-m`","^8",763,"^9",4,"^7","cats/core.cljc","^T","~$cats.core/curry-lift-m","^V","^E","^W",true],"~$ap",["^ ","^O",["^P",[["~$f","~$&","^1@"]]],"^6","Apply a pure function to applicative arguments, e.g.\n\n   (ap + (just 1) (just 2) (just 3))\n   ;; => #<Just [6]>\n   (ap str [\"hi\" \"lo\"] [\"bye\" \"woah\" \"hey\"])\n   ;; => [\"hibye\" \"hiwoah\" \"hihey\"\n          \"lobye\" \"lowoah\" \"lohey\"]\n\n   `ap` is essentially sugar for `(apply fapply (pure f) args)`,\n   but for the common case where you have a pure, uncurried,\n   possibly variadic function.\n\n   `ap` actually desugars in `alet` form:\n\n   (macroexpand-1 `(ap + (just 1) (just2)))\n   ;; => (alet [a1 (just 1) a2 (just 2)] (+ a1 a2))\n\n   That way, variadic functions Just Work, without needing to specify\n   an arity separately.\n\n   If you're familiar with Haskell, this is closest to writing\n   \"in Applicative style\": you can straightforwardly convert\n   pure function application to effectful application by with\n   some light syntax (<$> and <*> in case of Haskell, and `ap` here).\n\n   See the original Applicative paper for more inspiration:\n   http://staff.city.ac.uk/~ross/papers/Applicative.pdf","^8",471,"^9",1,"^7","cats/core.cljc","^T","~$cats.core/ap","^V","^E","^W",true],"^D",["^ ","^O",["^P",[["^X","~$&","^Y"]]],"^6","Monad composition macro that works like Clojure's\n     `let`. This facilitates much easier composition of\n     monadic computations.\n\n     Let's see an example to understand how it works.\n     This code uses bind to compose a few operations:\n\n         (bind (just 1)\n               (fn [a]\n                 (bind (just (inc a))\n                         (fn [b]\n                           (return (* b 2))))))\n         ;=> #<Just [4]>\n\n     Now see how this code can be made clearer\n     by using the mlet macro:\n\n         (mlet [a (just 1)\n                b (just (inc a))]\n           (return (* b 2)))\n         ;=> #<Just [4]>\n     ","^8",224,"^9",4,"^7","cats/core.cljc","^T","~$cats.core/mlet","^V","^E","^W",true]],"^T","^E","~:op","^V","~:imports",null,"~:requires",["^ ","~$cats.protocols","^1J","~$p","^1J","~$clojure.set","^1K","~$cats.context","^1L","~$ctx","^1L","~$cljs.core","^1N","~$goog","^1O"],"~:seen",["^H",["~:require","~:require-macros"]],"~:uses",null,"^1R",["^ ","^E","^E","^1L","^1L","^1M","^1L","^1N","^1N"],"~:form",["^P",["~$ns","^E","Category Theory abstractions for Clojure",["^P",["^1R",["^E","~:refer",["^P",["^D","^F"]]]]],["^P",["^1Q",["^1J","~:as","~$p"],["^1K"],["^1L","^1W","^1M","~:include-macros",true]]],["^P",["~:refer-clojure","~:exclude",["^K","^L","^J","^I"]]]]],"~:flags",["^ ","^1R",["^H",[]],"^1Q",["^H",[]]],"~:js-deps",["^ "],"~:deps",["^1O","^1N","^1J","^1K","^1L"]],"^V","^E","~:resource-id",["~:shadow.build.classpath/resource","cats/core.cljc"],"~:compiled-at",1579687556331,"~:resource-name","cats/core.cljc","~:warnings",[],"~:source",";; Copyright (c) 2014-2016 Andrey Antukh <niwi@niwi.nz>\n;; Copyright (c) 2014-2016 Alejandro Gómez <alejandro@dialelo.com>\n;; All rights reserved.\n;;\n;; Redistribution and use in source and binary forms, with or without\n;; modification, are permitted provided that the following conditions\n;; are met:\n;;\n;; 1. Redistributions of source code must retain the above copyright\n;;    notice, this list of conditions and the following disclaimer.\n;; 2. Redistributions in binary form must reproduce the above copyright\n;;    notice, this list of conditions and the following disclaimer in the\n;;    documentation and/or other materials provided with the distribution.\n;;\n;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n;; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n;; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n;; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n;; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n;; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n(ns cats.core\n  \"Category Theory abstractions for Clojure\"\n  #?(:cljs\n     (:require-macros [cats.core :refer (mlet alet)]))\n  #?(:cljs\n     (:require [cats.protocols :as p]\n               [clojure.set]\n               [cats.context :as ctx :include-macros true])\n     :clj\n     (:require [cats.protocols :as p]\n               [clojure.set]\n               [cats.context :as ctx]))\n  (:refer-clojure :exclude [filter sequence unless when]))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Context-aware functions\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn mempty\n  ([] (p/-mempty (ctx/infer)))\n  ([ctx] (p/-mempty ctx)))\n\n(defn mappend\n  [& svs]\n  {:pre [(seq svs)]}\n  (let [ctx (ctx/infer (first svs))]\n    (reduce (partial p/-mappend ctx) svs)))\n\n(defn pure\n  \"Given any value `v`, return it wrapped in\n  the default/effect-free context.\n\n  This is a multi-arity function that with arity `pure/1`\n  uses the dynamic scope to resolve the current\n  context. With `pure/2`, you can force a specific context\n  value.\n\n  Example:\n\n      (with-context either/context\n        (pure 1))\n      ;; => #<Right [1]>\n\n      (pure either/context 1)\n      ;; => #<Right [1]>\n  \"\n  ([v] (pure (ctx/infer) v))\n  ([ctx v] (p/-pure ctx v)))\n\n(defn return\n  \"This is a monad version of `pure` and works\n  identically to it.\"\n  ([v] (return (ctx/infer) v))\n  ([ctx v] (p/-mreturn ctx v)))\n\n(defn bind\n  \"Given a monadic value `mv` and a function `f`,\n  apply `f` to the unwrapped value of `mv`.\n\n      (bind (either/right 1) (fn [v]\n                               (return (inc v))))\n      ;; => #<Right [2]>\n\n  For convenience, you may prefer to use the `mlet` macro,\n  which provides a beautiful, `let`-like syntax for\n  composing operations with the `bind` function.\"\n  [mv f]\n  (let [ctx (ctx/infer mv)]\n    (p/-mbind ctx mv (fn [v]\n                       (ctx/with-context ctx\n                         (f v))))))\n\n(defn mzero\n  ([]\n   (p/-mzero (ctx/infer)))\n  ([ctx]\n   (p/-mzero ctx)))\n\n(defn mplus\n  [& mvs]\n  {:pre [(seq mvs)]}\n  (let [ctx (ctx/infer (first mvs))]\n    (reduce (partial p/-mplus ctx) mvs)))\n\n(defn guard\n  [b]\n  (if b\n    (return true)\n    (mzero)))\n\n(defn join\n  \"Remove one level of monadic structure.\n  This is the same as `(bind mv identity)`.\"\n  [mv]\n  (bind mv identity))\n\n(defn fmap\n  \"Apply a function `f` to the value wrapped in functor `fv`,\n  preserving the context type.\"\n  ([f]\n   (fn [fv]\n     (fmap f fv)))\n  ([f fv]\n   (let [ctx (ctx/infer fv)]\n     (ctx/with-context ctx\n       (p/-fmap ctx f fv)))))\n\n(defn bimap\n  \"Map over both arguments at the same time.\n\n  Given functions `f` and `g` and a value wrapped in a bifunctor `bv`,\n  apply `f` to a first argument or `g` to a second argument.\n\n      (bimap dec inc (either/right 1)\n      ;; => #<Right 2>\n\n      (bimap dec inc (either/left 1)\n      ;; => #<Left 0>\"\n  ([f g]\n   (fn [bv]\n     (bimap f g bv)))\n  ([f g bv]\n   (let [ctx (ctx/infer bv)]\n     (ctx/with-context ctx\n       (p/-bimap ctx f g bv)))))\n\n(defn left-map\n  \"Map covariantly over the first argument.\n\n  Given a function `f` and a value wrapped in a bifunctor `bv`,\n  apply `f` to the first argument, if present, otherwise leave `bv` unchanged.\n\n      (left-map dec (either/right 1)\n      ;; => #<Right 1>\n\n      (left-map dec (either/left 1)\n      ;; => #<Left 0>\"\n  ([f]\n   (fn [bv]\n     (left-map f bv)))\n  ([f bv]\n   (bimap f identity bv)))\n\n(defn right-map\n  \"Map covariantly over the second argument.\n\n  Given a function `g` and a value wrapped in a bifunctor `bv`,\n  apply `g` to the second argument, if present, otherwise leave `bv` unchanged.\n\n      (right-map inc (either/right 1)\n      ;; => #<Right 2>\n\n      (right-map inc (either/left 1)\n      ;; => #<Left 1>\"\n  ([g]\n   (fn [bv]\n     (right-map g bv)))\n  ([g bv]\n   (bimap identity g bv)))\n\n(defn fapply\n  \"Given a function wrapped in a monadic context `af`,\n  and a value wrapped in a monadic context `av`,\n  apply the unwrapped function to the unwrapped value\n  and return the result, wrapped in the same context as `av`.\n\n  This function is variadic, so it can be used like\n  a Haskell-style left-associative fapply.\"\n  [af & avs]\n  {:pre [(seq avs)]}\n  (let [ctx (ctx/infer af)]\n    (reduce (partial p/-fapply ctx) af avs)))\n\n(defn when\n  \"Given an expression and a monadic value,\n  if the expression is logical true, return the monadic value.\n  Otherwise, return nil in a monadic context.\"\n  ([b mv]\n   (when (ctx/infer mv) b mv))\n  ([ctx b mv]\n   (if b\n     mv\n     (pure ctx nil))))\n\n(defn unless\n  \"Given an expression and a monadic value,\n  if the expression is not logical true, return the monadic value.\n  Otherwise, return nil in a monadic context.\"\n  ([b mv]\n   (when (not b) mv))\n  ([ctx b mv]\n   (when ctx (not b) mv)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Monadic Let Macro\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n#?(:clj\n   (defmacro mlet\n     \"Monad composition macro that works like Clojure's\n     `let`. This facilitates much easier composition of\n     monadic computations.\n\n     Let's see an example to understand how it works.\n     This code uses bind to compose a few operations:\n\n         (bind (just 1)\n               (fn [a]\n                 (bind (just (inc a))\n                         (fn [b]\n                           (return (* b 2))))))\n         ;=> #<Just [4]>\n\n     Now see how this code can be made clearer\n     by using the mlet macro:\n\n         (mlet [a (just 1)\n                b (just (inc a))]\n           (return (* b 2)))\n         ;=> #<Just [4]>\n     \"\n     [bindings & body]\n     (when-not (and (vector? bindings)\n                    (not-empty bindings)\n                    (even? (count bindings)))\n       (throw (IllegalArgumentException. \"bindings has to be a vector with even number of elements.\")))\n     (->> (reverse (partition 2 bindings))\n          (reduce (fn [acc [l r]]\n                    (case l\n                      :let  `(let ~r ~acc)\n                      :when `(bind (guard ~r)\n                                   (fn [~(gensym)] ~acc))\n                      `(bind ~r (fn [~l] ~acc))))\n                  `(do ~@body)))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Applicative Let Macro\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- deps\n  [expr syms]\n  (cond\n    (and (symbol? expr)\n         (contains? syms expr))\n    (list expr)\n\n    (seq? expr)\n    (mapcat #(deps % syms) expr)\n\n    :else\n    '()))\n\n(defn- rename-sym\n  [expr renames]\n  (get renames expr expr))\n\n(defn- rename\n  [expr renames]\n  (cond\n    (symbol? expr)\n    (rename-sym expr renames)\n    (seq? expr)\n    (map #(rename % renames) expr)\n    :else\n    expr))\n\n(defn- dedupe-symbols*\n  [sym->ap body]\n  (letfn [(renamer [{:keys [body syms aps seen renames] :as summ} [s ap]]\n           (let [ap' (rename ap renames)\n                 new-aps (conj aps ap')]\n             (if (seen s)\n               (let [s' (gensym)\n                     new-syms (conj syms s')\n                     new-seen (conj seen s')\n                     new-renames (assoc renames s s')\n                     new-body (rename body new-renames)]\n                 {:syms new-syms\n                  :aps new-aps\n                  :seen new-seen\n                  :renames new-renames\n                  :body new-body})\n               (let [new-syms (conj syms s)\n                     new-seen (conj seen s)]\n                 {:syms new-syms\n                  :aps new-aps\n                  :seen new-seen\n                  :renames renames\n                  :body body}))))]\n    (let [summ\n          (reduce renamer\n                  {:syms []\n                   :aps []\n                   :seen #{}\n                   :renames {}\n                   :body body}\n                  sym->ap)]\n      [(mapv vector (:syms summ) (:aps summ)) (:body summ)])))\n\n(defn- dedupe-symbols\n  [bindings body]\n  (let [syms (map first bindings)\n        aps (map second bindings)\n        sym->ap (mapv vector syms aps)]\n    (dedupe-symbols* sym->ap body)))\n\n(defn- dependency-map\n  [sym->ap]\n  (let [syms (map first sym->ap)\n        symset (set syms)]\n    (into []\n          (for [[s ap] sym->ap\n                :let [ds (set (deps ap symset))]]\n            [s ds]))))\n\n(defn- remove-deps\n  [deps symset]\n  (let [removed (for [[s depset] deps]\n                  [s (clojure.set/difference depset symset)])]\n    (into (empty deps) removed)))\n\n(defn- topo-sort*\n  [deps seen batches current]\n  (if (empty? deps)\n    (conj batches current)\n    (let [dep (first deps)\n          [s dependencies] dep\n          dependant? (some dependencies seen)]\n      (if (nil? dependant?)\n        (recur (subvec deps 1)\n               (conj seen s)\n               batches\n               (conj current s))\n        (recur (remove-deps (subvec deps 1) (set current))\n               (conj seen s)\n               (conj batches current)\n               [s])))))\n\n(defn- topo-sort\n  [deps]\n  (let [syms (into #{} (map first deps))]\n    (topo-sort* deps #{} [] [])))\n\n(defn- bindings->batches\n  [bindings]\n  (let [syms (map first bindings)\n        aps (map second bindings)\n        sym->ap (mapv vector syms aps)\n        sorted-deps (topo-sort (dependency-map sym->ap))]\n    sorted-deps))\n\n(defn- alet*\n  [batches env body]\n  (let [fb (first batches)\n        rb (rest batches)\n        fs (first fb)\n        fa (get env fs)\n        code\n        (reduce (fn [acc syms]\n                  (let [fs (first syms)\n                        fa (get env fs)\n                        rs (rest syms)\n                        faps (map #(get env %) rs)]\n                    (if (= (count syms) 1)\n                      `(fmap (fn [~fs] ~acc) ~fa)\n                      (let [cf (reduce (fn [f sym] `(fn [~sym] ~f))\n                                       acc\n                                       (reverse syms))]\n                        `(fapply (fmap ~cf ~fa) ~@faps)))))\n                `(do ~@body)\n                (reverse batches))\n        join-count (dec (count batches))]\n    (reduce (fn [acc _]\n            `(join ~acc))\n        code\n        (range join-count))))\n\n#?(:clj\n   (defmacro alet\n     \"Applicative composition macro similar to Clojure's\n     `let`. This macro facilitates composition of applicative\n     computations using `fmap` and `fapply` and evaluating\n     applicative values in parallel.\n\n     Let's see an example to understand how it works.\n     This code uses fmap for executing computations inside\n     an applicative context:\n\n       (fmap (fn [a] (inc a)) (just 1))\n       ;=> #<Just [2]>\n\n     Now see how this code can be made clearer\n     by using the alet macro:\n\n       (alet [a (just 1)]\n         (inc a))\n       ;=> #<Just [2]>\n\n     Let's look at a more complex example, imagine we have\n     dependencies between applicative values:\n\n       (join\n         (fapply\n          (fmap\n            (fn [a]\n              (fn [b]\n                (fmap (fn [c] (inc c))\n                      (just (+ a b)))))\n            (just 1))\n          (just 2)))\n       ;=> #<Just [4]>\n\n     This is greatly simplified using `alet`:\n\n       (alet [a (just 1)\n              b (just 2)\n              c (just (+ a b))]\n         (inc c))\n      ;=> #<Just [4]>\n\n     The intent of the code is much clearer and evaluates `a` and `b`\n     at the same time, then proceeds to evaluate `c` when all the values\n     it depends on are available. This evaluation strategy is specially\n     helpful for asynchronous applicatives.\"\n     [bindings & body]\n     (when-not (and (vector? bindings)\n                    (not-empty bindings)\n                    (even? (count bindings)))\n       (throw (IllegalArgumentException. \"bindings has to be a vector with even number of elements.\")))\n     (let [bindings (partition 2 bindings)\n           [bindings body] (dedupe-symbols bindings body)\n           batches (bindings->batches bindings)\n           env (into {} bindings)]\n       (if (and (= (count batches) 1)\n                (= (count (map first bindings)) 1))\n         `(fmap (fn [~@(map first bindings)]\n                  ~@body)\n                ~@(map second bindings))\n         (alet* batches env body)))))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; applicative \"idiomatic apply\"\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defmacro ap\n  \"Apply a pure function to applicative arguments, e.g.\n\n   (ap + (just 1) (just 2) (just 3))\n   ;; => #<Just [6]>\n   (ap str [\\\"hi\\\" \\\"lo\\\"] [\\\"bye\\\" \\\"woah\\\" \\\"hey\\\"])\n   ;; => [\\\"hibye\\\" \\\"hiwoah\\\" \\\"hihey\\\"\n          \\\"lobye\\\" \\\"lowoah\\\" \\\"lohey\\\"]\n\n   `ap` is essentially sugar for `(apply fapply (pure f) args)`,\n   but for the common case where you have a pure, uncurried,\n   possibly variadic function.\n\n   `ap` actually desugars in `alet` form:\n\n   (macroexpand-1 `(ap + (just 1) (just2)))\n   ;; => (alet [a1 (just 1) a2 (just 2)] (+ a1 a2))\n\n   That way, variadic functions Just Work, without needing to specify\n   an arity separately.\n\n   If you're familiar with Haskell, this is closest to writing\n   \\\"in Applicative style\\\": you can straightforwardly convert\n   pure function application to effectful application by with\n   some light syntax (<$> and <*> in case of Haskell, and `ap` here).\n\n   See the original Applicative paper for more inspiration:\n   http://staff.city.ac.uk/~ross/papers/Applicative.pdf\"\n  [f & args]\n  (let [syms (repeatedly (count args) (partial gensym \"arg\"))]\n    `(alet [~@(interleave syms args)]\n        (~f ~@syms))))\n\n(defmacro ap->\n  \"Thread like `->`, within an applicative idiom.\n\n  Compare:\n\n  (macroexpand-1 `(-> a b c (d e f)))\n  => (d (c (b a) e f)\n\n  with:\n\n  (macroexpand-1 `(ap-> a b c (d e f))\n  => (ap d (ap c (ap b a) e f))\n  \"\n  [x & forms]\n  (loop [x x, forms forms]\n    (if forms\n      (let [form (first forms)\n            threaded (if (seq? form)\n                       (with-meta `(ap ~(first form) ~x ~@(next form)) (meta form))\n                       `(ap ~form ~x))]\n        (recur threaded (next forms)))\n      x)))\n\n(defmacro ap->>\n  \"Thread like `->>`, within an applicative idiom.\n   See `cats.labs.sugar/ap->` for more in-depth discussion.\"\n  [x & forms]\n  (loop [x x, forms forms]\n    (if forms\n      (let [form (first forms)\n            threaded (if (seq? form)\n                       (with-meta `(ap ~(first form) ~@(next form)  ~x) (meta form))\n                       `(ap ~form ~x))]\n        (recur threaded (next forms)))\n      x)))\n\n(defmacro as-ap->\n  \"Thread like `as->`, within an applicative idiom.\n   See `cats.labs.sugar/ap->` for more in-depth discussion.\"\n  [expr name & forms]\n  `(let [~name ~expr\n         ~@(interleave (repeat name) (for [form forms] `(ap ~@form)))]\n     ~name))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Monadic arrow macros.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defmacro ->=\n  \"Like `->`, but with monadic binding instead of pure application.\n   A mnemonic for the name is a pun on `>>=`, the monadic bind operator,\n   and clojure's regular arrow macros.\n\n   You can think of it as generalizing the `some->` thread macro\n   to all Monads instead of just Maybe.\n\n   Alternatively, if you think of the regular thread macro as\n   sugar for `let`:\n\n   (-> :a b (c (other args)) d)\n   =>\n   (let [res (b :a)\n         res (c res (other args))\n         res (d res)]\n     res)\n\n   Then `->=` is sugar for cats.core/mlet:\n\n   (->= m-a b (c (other args)) d)\n   (mlet [res m-a\n          res (c res (other args))\n          res (d res)]\n     (return res))\n\n   Note that extra args in this context are assumed pure, and will\n   be evaluated along with the function itself; this also matches\n   the behavior of `some->` wrt extra args.\n\n   Threading through pure functions is somewhat awkward, but can be done:\n\n   (->= m-a\n        monadic-fn\n        (-> pure-fn\n            other-pure-fn\n            m/return)\n        other-monadic-fn)\"\n  [expr & forms]\n  (let [g (gensym)\n        pstep (fn [step] `(-> ~g ~step))]\n    `(mlet [~g ~expr\n              ~@(interleave (repeat g) (map pstep forms))]\n           (return ~g))))\n\n(defmacro ->>=\n  \"Like ->>, but with monadic binding instead of pure application.\n   See `cats.labs.sugar/->=` for more in-depth discussion.\"\n  [expr & forms]\n  (let [g (gensym)\n        pstep (fn [step] `(->> ~g ~step))]\n    `(mlet [~g ~expr\n              ~@(interleave (repeat g) (map pstep forms))]\n           (return ~g))))\n\n(defmacro as->=\n  \"Like `as->`, but with monadic binding instead of pure application.\n   See `cats.labs.sugar/->=` for more in-depth discussion.\"\n  [expr name & forms]\n  `(mlet [~name ~expr\n            ~@(interleave (repeat name) forms)]\n     (return ~name)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Curry Facilities\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- arglists\n  [var]\n  (get (meta var) :arglists))\n\n(defn- single-arity?\n  [var]\n  (let [args (arglists var)]\n    (and (= (count args) 1)\n         (not (some #{'&} (first args))))))\n\n(defn- arity\n  [var]\n  {:pre [(single-arity? var)]}\n  (count (first (arglists var))))\n\n#?(:clj\n   (defmacro curry*\n     [args body]\n     (let [argcount (count args)]\n       (cond\n         (= argcount 0) `(fn f# [] ~body)\n         (= argcount 1) `(fn f#\n                           ([] f#)\n                           ([~@args] ~body))\n         :else\n         (let [arities (for [n (range 1 (count args))]\n                         `([~@(take n args)] (curry* ~(drop n args) ~body)))]\n           `(fn f#\n              ([] f#)\n              ~@arities\n              ([~@args] ~body)))))))\n\n#?(:clj\n   (defmacro curry\n     \"Given either a fixed arity function or an arity and a function,\n     return another which is curried.\n\n     With inferred arity (function must have one fixed arity):\n\n         (defn add2 [x y] (+ x y))\n         (def cadd2 (curry add2))\n\n         ((cadd2 1) 3)\n         ;; => 4\n\n         (cadd2 1 3)\n         ;; => 4\n\n     With given arity:\n\n         (def c+ (curry 3 +))\n\n         ((c+ 1 2) 3)\n         ;; => 6\n\n         ((((c+) 1) 2) 3)\n         ;; => 6\n     \"\n     ([f]\n      (if (not (symbol? f))\n        (throw (IllegalArgumentException. \"You must provide an arity for currying anonymous functions\"))\n        (let [fvar (resolve f)]\n          (if-let [args (arglists fvar)]\n            (if (single-arity? fvar)\n              `(curry ~(arity fvar) ~f)\n              (throw (IllegalArgumentException. \"The given function is either variadic or has multiple arities, provide an arity for currying.\")))\n            (throw (IllegalArgumentException. \"The given function doesn't have arity metadata, provide an arity for currying.\"))))))\n     ([n f]\n      {:pre [(< n 21)]}\n      (let [args (repeatedly n gensym)\n            body `(~f ~@args)]\n        `(curry* ~args ~body)))))\n\n#?(:clj\n   (defmacro lift-m\n     \"Lift a function with a given fixed arity to a monadic context.\n\n         (def monad+ (lift-m 2 +))\n\n         (monad+ (maybe/just 1) (maybe/just 2))\n         ;; => <Just [3]>\n\n         (monad+ (maybe/just 1) (maybe/nothing))\n         ;; => <Nothing>\n\n         (monad+ [0 2 4] [1 2])\n         ;; => [1 2 3 4 5 6]\n     \"\n     ([f]\n      (if (not (symbol? f))\n        (throw (IllegalArgumentException.\n                \"You must provide an arity for lifting anonymous functions\"))\n        (let [fvar (resolve f)]\n          (if-let [args (arglists fvar)]\n            (if (single-arity? fvar)\n              `(lift-m ~(arity fvar) ~f)\n              (throw (IllegalArgumentException.\n                      \"The given function is either variadic or has multiple arities, provide an arity for lifting.\")))\n            (throw (IllegalArgumentException.\n                    \"The given function doesn't have arity metadata, provide an arity for lifting.\"))))))\n     ([n f]\n      (let [val-syms (repeatedly n gensym)\n            mval-syms (repeatedly n gensym)\n            mlet-bindings (interleave val-syms mval-syms)]\n        `(fn [~@mval-syms]\n           (mlet [~@mlet-bindings]\n             (return (~f ~@val-syms))))))))\n\n#?(:clj\n   (defmacro lift-a\n     \"Lift a function with a given fixed arity to an applicative context.\n\n         (def app+ (lift-a 2 +))\n\n         (app+ (maybe/just 1) (maybe/just 2))\n         ;; => <Just 3>\n\n         (app+ (maybe/just 1) (maybe/nothing))\n         ;; => <Nothing>\n\n         (app+ [0 2 4] [1 2])\n         ;; => [1 2 3 4 5 6]\n     \"\n     ([f]\n      (if (not (symbol? f))\n        (throw (IllegalArgumentException.\n                \"You must provide an arity for lifting anonymous functions\"))\n        (let [fvar (resolve f)]\n          (if-let [args (arglists fvar)]\n            (if (single-arity? fvar)\n              `(lift-a ~(arity fvar) ~f)\n              (throw (IllegalArgumentException.\n                      \"The given function is either variadic or has multiple arities, provide an arity for lifting.\")))\n            (throw (IllegalArgumentException.\n                    \"The given function doesn't have arity metadata, provide an arity for lifting.\"))))))\n     ([n f]\n      (let [val-syms (repeatedly n gensym)\n            mval-syms (repeatedly n gensym)\n            bindings (interleave val-syms mval-syms)]\n        `(fn [~@mval-syms]\n           (alet [~@bindings]\n             (~f ~@val-syms)))))))\n\n#?(:clj\n   (defmacro curry-lift-m\n     \"Composition of `curry` and `lift-m`\"\n     [n f]\n     `(curry ~n (lift-m ~n ~f))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Sequences.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn sequence\n  \"Given a collection of monadic values, collect\n  their values in a seq returned in the monadic context.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/sequence [(maybe/just 2) (maybe/just 3)])\n      ;; => #<Just [[2, 3]]>\n\n      (m/sequence [(maybe/nothing) (maybe/just 3)])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (m/sequence []))\n      ;; => #<Just [()]>\n  \"\n  [mvs]\n  (if (empty? mvs)\n    (return ())\n    (let [ctx (ctx/infer (first mvs))]\n      (ctx/with-context ctx\n        (reduce (fn [mvs mv]\n                  (mlet [v mv\n                         vs mvs]\n                    (return (cons v vs))))\n                (return ())\n                (reverse mvs))))))\n\n(defn mapseq\n  \"Given a function `mf` that takes a value and puts it into a\n  monadic context, and a collection, map `mf` over the collection,\n  calling `sequence` on the results.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/mapseq maybe/just [2 3])\n      ;=> <Just [[2 3]]>\n\n      (m/mapseq (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing)))\n                [1 2])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (mapseq #(maybe/just (* % 2)) []))\n      ;; => #<Just [()]>\n  \"\n  [mf coll]\n  (sequence (map mf coll)))\n\n(defn forseq\n  \"Same as `mapseq` but with the arguments flipped.\n\n  Let's see a little example:\n\n      (m/forseq [2 3] maybe/just)\n      ;; => <Just [[2 3]]>\n\n  Yet an other example that fails:\n\n      (m/forseq [1 2]\n                (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing))))\n      ;; => <Nothing>\n  \"\n  [vs mf]\n  (mapseq mf vs))\n\n(defn filter\n  \"Apply a predicate to a value in a `MonadZero` instance,\n  returning the identity element when the predicate does not hold.\n\n  Otherwise, return the instance unchanged.\n\n      (require '[cats.monad.maybe :as maybe])\n      (require '[cats.core :as m])\n\n      (m/filter (partial < 2) (maybe/just 3))\n      ;=> <Just [3]>\n\n      (m/filter (partial < 4) (maybe/just 3))\n      ;=> <Nothing>\n  \"\n  [p mv]\n  (mlet [v mv\n         :when (p v)]\n    (return v)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Haskell-style aliases and util functions.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def <$>\n  \"A Haskell-style `fmap` alias.\"\n  fmap)\n\n(def <*>\n  \"A Haskell-style `fapply` alias.\"\n  fapply)\n\n(defn >>=\n  \"Perform a Haskell-style left-associative bind.\n\n  Let's see it in action:\n\n      (>>= (just 1) (comp just inc) (comp just inc))\n      ;; => #<Just [3]>\n  \"\n  ([mv f]\n   (bind mv f))\n  ([mv f & fs]\n   (reduce bind mv (cons f fs))))\n\n(defn >>\n  \"Perform a Haskell-style left-associative bind,\n  ignoring the values produced by the monadic computations.\"\n  ([mv mv']\n   (bind mv (fn [_] mv')))\n  ([mv mv' & mvs]\n   (reduce >> mv (cons mv' mvs))))\n\n(defn =<<\n  \"Same as the two argument version of `>>=` but with the\n  arguments flipped.\"\n  [f mv]\n  (>>= mv f))\n\n(defn >=>\n  \"Left-to-right composition of monads.\"\n  [mf mg x]\n  (ctx/with-context (ctx/infer mf)\n    (mlet [a (mf x)\n           b (mg a)]\n      (return b))))\n\n(defn <=<\n  \"Right-to-left composition of monads.\n  Same as `>=>` with its first two arguments flipped.\"\n  [mg mf x]\n  (ctx/with-context (ctx/infer mf)\n    (mlet [a (mf x)\n           b (mg a)]\n      (return b))))\n\n(defn extract\n  \"Generic function to unwrap/extract\n  the inner value of a container.\"\n  [v]\n  (p/-extract v))\n\n(def <> mappend)\n\n(defn foldr\n  \"Perform a right-associative fold on the data structure.\"\n  [f z xs]\n  (let [ctx (p/-get-context xs)]\n    (ctx/with-context ctx\n      (p/-foldr ctx f z xs))))\n\n(defn foldl\n  \"Perform a left-associative fold on the data structure.\"\n  [f z xs]\n  (let [ctx (p/-get-context xs)]\n    (ctx/with-context ctx\n      (p/-foldl ctx f z xs))))\n\n(defn foldm\n  \"Given an optional monadic context, a function that takes two non-monadic\n  arguments and returns a value inside the given monadic context, an initial\n  value, and a collection of values, perform a left-associative fold.\n\n      (require '[cats.context :as ctx]\n               '[cats.core :as m]\n               '[cats.monad.maybe :as maybe])\n\n      (defn m-div [x y]\n        (if (zero? y)\n          (maybe/nothing)\n          (maybe/just (/ x y))))\n\n      (m/foldm m-div 1 [1 2 3])\n      (m/foldm maybe/context m-div 1 [1 2 3])\n      ;; => #<Just 1/6>\n\n      (m/foldm maybe/context m-div 1 [1 0 3])\n      ;; => #<Nothing>\n\n      (foldm m-div 1 [])\n      ;; => Exception\n\n      (m/foldm maybe/context m-div 1 [])\n      (ctx/with-context maybe/context\n        (foldm m-div 1 []))\n      ;; => #<Just 1>\n  \"\n  ([f z xs]\n   (if (empty? xs)\n     (return z)\n     (let [[h & t] xs]\n       (mlet [z' (f z h)]\n         (if (empty? t)\n           (return z')\n           (foldm f z' t))))))\n  ([ctx f z xs]\n   (if (empty? xs)\n     (return ctx z)\n     (foldm f z xs))))\n\n(defn traverse\n  \"Map each element of a structure to an action, evaluate these\n  actions from left to right, and collect the results.\n\n      (defn inc-if-even\n        [n]\n        (if (even? n)\n          (maybe/just (inc n))\n          (maybe/nothing)))\n\n      (ctx/with-context maybe/context\n        (m/traverse inc-if-even [2 4]))\n      ;; => #<Just [3 4]>\n  \"\n  ([f tv]\n   (p/-traverse (p/-get-context tv) f tv))\n  ([ctx f tv]\n   (ctx/with-context ctx\n     (p/-traverse (p/-get-context tv) f tv))))\n","~:reader-features",["^H",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["var_args","G__39738","cats.core/mempty","js/Error","cats.protocols/-mempty","cats.context.infer.cljs$core$IFn$_invoke$arity$0","ctx","args__4795__auto__","len__4789__auto__","i__4790__auto__","argseq__4796__auto__","cljs.core/IndexedSeq","cats.core/mappend","seq39741","self__4777__auto__","cljs.core/seq","svs","cats.context.infer.cljs$core$IFn$_invoke$arity$1","cljs.core/first","cljs.core.reduce.cljs$core$IFn$_invoke$arity$2","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","cats.protocols/-mappend","G__39754","cats.core/pure","v","cats.core.pure.cljs$core$IFn$_invoke$arity$2","cats.protocols/-pure","G__39759","cats.core/return","cats.core.return$.cljs$core$IFn$_invoke$arity$2","cats.protocols/-mreturn","cats.core/bind","mv","f","cats.protocols/-mbind","cats.context/context?","cats.context/throw-illegal-argument","*context*-orig-val__39761","cats.context/*context*","*context*-temp-val__39762","G__39767","cats.core/mzero","cats.protocols/-mzero","cats.core/mplus","seq39769","mvs","cats.protocols/-mplus","cats.core/guard","b","cats.core.return$.cljs$core$IFn$_invoke$arity$1","cats.core.mzero.cljs$core$IFn$_invoke$arity$0","cats.core/join","cljs.core/identity","G__39774","cats.core/fmap","fv","cats.core.fmap.cljs$core$IFn$_invoke$arity$2","*context*-orig-val__39775","*context*-temp-val__39776","cats.protocols/-fmap","G__39780","cats.core/bimap","g","bv","cats.core.bimap.cljs$core$IFn$_invoke$arity$3","*context*-orig-val__39784","*context*-temp-val__39785","cats.protocols/-bimap","G__39787","cats.core/left-map","cats.core.left_map.cljs$core$IFn$_invoke$arity$2","G__39789","cats.core/right-map","cats.core.right_map.cljs$core$IFn$_invoke$arity$2","cats.core/fapply","seq39790","G__39791","cljs.core/next","self__4776__auto__","af","avs","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","cats.protocols/-fapply","G__39807","cats.core/when","cats.core.when.cljs$core$IFn$_invoke$arity$3","G__39817","cats.core/unless","cats.core.when.cljs$core$IFn$_invoke$arity$2","cljs.core/not","cats.core/deps","expr","syms","cljs.core/Symbol","cljs.core/contains?","cljs.core/List","cljs.core/seq?","p1__39821#","cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic","cats.core/rename-sym","renames","cljs.core.get.cljs$core$IFn$_invoke$arity$3","cats.core/rename","p1__39827#","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cats.core/dedupe-symbols*","sym->ap","body","p__39856","p__39857","map__39858","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","vec__39859","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","aps","seen","summ","s","ap","ap'","new-aps","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","s'","cljs.core.gensym.cljs$core$IFn$_invoke$arity$0","new-syms","new-seen","new-renames","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","new-body","renamer","cljs.core.mapv.cljs$core$IFn$_invoke$arity$3","cljs.core/vector","cats.core/dedupe-symbols","bindings","cljs.core/second","cats.core/dependency-map","symset","cljs.core/set","cljs.core.into.cljs$core$IFn$_invoke$arity$2","iter__4582__auto__","s__39872","cljs.core/LazySeq","temp__5735__auto__","cljs.core/chunked-seq?","c__4580__auto__","size__4581__auto__","cljs.core/count","b__39874","cljs.core/chunk-buffer","i__39873","vec__39877","cljs.core._nth.cljs$core$IFn$_invoke$arity$2","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__39871","cljs.core/chunk-rest","vec__39884","cljs.core/cons","cljs.core/rest","ds","cats.core/remove-deps","deps","removed","s__39888","b__39890","i__39889","vec__39891","iter__39887","vec__39898","depset","clojure.set.difference.cljs$core$IFn$_invoke$arity$2","cljs.core/empty","cats.core/topo-sort*","batches","current","cljs.core/empty?","vec__39904","dep","dependencies","dependant?","cljs.core/some","cljs.core.subvec.cljs$core$IFn$_invoke$arity$2","cats.core/topo-sort","cats.core/bindings->batches","sorted-deps","cats.core/alet*","env","fb","rb","fs","fa","code","cljs.core.sequence.cljs$core$IFn$_invoke$arity$1","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","acc","rs","faps","p1__39910#","cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic","cljs.core/vec","cljs.core.concat.cljs$core$IFn$_invoke$arity$1","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cf","sym","cljs.core/reverse","join-count","_","cljs.core.range.cljs$core$IFn$_invoke$arity$1","cats.core/arglists","var","cljs.core/meta","cats.core/single-arity?","args","cats.core/arity","cats.core/sequence","*context*-orig-val__39936","*context*-temp-val__39937","vs","cats.core/mapseq","mf","coll","cats.core/forseq","cats.core/filter","p","G__39939","cats.core/<$>","cats.core/<*>","G__39948","cats.core/>>=","args-arr__4810__auto__","argseq__4811__auto__","seq39945","G__39946","G__39947","G__39953","cats.core/>>","seq39950","G__39951","G__39952","mv'","cats.core/=<<","cats.core._GT__GT__EQ_.cljs$core$IFn$_invoke$arity$2","cats.core/>=>","mg","x","*context*-orig-val__39954","*context*-temp-val__39955","a","cats.core/<=<","*context*-orig-val__39962","*context*-temp-val__39963","cats.core/extract","cats.protocols/-extract","cats.core/<>","cats.core/foldr","z","xs","cats.protocols/-get-context","*context*-orig-val__39965","*context*-temp-val__39966","cats.protocols/-foldr","cats.core/foldl","*context*-orig-val__39968","*context*-temp-val__39969","cats.protocols/-foldl","G__39974","cats.core/foldm","vec__39976","seq__39977","first__39978","h","t","z'","cats.core.foldm.cljs$core$IFn$_invoke$arity$3","G__39984","cats.core/traverse","tv","cats.protocols/-traverse","*context*-orig-val__39985","*context*-temp-val__39986","cljs.core/chunk-first"]]],"~:cache-keys",["~#cmap",[["^23","goog/dom/tagname.js"],[1579687410012,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^H",[]],"~:deps-syms",["^1O","~$goog.dom.HtmlElement"]]],["^23","goog/math/math.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","~$goog.array","~$goog.asserts"]]],["^23","goog/html/trustedtypes.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O"]]],["^23","goog/labs/useragent/browser.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2E","~$goog.labs.userAgent.util","~$goog.object","~$goog.string.internal"]]],["^23","goog/html/safeurl.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2F","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^2I"]]],["^23","goog/array/array.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2F"]]],["^23","goog/debug/error.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O"]]],["^23","cats/protocols.cljc"],[1579687471496,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^1N"]]],["^23","goog/dom/nodetype.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O"]]],["^23","cats/core.cljc"],[1579687471496,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^1N","^1J","^1K","^1L"]]],["^23","goog/string/typedstring.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O"]]],["^23","goog/object/object.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O"]]],["^23","goog/dom/asserts.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2F"]]],"~:SHADOW-TIMESTAMP",[1579687469000,1579687405000],["^23","goog/math/long.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2F","~$goog.reflect"]]],["^23","goog/html/trustedresourceurl.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2F","~$goog.html.trustedtypes","^2L","^2M","^2N","^2O"]]],["^23","goog/string/internal.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O"]]],["^23","goog/functions/functions.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O"]]],["^23","goog/html/safestyle.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2E","^2F","~$goog.html.SafeUrl","^2N","^2O","^2I"]]],["^23","goog/dom/safe.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2F","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","~$goog.html.SafeScript","~$goog.html.SafeStyle","^2S","^2K","~$goog.html.uncheckedconversions","^2N","^2I"]]],["^23","goog/structs/map.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^23","goog/html/safehtml.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2E","^2F","~$goog.dom.TagName","~$goog.dom.tags","^2W","^2X","~$goog.html.SafeStyleSheet","^2S","^2K","^2R","^2L","^2M","~$goog.labs.userAgent.browser","^2H","^2N","^2O","^2I"]]],["^23","goog/dom/tags.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2H"]]],["^23","cats/context.cljc"],[1579687471496,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^1N","^1J"]]],["^23","goog/asserts/asserts.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^23","goog/uri/uri.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2E","^2F","~$goog.string","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^23","goog/i18n/bidi.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O"]]],["^23","goog/fs/url.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O"]]],["^23","goog/base.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",[]]],["^23","goog/structs/structs.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2E","^2H"]]],["^23","goog/string/string.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","~$goog.dom.safe","^2Y","^2N","^2I"]]],["^23","goog/reflect/reflect.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O"]]],["^23","goog/labs/useragent/util.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2I"]]],["^23","goog/string/stringbuffer.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O"]]],["^23","goog/iter/iter.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2E","^2F","^2U","~$goog.math"]]],["^23","goog/html/uncheckedconversions.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2F","^2V","^2W","^2X","^32","^2S","^2K","^2N","^2I"]]],["^23","goog/dom/htmlelement.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O"]]],["^23","cljs/core.cljs"],[1579687405264,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["~$goog.math.Long","~$goog.math.Integer","^36","^2H","^2E","~$goog.Uri","~$goog.string.StringBuffer"]]],["^23","goog/html/safescript.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2F","^2R","^2N","^2O"]]],["^23","goog/html/safestylesheet.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2E","^2F","^2X","^2H","^2N","^2O","^2I"]]],["^23","goog/math/integer.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2Q"]]],["^23","clojure/set.cljs"],[1579687405264,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^1N"]]],["^23","goog/uri/utils.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2E","^2F","^36"]]],["^23","goog/string/const.js"],[1579687410012,"^2@",["^ ","^2A",null,"^2B",["^H",[]],"^2C",["^1O","^2F","^2O"]]]]],"~:clj-info",["^ ","jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/source_map.clj",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/default_data_readers.clj",1579687401000,"jar:file:/C:/Users/PC/.m2/repository/funcool/cats/2.0.0/cats-2.0.0.jar!/cats/core.cljc",1579687471000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/source_map/base64.clj",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/set.clj",1579687402000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/string.clj",1579687402000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/analyzer.cljc",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/java/io.clj",1579687402000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/tagged_literals.cljc",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/util.cljc",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/compiler.cljc",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/source_map/base64_vlq.clj",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/core.clj",1579687402000,"jar:file:/C:/Users/PC/.m2/repository/funcool/cats/2.0.0/cats-2.0.0.jar!/cats/context.cljc",1579687471000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/impl/errors.clj",1579687401000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader.clj",1579687401000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/externs.clj",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/impl/inspect.clj",1579687401000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/js_deps.cljc",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/reader_types.clj",1579687401000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/data.json/0.2.6/data.json-0.2.6.jar!/clojure/data/json.clj",1579687401000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/edn.clj",1579687402000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/pprint.clj",1579687402000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/instant.clj",1579687402000,"jar:file:/C:/Users/PC/.m2/repository/funcool/cats/2.0.0/cats-2.0.0.jar!/cats/protocols.cljc",1579687471000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/core.cljc",1579687405000,"jar:file:/C:/Users/PC/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/env.cljc",1579687405000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","Category Theory abstractions for Clojure","^7","cats/core.cljc","^8",26,"^9",5,"^:",26,"^;",14],"^<",["^ ","^=","^>","^?","^@","^A","^B"],"^C",["^ ","^D","^E","^F","^E"],"^G",["^H",["^I","^J","^K","^L"]],"^M",["^ ","^N",["^ ","^O",["^P",[["^Q","^R","~$&","^S"]]],"^6","Thread like `as->`, within an applicative idiom.\n   See `cats.labs.sugar/ap->` for more in-depth discussion.","^8",540,"^9",1,"^7","cats/core.cljc","^T","^U","^V","^E","^W",true],"^F",["^ ","^O",["^P",[["^X","~$&","^Y"]]],"^6","Applicative composition macro similar to Clojure's\n     `let`. This macro facilitates composition of applicative\n     computations using `fmap` and `fapply` and evaluating\n     applicative values in parallel.\n\n     Let's see an example to understand how it works.\n     This code uses fmap for executing computations inside\n     an applicative context:\n\n       (fmap (fn [a] (inc a)) (just 1))\n       ;=> #<Just [2]>\n\n     Now see how this code can be made clearer\n     by using the alet macro:\n\n       (alet [a (just 1)]\n         (inc a))\n       ;=> #<Just [2]>\n\n     Let's look at a more complex example, imagine we have\n     dependencies between applicative values:\n\n       (join\n         (fapply\n          (fmap\n            (fn [a]\n              (fn [b]\n                (fmap (fn [c] (inc c))\n                      (just (+ a b)))))\n            (just 1))\n          (just 2)))\n       ;=> #<Just [4]>\n\n     This is greatly simplified using `alet`:\n\n       (alet [a (just 1)\n              b (just 2)\n              c (just (+ a b))]\n         (inc c))\n      ;=> #<Just [4]>\n\n     The intent of the code is much clearer and evaluates `a` and `b`\n     at the same time, then proceeds to evaluate `c` when all the values\n     it depends on are available. This evaluation strategy is specially\n     helpful for asynchronous applicatives.","^8",404,"^9",4,"^7","cats/core.cljc","^T","^Z","^V","^E","^W",true],"^[",["^ ","^O",["^P",[["^Q","~$&","^S"]]],"^6","Like `->`, but with monadic binding instead of pure application.\n   A mnemonic for the name is a pun on `>>=`, the monadic bind operator,\n   and clojure's regular arrow macros.\n\n   You can think of it as generalizing the `some->` thread macro\n   to all Monads instead of just Maybe.\n\n   Alternatively, if you think of the regular thread macro as\n   sugar for `let`:\n\n   (-> :a b (c (other args)) d)\n   =>\n   (let [res (b :a)\n         res (c res (other args))\n         res (d res)]\n     res)\n\n   Then `->=` is sugar for cats.core/mlet:\n\n   (->= m-a b (c (other args)) d)\n   (mlet [res m-a\n          res (c res (other args))\n          res (d res)]\n     (return res))\n\n   Note that extra args in this context are assumed pure, and will\n   be evaluated along with the function itself; this also matches\n   the behavior of `some->` wrt extra args.\n\n   Threading through pure functions is somewhat awkward, but can be done:\n\n   (->= m-a\n        monadic-fn\n        (-> pure-fn\n            other-pure-fn\n            m/return)\n        other-monadic-fn)","^8",552,"^9",1,"^7","cats/core.cljc","^T","^10","^V","^E","^W",true],"^11",["^ ","^O",["^P",[["~$x","~$&","^S"]]],"^6","Thread like `->`, within an applicative idiom.\n\n  Compare:\n\n  (macroexpand-1 `(-> a b c (d e f)))\n  => (d (c (b a) e f)\n\n  with:\n\n  (macroexpand-1 `(ap-> a b c (d e f))\n  => (ap d (ap c (ap b a) e f))\n  ","^8",504,"^9",1,"^7","cats/core.cljc","^T","^12","^V","^E","^W",true],"^13",["^ ","^O",["^P",[["~$f"],["~$n","~$f"]]],"^6","Lift a function with a given fixed arity to an applicative context.\n\n         (def app+ (lift-a 2 +))\n\n         (app+ (maybe/just 1) (maybe/just 2))\n         ;; => <Just 3>\n\n         (app+ (maybe/just 1) (maybe/nothing))\n         ;; => <Nothing>\n\n         (app+ [0 2 4] [1 2])\n         ;; => [1 2 3 4 5 6]\n     ","^8",728,"^9",4,"^7","cats/core.cljc","^T","^14","^V","^E","^W",true],"^15",["^ ","^O",["^P",[["~$f"],["~$n","~$f"]]],"^6","Lift a function with a given fixed arity to a monadic context.\n\n         (def monad+ (lift-m 2 +))\n\n         (monad+ (maybe/just 1) (maybe/just 2))\n         ;; => <Just [3]>\n\n         (monad+ (maybe/just 1) (maybe/nothing))\n         ;; => <Nothing>\n\n         (monad+ [0 2 4] [1 2])\n         ;; => [1 2 3 4 5 6]\n     ","^8",693,"^9",4,"^7","cats/core.cljc","^T","^16","^V","^E","^W",true],"^17",["^ ","^O",["^P",[["^Q","^R","~$&","^S"]]],"^6","Like `as->`, but with monadic binding instead of pure application.\n   See `cats.labs.sugar/->=` for more in-depth discussion.","^8",607,"^9",1,"^7","cats/core.cljc","^T","^18","^V","^E","^W",true],"^19",["^ ","^O",["^P",[["^Q","~$&","^S"]]],"^6","Like ->>, but with monadic binding instead of pure application.\n   See `cats.labs.sugar/->=` for more in-depth discussion.","^8",597,"^9",1,"^7","cats/core.cljc","^T","^1:","^V","^E","^W",true],"^1;",["^ ","^O",["^P",[["~$x","~$&","^S"]]],"^6","Thread like `->>`, within an applicative idiom.\n   See `cats.labs.sugar/ap->` for more in-depth discussion.","^8",527,"^9",1,"^7","cats/core.cljc","^T","^1<","^V","^E","^W",true],"^1=",["^ ","^O",["^P",[["~$f"],["~$n","~$f"]]],"^6","Given either a fixed arity function or an arity and a function,\n     return another which is curried.\n\n     With inferred arity (function must have one fixed arity):\n\n         (defn add2 [x y] (+ x y))\n         (def cadd2 (curry add2))\n\n         ((cadd2 1) 3)\n         ;; => 4\n\n         (cadd2 1 3)\n         ;; => 4\n\n     With given arity:\n\n         (def c+ (curry 3 +))\n\n         ((c+ 1 2) 3)\n         ;; => 6\n\n         ((((c+) 1) 2) 3)\n         ;; => 6\n     ","^8",652,"^9",4,"^7","cats/core.cljc","^T","^1>","^V","^E","^W",true],"^1?",["^ ","^O",["^P",[["^1@","^Y"]]],"^8",635,"^9",4,"^7","cats/core.cljc","^T","^1A","^V","^E","^W",true],"^1B",["^ ","^O",["^P",[["~$n","~$f"]]],"^6","Composition of `curry` and `lift-m`","^8",763,"^9",4,"^7","cats/core.cljc","^T","^1C","^V","^E","^W",true],"^1D",["^ ","^O",["^P",[["~$f","~$&","^1@"]]],"^6","Apply a pure function to applicative arguments, e.g.\n\n   (ap + (just 1) (just 2) (just 3))\n   ;; => #<Just [6]>\n   (ap str [\"hi\" \"lo\"] [\"bye\" \"woah\" \"hey\"])\n   ;; => [\"hibye\" \"hiwoah\" \"hihey\"\n          \"lobye\" \"lowoah\" \"lohey\"]\n\n   `ap` is essentially sugar for `(apply fapply (pure f) args)`,\n   but for the common case where you have a pure, uncurried,\n   possibly variadic function.\n\n   `ap` actually desugars in `alet` form:\n\n   (macroexpand-1 `(ap + (just 1) (just2)))\n   ;; => (alet [a1 (just 1) a2 (just 2)] (+ a1 a2))\n\n   That way, variadic functions Just Work, without needing to specify\n   an arity separately.\n\n   If you're familiar with Haskell, this is closest to writing\n   \"in Applicative style\": you can straightforwardly convert\n   pure function application to effectful application by with\n   some light syntax (<$> and <*> in case of Haskell, and `ap` here).\n\n   See the original Applicative paper for more inspiration:\n   http://staff.city.ac.uk/~ross/papers/Applicative.pdf","^8",471,"^9",1,"^7","cats/core.cljc","^T","^1E","^V","^E","^W",true],"^D",["^ ","^O",["^P",[["^X","~$&","^Y"]]],"^6","Monad composition macro that works like Clojure's\n     `let`. This facilitates much easier composition of\n     monadic computations.\n\n     Let's see an example to understand how it works.\n     This code uses bind to compose a few operations:\n\n         (bind (just 1)\n               (fn [a]\n                 (bind (just (inc a))\n                         (fn [b]\n                           (return (* b 2))))))\n         ;=> #<Just [4]>\n\n     Now see how this code can be made clearer\n     by using the mlet macro:\n\n         (mlet [a (just 1)\n                b (just (inc a))]\n           (return (* b 2)))\n         ;=> #<Just [4]>\n     ","^8",224,"^9",4,"^7","cats/core.cljc","^T","^1F","^V","^E","^W",true]],"^T","^E","^1H",null,"^1I",["^ ","^1J","^1J","~$p","^1J","^1K","^1K","^1L","^1L","^1M","^1L","^1N","^1N","^1O","^1O"],"^1P",["^H",["^1Q","^1R"]],"~:shadow/js-access-global",["^H",["Error"]],"^1S",null,"~:defs",["^ ","~$arity",["^ ","~:protocol-inline",null,"^5",["^ ","^7","cats/core.cljc","^8",629,"^9",8,"^:",629,"^;",13,"~:private",true,"^O",["^P",["~$quote",["^P",[["~$var"]]]]]],"^47",true,"^T","~$cats.core/arity","^7","cats/core.cljc","^;",13,"~:method-params",["^P",[["^49"]]],"~:protocol-impl",null,"~:arglists-meta",["^P",[null,null]],"^9",1,"~:variadic?",false,"^8",629,"~:ret-tag","~$number","^:",629,"~:max-fixed-arity",1,"~:fn-var",true,"^O",["^P",["^48",["^P",[["^49"]]]]]],"~$pure",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",54,"^9",7,"^:",54,"^;",11,"^O",["^P",["^48",["^P",[["~$v"],["^1M","~$v"]]]]],"^6","Given any value `v`, return it wrapped in\n  the default/effect-free context.\n\n  This is a multi-arity function that with arity `pure/1`\n  uses the dynamic scope to resolve the current\n  context. With `pure/2`, you can force a specific context\n  value.\n\n  Example:\n\n      (with-context either/context\n        (pure 1))\n      ;; => #<Right [1]>\n\n      (pure either/context 1)\n      ;; => #<Right [1]>\n  ","~:top-fn",["^ ","^4>",false,"~:fixed-arity",2,"^4A",2,"^4;",["^P",[["~$v"],["^1M","~$v"]]],"^O",["^P",[["~$v"],["^1M","~$v"]]],"^4=",["^P",[null,null]]]],"^T","~$cats.core/pure","^7","cats/core.cljc","^;",11,"^4D",["^ ","^4>",false,"^4E",2,"^4A",2,"^4;",["^P",[["~$v"],["^1M","~$v"]]],"^O",["^P",[["~$v"],["^1M","~$v"]]],"^4=",["^P",[null,null]]],"^4;",["^P",[["~$v"],["^1M","~$v"]]],"^4<",null,"^4E",2,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"~:methods",[["^ ","^4E",1,"^4>",false,"~:tag","~$any"],["^ ","^4E",2,"^4>",false,"^4H","^4I"]],"^8",54,"^:",54,"^4A",2,"^4B",true,"^O",["^P",[["~$v"],["^1M","~$v"]]],"^6","Given any value `v`, return it wrapped in\n  the default/effect-free context.\n\n  This is a multi-arity function that with arity `pure/1`\n  uses the dynamic scope to resolve the current\n  context. With `pure/2`, you can force a specific context\n  value.\n\n  Example:\n\n      (with-context either/context\n        (pure 1))\n      ;; => #<Right [1]>\n\n      (pure either/context 1)\n      ;; => #<Right [1]>\n  "],"~$arglists",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",619,"^9",8,"^:",619,"^;",16,"^47",true,"^O",["^P",["^48",["^P",[["^49"]]]]]],"^47",true,"^T","~$cats.core/arglists","^7","cats/core.cljc","^;",16,"^4;",["^P",[["^49"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",619,"^4?",["^H",["^4I","~$clj-nil"]],"^:",619,"^4A",1,"^4B",true,"^O",["^P",["^48",["^P",[["^49"]]]]]],"~$foldl",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",939,"^9",7,"^:",939,"^;",12,"^O",["^P",["^48",["^P",[["~$f","~$z","~$xs"]]]]],"^6","Perform a left-associative fold on the data structure."],"^T","~$cats.core/foldl","^7","cats/core.cljc","^;",12,"^4;",["^P",[["~$f","~$z","^4N"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",939,"^:",939,"^4A",3,"^4B",true,"^O",["^P",["^48",["^P",[["~$f","~$z","^4N"]]]]],"^6","Perform a left-associative fold on the data structure."],"~$fapply",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",186,"^9",7,"^:",186,"^;",13,"^O",["^P",["^48",["^P",[["~$af","~$&","~$avs"]]]]],"^6","Given a function wrapped in a monadic context `af`,\n  and a value wrapped in a monadic context `av`,\n  apply the unwrapped function to the unwrapped value\n  and return the result, wrapped in the same context as `av`.\n\n  This function is variadic, so it can be used like\n  a Haskell-style left-associative fapply.","^4D",["^ ","^4>",true,"^4E",1,"^4A",1,"^4;",[["^P",["^4Q","^4R"]]],"^O",["^P",[["^4Q","~$&","^4R"]]],"^4=",["^P",[null]]]],"^T","~$cats.core/fapply","^7","cats/core.cljc","^;",13,"^4D",["^ ","^4>",true,"^4E",1,"^4A",1,"^4;",[["^P",["^4Q","^4R"]]],"^O",["^P",[["^4Q","~$&","^4R"]]],"^4=",["^P",[null]]],"^4;",[["^P",["^4Q","^4R"]]],"^4<",null,"^4E",1,"^4=",["^P",[null]],"^9",1,"^4>",true,"^4G",[["^ ","^4E",1,"^4>",true,"^4H",["^H",[null,"^4I"]]]],"^8",186,"^4?","^4I","^:",186,"^4A",1,"^4B",true,"^O",["^P",[["^4Q","~$&","^4R"]]],"^6","Given a function wrapped in a monadic context `af`,\n  and a value wrapped in a monadic context `av`,\n  apply the unwrapped function to the unwrapped value\n  and return the result, wrapped in the same context as `av`.\n\n  This function is variadic, so it can be used like\n  a Haskell-style left-associative fapply."],"~$<*>",["^ ","^T","~$cats.core/<*>","^7","cats/core.cljc","^8",876,"^9",1,"^:",876,"^;",9,"^5",["^ ","^7","cats/core.cljc","^8",876,"^9",6,"^:",876,"^;",9],"^6","A Haskell-style `fapply` alias."],"~$guard",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",110,"^9",7,"^:",110,"^;",12,"^O",["^P",["^48",["^P",[["~$b"]]]]]],"^T","~$cats.core/guard","^7","cats/core.cljc","^;",12,"^4;",["^P",[["~$b"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",110,"^4?","^4I","^:",110,"^4A",1,"^4B",true,"^O",["^P",["^48",["^P",[["~$b"]]]]]],"~$join",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",116,"^9",7,"^:",116,"^;",11,"^O",["^P",["^48",["^P",[["~$mv"]]]]],"^6","Remove one level of monadic structure.\n  This is the same as `(bind mv identity)`."],"^T","~$cats.core/join","^7","cats/core.cljc","^;",11,"^4;",["^P",[["^4Y"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",116,"^4?","^4I","^:",116,"^4A",1,"^4B",true,"^O",["^P",["^48",["^P",[["^4Y"]]]]],"^6","Remove one level of monadic structure.\n  This is the same as `(bind mv identity)`."],"~$bimap",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",133,"^9",7,"^:",133,"^;",12,"^O",["^P",["^48",["^P",[["~$f","~$g"],["~$f","~$g","~$bv"]]]]],"^6","Map over both arguments at the same time.\n\n  Given functions `f` and `g` and a value wrapped in a bifunctor `bv`,\n  apply `f` to a first argument or `g` to a second argument.\n\n      (bimap dec inc (either/right 1)\n      ;; => #<Right 2>\n\n      (bimap dec inc (either/left 1)\n      ;; => #<Left 0>","^4D",["^ ","^4>",false,"^4E",3,"^4A",3,"^4;",["^P",[["~$f","~$g"],["~$f","~$g","^50"]]],"^O",["^P",[["~$f","~$g"],["~$f","~$g","^50"]]],"^4=",["^P",[null,null]]]],"^T","~$cats.core/bimap","^7","cats/core.cljc","^;",12,"^4D",["^ ","^4>",false,"^4E",3,"^4A",3,"^4;",["^P",[["~$f","~$g"],["~$f","~$g","^50"]]],"^O",["^P",[["~$f","~$g"],["~$f","~$g","^50"]]],"^4=",["^P",[null,null]]],"^4;",["^P",[["~$f","~$g"],["~$f","~$g","^50"]]],"^4<",null,"^4E",3,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^4G",[["^ ","^4E",2,"^4>",false,"^4H","~$function"],["^ ","^4E",3,"^4>",false]],"^8",133,"^:",133,"^4A",3,"^4B",true,"^O",["^P",[["~$f","~$g"],["~$f","~$g","^50"]]],"^6","Map over both arguments at the same time.\n\n  Given functions `f` and `g` and a value wrapped in a bifunctor `bv`,\n  apply `f` to a first argument or `g` to a second argument.\n\n      (bimap dec inc (either/right 1)\n      ;; => #<Right 2>\n\n      (bimap dec inc (either/left 1)\n      ;; => #<Left 0>"],"~$bind",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",81,"^9",7,"^:",81,"^;",11,"^O",["^P",["^48",["^P",[["^4Y","~$f"]]]]],"^6","Given a monadic value `mv` and a function `f`,\n  apply `f` to the unwrapped value of `mv`.\n\n      (bind (either/right 1) (fn [v]\n                               (return (inc v))))\n      ;; => #<Right [2]>\n\n  For convenience, you may prefer to use the `mlet` macro,\n  which provides a beautiful, `let`-like syntax for\n  composing operations with the `bind` function."],"^T","~$cats.core/bind","^7","cats/core.cljc","^;",11,"^4;",["^P",[["^4Y","~$f"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",81,"^4?","^4I","^:",81,"^4A",2,"^4B",true,"^O",["^P",["^48",["^P",[["^4Y","~$f"]]]]],"^6","Given a monadic value `mv` and a function `f`,\n  apply `f` to the unwrapped value of `mv`.\n\n      (bind (either/right 1) (fn [v]\n                               (return (inc v))))\n      ;; => #<Right [2]>\n\n  For convenience, you may prefer to use the `mlet` macro,\n  which provides a beautiful, `let`-like syntax for\n  composing operations with the `bind` function."],"~$deps",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",265,"^9",8,"^:",265,"^;",12,"^47",true,"^O",["^P",["^48",["^P",[["^Q","~$syms"]]]]]],"^47",true,"^T","~$cats.core/deps","^7","cats/core.cljc","^;",12,"^4;",["^P",[["^Q","^56"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",265,"^4?",["^H",["~$cljs.core/IList","^4I","~$cljs.core/List"]],"^:",265,"^4A",2,"^4B",true,"^O",["^P",["^48",["^P",[["^Q","^56"]]]]]],"~$topo-sort*",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",347,"^9",8,"^:",347,"^;",18,"^47",true,"^O",["^P",["^48",["^P",[["^55","~$seen","~$batches","~$current"]]]]]],"^47",true,"^T","~$cats.core/topo-sort*","^7","cats/core.cljc","^;",18,"^4;",["^P",[["^55","^5;","^5<","^5="]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",347,"^4?","~$clj","^:",347,"^4A",4,"^4B",true,"^O",["^P",["^48",["^P",[["^55","^5;","^5<","^5="]]]]]],"~$<$>",["^ ","^T","~$cats.core/<$>","^7","cats/core.cljc","^8",872,"^9",1,"^:",872,"^;",9,"^5",["^ ","^7","cats/core.cljc","^8",872,"^9",6,"^:",872,"^;",9],"^6","A Haskell-style `fmap` alias."],"~$<=<",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",915,"^9",7,"^:",915,"^;",10,"^O",["^P",["^48",["^P",[["~$mg","~$mf","~$x"]]]]],"^6","Right-to-left composition of monads.\n  Same as `>=>` with its first two arguments flipped."],"^T","~$cats.core/<=<","^7","cats/core.cljc","^;",10,"^4;",["^P",[["^5C","^5D","~$x"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",915,"^:",915,"^4A",3,"^4B",true,"^O",["^P",["^48",["^P",[["^5C","^5D","~$x"]]]]],"^6","Right-to-left composition of monads.\n  Same as `>=>` with its first two arguments flipped."],"~$alet*",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",377,"^9",8,"^:",377,"^;",13,"^47",true,"^O",["^P",["^48",["^P",[["^5<","~$env","^Y"]]]]]],"^47",true,"^T","~$cats.core/alet*","^7","cats/core.cljc","^;",13,"^4;",["^P",[["^5<","^5G","^Y"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",377,"^4?",["^H",[null,"^4I"]],"^:",377,"^4A",3,"^4B",true,"^O",["^P",["^48",["^P",[["^5<","^5G","^Y"]]]]]],"~$single-arity?",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",623,"^9",8,"^:",623,"^;",21,"^47",true,"^O",["^P",["^48",["^P",[["^49"]]]]]],"^47",true,"^T","~$cats.core/single-arity?","^7","cats/core.cljc","^;",21,"^4;",["^P",[["^49"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",623,"^4?","~$boolean","^:",623,"^4A",1,"^4B",true,"^O",["^P",["^48",["^P",[["^49"]]]]]],"^I",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",199,"^9",7,"^:",199,"^;",11,"^O",["^P",["^48",["^P",[["~$b","^4Y"],["^1M","~$b","^4Y"]]]]],"^6","Given an expression and a monadic value,\n  if the expression is logical true, return the monadic value.\n  Otherwise, return nil in a monadic context.","^4D",["^ ","^4>",false,"^4E",3,"^4A",3,"^4;",["^P",[["~$b","^4Y"],["^1M","~$b","^4Y"]]],"^O",["^P",[["~$b","^4Y"],["^1M","~$b","^4Y"]]],"^4=",["^P",[null,null]]]],"^T","~$cats.core/when","^7","cats/core.cljc","^;",11,"^4D",["^ ","^4>",false,"^4E",3,"^4A",3,"^4;",["^P",[["~$b","^4Y"],["^1M","~$b","^4Y"]]],"^O",["^P",[["~$b","^4Y"],["^1M","~$b","^4Y"]]],"^4=",["^P",[null,null]]],"^4;",["^P",[["~$b","^4Y"],["^1M","~$b","^4Y"]]],"^4<",null,"^4E",3,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^4G",[["^ ","^4E",2,"^4>",false,"^4H","^4I"],["^ ","^4E",3,"^4>",false,"^4H",["^H",[null,"^4I"]]]],"^8",199,"^:",199,"^4A",3,"^4B",true,"^O",["^P",[["~$b","^4Y"],["^1M","~$b","^4Y"]]],"^6","Given an expression and a monadic value,\n  if the expression is logical true, return the monadic value.\n  Otherwise, return nil in a monadic context."],"~$>>=",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",880,"^9",7,"^:",880,"^;",10,"^O",["^P",["^48",["^P",[["^4Y","~$f"],["^4Y","~$f","~$&","~$fs"]]]]],"^6","Perform a Haskell-style left-associative bind.\n\n  Let's see it in action:\n\n      (>>= (just 1) (comp just inc) (comp just inc))\n      ;; => #<Just [3]>\n  ","^4D",["^ ","^4>",true,"^4E",2,"^4A",2,"^4;",["^P",[["^4Y","~$f"]]],"^O",["^P",[["^4Y","~$f"],["^4Y","~$f","~$&","^5N"]]],"^4=",["^P",[null,null]]]],"^T","~$cats.core/>>=","^7","cats/core.cljc","^;",10,"^4D",["^ ","^4>",true,"^4E",2,"^4A",2,"^4;",["^P",[["^4Y","~$f"]]],"^O",["^P",[["^4Y","~$f"],["^4Y","~$f","~$&","^5N"]]],"^4=",["^P",[null,null]]],"^4;",["^P",[["^4Y","~$f"]]],"^4<",null,"^4E",2,"^4=",["^P",[null,null]],"^9",1,"^4>",true,"^4G",[["^ ","^4E",2,"^4>",false,"^4H","^4I"],["^ ","^4E",2,"^4>",true,"^4H",["^H",[null,"^4I"]]]],"^8",880,"^:",880,"^4A",2,"^4B",true,"^O",["^P",[["^4Y","~$f"],["^4Y","~$f","~$&","^5N"]]],"^6","Perform a Haskell-style left-associative bind.\n\n  Let's see it in action:\n\n      (>>= (just 1) (comp just inc) (comp just inc))\n      ;; => #<Just [3]>\n  "],"~$mzero",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",98,"^9",7,"^:",98,"^;",12,"^O",["^P",["^48",["^P",[[],["^1M"]]]]],"^4D",["^ ","^4>",false,"^4E",1,"^4A",1,"^4;",["^P",[[],["^1M"]]],"^O",["^P",[[],["^1M"]]],"^4=",["^P",[null,null]]]],"^T","~$cats.core/mzero","^7","cats/core.cljc","^;",12,"^4D",["^ ","^4>",false,"^4E",1,"^4A",1,"^4;",["^P",[[],["^1M"]]],"^O",["^P",[[],["^1M"]]],"^4=",["^P",[null,null]]],"^4;",["^P",[[],["^1M"]]],"^4<",null,"^4E",1,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^4G",[["^ ","^4E",0,"^4>",false,"^4H","^4I"],["^ ","^4E",1,"^4>",false,"^4H","^4I"]],"^8",98,"^:",98,"^4A",1,"^4B",true,"^O",["^P",[[],["^1M"]]]],"~$return",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",75,"^9",7,"^:",75,"^;",13,"^O",["^P",["^48",["^P",[["~$v"],["^1M","~$v"]]]]],"^6","This is a monad version of `pure` and works\n  identically to it.","^4D",["^ ","^4>",false,"^4E",2,"^4A",2,"^4;",["^P",[["~$v"],["^1M","~$v"]]],"^O",["^P",[["~$v"],["^1M","~$v"]]],"^4=",["^P",[null,null]]]],"^T","~$cats.core/return","^7","cats/core.cljc","^;",13,"^4D",["^ ","^4>",false,"^4E",2,"^4A",2,"^4;",["^P",[["~$v"],["^1M","~$v"]]],"^O",["^P",[["~$v"],["^1M","~$v"]]],"^4=",["^P",[null,null]]],"^4;",["^P",[["~$v"],["^1M","~$v"]]],"^4<",null,"^4E",2,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^4G",[["^ ","^4E",1,"^4>",false,"^4H","^4I"],["^ ","^4E",2,"^4>",false,"^4H","^4I"]],"^8",75,"^:",75,"^4A",2,"^4B",true,"^O",["^P",[["~$v"],["^1M","~$v"]]],"^6","This is a monad version of `pure` and works\n  identically to it."],"~$mappend",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",48,"^9",7,"^:",48,"^;",14,"^O",["^P",["^48",["^P",[["~$&","~$svs"]]]]],"^4D",["^ ","^4>",true,"^4E",0,"^4A",0,"^4;",[["^P",["^5U"]]],"^O",["^P",[["~$&","^5U"]]],"^4=",["^P",[null]]]],"^T","~$cats.core/mappend","^7","cats/core.cljc","^;",14,"^4D",["^ ","^4>",true,"^4E",0,"^4A",0,"^4;",[["^P",["^5U"]]],"^O",["^P",[["~$&","^5U"]]],"^4=",["^P",[null]]],"^4;",[["^P",["^5U"]]],"^4<",null,"^4E",0,"^4=",["^P",[null]],"^9",1,"^4>",true,"^4G",[["^ ","^4E",0,"^4>",true,"^4H","^4I"]],"^8",48,"^4?","^4I","^:",48,"^4A",0,"^4B",true,"^O",["^P",[["~$&","^5U"]]]],"~$mapseq",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",802,"^9",7,"^:",802,"^;",13,"^O",["^P",["^48",["^P",[["^5D","~$coll"]]]]],"^6","Given a function `mf` that takes a value and puts it into a\n  monadic context, and a collection, map `mf` over the collection,\n  calling `sequence` on the results.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/mapseq maybe/just [2 3])\n      ;=> <Just [[2 3]]>\n\n      (m/mapseq (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing)))\n                [1 2])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (mapseq #(maybe/just (* % 2)) []))\n      ;; => #<Just [()]>\n  "],"^T","~$cats.core/mapseq","^7","cats/core.cljc","^;",13,"^4;",["^P",[["^5D","^5X"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",802,"^4?",["^H",[null,"^4I"]],"^:",802,"^4A",2,"^4B",true,"^O",["^P",["^48",["^P",[["^5D","^5X"]]]]],"^6","Given a function `mf` that takes a value and puts it into a\n  monadic context, and a collection, map `mf` over the collection,\n  calling `sequence` on the results.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/mapseq maybe/just [2 3])\n      ;=> <Just [[2 3]]>\n\n      (m/mapseq (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing)))\n                [1 2])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (mapseq #(maybe/just (* % 2)) []))\n      ;; => #<Just [()]>\n  "],"~$mplus",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",104,"^9",7,"^:",104,"^;",12,"^O",["^P",["^48",["^P",[["~$&","~$mvs"]]]]],"^4D",["^ ","^4>",true,"^4E",0,"^4A",0,"^4;",[["^P",["^5["]]],"^O",["^P",[["~$&","^5["]]],"^4=",["^P",[null]]]],"^T","~$cats.core/mplus","^7","cats/core.cljc","^;",12,"^4D",["^ ","^4>",true,"^4E",0,"^4A",0,"^4;",[["^P",["^5["]]],"^O",["^P",[["~$&","^5["]]],"^4=",["^P",[null]]],"^4;",[["^P",["^5["]]],"^4<",null,"^4E",0,"^4=",["^P",[null]],"^9",1,"^4>",true,"^4G",[["^ ","^4E",0,"^4>",true,"^4H","^4I"]],"^8",104,"^4?","^4I","^:",104,"^4A",0,"^4B",true,"^O",["^P",[["~$&","^5["]]]],"~$dedupe-symbols",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",325,"^9",8,"^:",325,"^;",22,"^47",true,"^O",["^P",["^48",["^P",[["^X","^Y"]]]]]],"^47",true,"^T","~$cats.core/dedupe-symbols","^7","cats/core.cljc","^;",22,"^4;",["^P",[["^X","^Y"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",325,"^4?","^4I","^:",325,"^4A",2,"^4B",true,"^O",["^P",["^48",["^P",[["^X","^Y"]]]]]],"~$>>",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",893,"^9",7,"^:",893,"^;",9,"^O",["^P",["^48",["^P",[["^4Y","~$mv'"],["^4Y","^64","~$&","^5["]]]]],"^6","Perform a Haskell-style left-associative bind,\n  ignoring the values produced by the monadic computations.","^4D",["^ ","^4>",true,"^4E",2,"^4A",2,"^4;",["^P",[["^4Y","^64"]]],"^O",["^P",[["^4Y","^64"],["^4Y","^64","~$&","^5["]]],"^4=",["^P",[null,null]]]],"^T","~$cats.core/>>","^7","cats/core.cljc","^;",9,"^4D",["^ ","^4>",true,"^4E",2,"^4A",2,"^4;",["^P",[["^4Y","^64"]]],"^O",["^P",[["^4Y","^64"],["^4Y","^64","~$&","^5["]]],"^4=",["^P",[null,null]]],"^4;",["^P",[["^4Y","^64"]]],"^4<",null,"^4E",2,"^4=",["^P",[null,null]],"^9",1,"^4>",true,"^4G",[["^ ","^4E",2,"^4>",false,"^4H","^4I"],["^ ","^4E",2,"^4>",true,"^4H",["^H",[null,"^4I"]]]],"^8",893,"^:",893,"^4A",2,"^4B",true,"^O",["^P",[["^4Y","^64"],["^4Y","^64","~$&","^5["]]],"^6","Perform a Haskell-style left-associative bind,\n  ignoring the values produced by the monadic computations."],"~$rename",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",282,"^9",8,"^:",282,"^;",14,"^47",true,"^O",["^P",["^48",["^P",[["^Q","~$renames"]]]]]],"^47",true,"^T","~$cats.core/rename","^7","cats/core.cljc","^;",14,"^4;",["^P",[["^Q","^67"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",282,"^4?",["^H",[null,"^4I","~$cljs.core/LazySeq"]],"^:",282,"^4A",2,"^4B",true,"^O",["^P",["^48",["^P",[["^Q","^67"]]]]]],"~$rename-sym",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",278,"^9",8,"^:",278,"^;",18,"^47",true,"^O",["^P",["^48",["^P",[["^Q","^67"]]]]]],"^47",true,"^T","~$cats.core/rename-sym","^7","cats/core.cljc","^;",18,"^4;",["^P",[["^Q","^67"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",278,"^4?",["^H",[null,"^4I"]],"^:",278,"^4A",2,"^4B",true,"^O",["^P",["^48",["^P",[["^Q","^67"]]]]]],"^J",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",210,"^9",7,"^:",210,"^;",13,"^O",["^P",["^48",["^P",[["~$b","^4Y"],["^1M","~$b","^4Y"]]]]],"^6","Given an expression and a monadic value,\n  if the expression is not logical true, return the monadic value.\n  Otherwise, return nil in a monadic context.","^4D",["^ ","^4>",false,"^4E",3,"^4A",3,"^4;",["^P",[["~$b","^4Y"],["^1M","~$b","^4Y"]]],"^O",["^P",[["~$b","^4Y"],["^1M","~$b","^4Y"]]],"^4=",["^P",[null,null]]]],"^T","~$cats.core/unless","^7","cats/core.cljc","^;",13,"^4D",["^ ","^4>",false,"^4E",3,"^4A",3,"^4;",["^P",[["~$b","^4Y"],["^1M","~$b","^4Y"]]],"^O",["^P",[["~$b","^4Y"],["^1M","~$b","^4Y"]]],"^4=",["^P",[null,null]]],"^4;",["^P",[["~$b","^4Y"],["^1M","~$b","^4Y"]]],"^4<",null,"^4E",3,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^4G",[["^ ","^4E",2,"^4>",false,"^4H","^4I"],["^ ","^4E",3,"^4>",false,"^4H",["^H",[null,"^4I"]]]],"^8",210,"^:",210,"^4A",3,"^4B",true,"^O",["^P",[["~$b","^4Y"],["^1M","~$b","^4Y"]]],"^6","Given an expression and a monadic value,\n  if the expression is not logical true, return the monadic value.\n  Otherwise, return nil in a monadic context."],"~$traverse",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",988,"^9",7,"^:",988,"^;",15,"^O",["^P",["^48",["^P",[["~$f","~$tv"],["^1M","~$f","^6>"]]]]],"^6","Map each element of a structure to an action, evaluate these\n  actions from left to right, and collect the results.\n\n      (defn inc-if-even\n        [n]\n        (if (even? n)\n          (maybe/just (inc n))\n          (maybe/nothing)))\n\n      (ctx/with-context maybe/context\n        (m/traverse inc-if-even [2 4]))\n      ;; => #<Just [3 4]>\n  ","^4D",["^ ","^4>",false,"^4E",3,"^4A",3,"^4;",["^P",[["~$f","^6>"],["^1M","~$f","^6>"]]],"^O",["^P",[["~$f","^6>"],["^1M","~$f","^6>"]]],"^4=",["^P",[null,null]]]],"^T","~$cats.core/traverse","^7","cats/core.cljc","^;",15,"^4D",["^ ","^4>",false,"^4E",3,"^4A",3,"^4;",["^P",[["~$f","^6>"],["^1M","~$f","^6>"]]],"^O",["^P",[["~$f","^6>"],["^1M","~$f","^6>"]]],"^4=",["^P",[null,null]]],"^4;",["^P",[["~$f","^6>"],["^1M","~$f","^6>"]]],"^4<",null,"^4E",3,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^4G",[["^ ","^4E",2,"^4>",false,"^4H","^4I"],["^ ","^4E",3,"^4>",false]],"^8",988,"^:",988,"^4A",3,"^4B",true,"^O",["^P",[["~$f","^6>"],["^1M","~$f","^6>"]]],"^6","Map each element of a structure to an action, evaluate these\n  actions from left to right, and collect the results.\n\n      (defn inc-if-even\n        [n]\n        (if (even? n)\n          (maybe/just (inc n))\n          (maybe/nothing)))\n\n      (ctx/with-context maybe/context\n        (m/traverse inc-if-even [2 4]))\n      ;; => #<Just [3 4]>\n  "],"~$forseq",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",828,"^9",7,"^:",828,"^;",13,"^O",["^P",["^48",["^P",[["~$vs","^5D"]]]]],"^6","Same as `mapseq` but with the arguments flipped.\n\n  Let's see a little example:\n\n      (m/forseq [2 3] maybe/just)\n      ;; => <Just [[2 3]]>\n\n  Yet an other example that fails:\n\n      (m/forseq [1 2]\n                (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing))))\n      ;; => <Nothing>\n  "],"^T","~$cats.core/forseq","^7","cats/core.cljc","^;",13,"^4;",["^P",[["^6A","^5D"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",828,"^4?",["^H",[null,"^4I"]],"^:",828,"^4A",2,"^4B",true,"^O",["^P",["^48",["^P",[["^6A","^5D"]]]]],"^6","Same as `mapseq` but with the arguments flipped.\n\n  Let's see a little example:\n\n      (m/forseq [2 3] maybe/just)\n      ;; => <Just [[2 3]]>\n\n  Yet an other example that fails:\n\n      (m/forseq [1 2]\n                (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing))))\n      ;; => <Nothing>\n  "],"~$=<<",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",901,"^9",7,"^:",901,"^;",10,"^O",["^P",["^48",["^P",[["~$f","^4Y"]]]]],"^6","Same as the two argument version of `>>=` but with the\n  arguments flipped."],"^T","~$cats.core/=<<","^7","cats/core.cljc","^;",10,"^4;",["^P",[["~$f","^4Y"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",901,"^4?","^4I","^:",901,"^4A",2,"^4B",true,"^O",["^P",["^48",["^P",[["~$f","^4Y"]]]]],"^6","Same as the two argument version of `>>=` but with the\n  arguments flipped."],"~$foldr",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",932,"^9",7,"^:",932,"^;",12,"^O",["^P",["^48",["^P",[["~$f","~$z","^4N"]]]]],"^6","Perform a right-associative fold on the data structure."],"^T","~$cats.core/foldr","^7","cats/core.cljc","^;",12,"^4;",["^P",[["~$f","~$z","^4N"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",932,"^:",932,"^4A",3,"^4B",true,"^O",["^P",["^48",["^P",[["~$f","~$z","^4N"]]]]],"^6","Perform a right-associative fold on the data structure."],"~$>=>",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",907,"^9",7,"^:",907,"^;",10,"^O",["^P",["^48",["^P",[["^5D","^5C","~$x"]]]]],"^6","Left-to-right composition of monads."],"^T","~$cats.core/>=>","^7","cats/core.cljc","^;",10,"^4;",["^P",[["^5D","^5C","~$x"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",907,"^:",907,"^4A",3,"^4B",true,"^O",["^P",["^48",["^P",[["^5D","^5C","~$x"]]]]],"^6","Left-to-right composition of monads."],"~$dependency-map",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",332,"^9",8,"^:",332,"^;",22,"^47",true,"^O",["^P",["^48",["^P",[["~$sym->ap"]]]]]],"^47",true,"^T","~$cats.core/dependency-map","^7","cats/core.cljc","^;",22,"^4;",["^P",[["^6J"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",332,"^4?",["^H",[null,"^5?","^4I"]],"^:",332,"^4A",1,"^4B",true,"^O",["^P",["^48",["^P",[["^6J"]]]]]],"~$<>",["^ ","^T","~$cats.core/<>","^7","cats/core.cljc","^8",930,"^9",1,"^:",930,"^;",8,"^5",["^ ","^7","cats/core.cljc","^8",930,"^9",6,"^:",930,"^;",8]],"~$right-map",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",169,"^9",7,"^:",169,"^;",16,"^O",["^P",["^48",["^P",[["~$g"],["~$g","^50"]]]]],"^6","Map covariantly over the second argument.\n\n  Given a function `g` and a value wrapped in a bifunctor `bv`,\n  apply `g` to the second argument, if present, otherwise leave `bv` unchanged.\n\n      (right-map inc (either/right 1)\n      ;; => #<Right 2>\n\n      (right-map inc (either/left 1)\n      ;; => #<Left 1>","^4D",["^ ","^4>",false,"^4E",2,"^4A",2,"^4;",["^P",[["~$g"],["~$g","^50"]]],"^O",["^P",[["~$g"],["~$g","^50"]]],"^4=",["^P",[null,null]]]],"^T","~$cats.core/right-map","^7","cats/core.cljc","^;",16,"^4D",["^ ","^4>",false,"^4E",2,"^4A",2,"^4;",["^P",[["~$g"],["~$g","^50"]]],"^O",["^P",[["~$g"],["~$g","^50"]]],"^4=",["^P",[null,null]]],"^4;",["^P",[["~$g"],["~$g","^50"]]],"^4<",null,"^4E",2,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^4G",[["^ ","^4E",1,"^4>",false,"^4H","^52"],["^ ","^4E",2,"^4>",false,"^4H","^4I"]],"^8",169,"^:",169,"^4A",2,"^4B",true,"^O",["^P",[["~$g"],["~$g","^50"]]],"^6","Map covariantly over the second argument.\n\n  Given a function `g` and a value wrapped in a bifunctor `bv`,\n  apply `g` to the second argument, if present, otherwise leave `bv` unchanged.\n\n      (right-map inc (either/right 1)\n      ;; => #<Right 2>\n\n      (right-map inc (either/left 1)\n      ;; => #<Left 1>"],"~$topo-sort",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",364,"^9",8,"^:",364,"^;",17,"^47",true,"^O",["^P",["^48",["^P",[["^55"]]]]]],"^47",true,"^T","~$cats.core/topo-sort","^7","cats/core.cljc","^;",17,"^4;",["^P",[["^55"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",364,"^4?","^5?","^:",364,"^4A",1,"^4B",true,"^O",["^P",["^48",["^P",[["^55"]]]]]],"^K",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",848,"^9",7,"^:",848,"^;",13,"^O",["^P",["^48",["^P",[["~$p","^4Y"]]]]],"^6","Apply a predicate to a value in a `MonadZero` instance,\n  returning the identity element when the predicate does not hold.\n\n  Otherwise, return the instance unchanged.\n\n      (require '[cats.monad.maybe :as maybe])\n      (require '[cats.core :as m])\n\n      (m/filter (partial < 2) (maybe/just 3))\n      ;=> <Just [3]>\n\n      (m/filter (partial < 4) (maybe/just 3))\n      ;=> <Nothing>\n  "],"^T","~$cats.core/filter","^7","cats/core.cljc","^;",13,"^4;",["^P",[["~$p","^4Y"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",848,"^4?","^4I","^:",848,"^4A",2,"^4B",true,"^O",["^P",["^48",["^P",[["~$p","^4Y"]]]]],"^6","Apply a predicate to a value in a `MonadZero` instance,\n  returning the identity element when the predicate does not hold.\n\n  Otherwise, return the instance unchanged.\n\n      (require '[cats.monad.maybe :as maybe])\n      (require '[cats.core :as m])\n\n      (m/filter (partial < 2) (maybe/just 3))\n      ;=> <Just [3]>\n\n      (m/filter (partial < 4) (maybe/just 3))\n      ;=> <Nothing>\n  "],"~$left-map",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",152,"^9",7,"^:",152,"^;",15,"^O",["^P",["^48",["^P",[["~$f"],["~$f","^50"]]]]],"^6","Map covariantly over the first argument.\n\n  Given a function `f` and a value wrapped in a bifunctor `bv`,\n  apply `f` to the first argument, if present, otherwise leave `bv` unchanged.\n\n      (left-map dec (either/right 1)\n      ;; => #<Right 1>\n\n      (left-map dec (either/left 1)\n      ;; => #<Left 0>","^4D",["^ ","^4>",false,"^4E",2,"^4A",2,"^4;",["^P",[["~$f"],["~$f","^50"]]],"^O",["^P",[["~$f"],["~$f","^50"]]],"^4=",["^P",[null,null]]]],"^T","~$cats.core/left-map","^7","cats/core.cljc","^;",15,"^4D",["^ ","^4>",false,"^4E",2,"^4A",2,"^4;",["^P",[["~$f"],["~$f","^50"]]],"^O",["^P",[["~$f"],["~$f","^50"]]],"^4=",["^P",[null,null]]],"^4;",["^P",[["~$f"],["~$f","^50"]]],"^4<",null,"^4E",2,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^4G",[["^ ","^4E",1,"^4>",false,"^4H","^52"],["^ ","^4E",2,"^4>",false,"^4H","^4I"]],"^8",152,"^:",152,"^4A",2,"^4B",true,"^O",["^P",[["~$f"],["~$f","^50"]]],"^6","Map covariantly over the first argument.\n\n  Given a function `f` and a value wrapped in a bifunctor `bv`,\n  apply `f` to the first argument, if present, otherwise leave `bv` unchanged.\n\n      (left-map dec (either/right 1)\n      ;; => #<Right 1>\n\n      (left-map dec (either/left 1)\n      ;; => #<Left 0>"],"~$dedupe-symbols*",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",292,"^9",8,"^:",292,"^;",23,"^47",true,"^O",["^P",["^48",["^P",[["^6J","^Y"]]]]]],"^47",true,"^T","~$cats.core/dedupe-symbols*","^7","cats/core.cljc","^;",23,"^4;",["^P",[["^6J","^Y"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",292,"^:",292,"^4A",2,"^4B",true,"^O",["^P",["^48",["^P",[["^6J","^Y"]]]]]],"~$fmap",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",122,"^9",7,"^:",122,"^;",11,"^O",["^P",["^48",["^P",[["~$f"],["~$f","~$fv"]]]]],"^6","Apply a function `f` to the value wrapped in functor `fv`,\n  preserving the context type.","^4D",["^ ","^4>",false,"^4E",2,"^4A",2,"^4;",["^P",[["~$f"],["~$f","^6X"]]],"^O",["^P",[["~$f"],["~$f","^6X"]]],"^4=",["^P",[null,null]]]],"^T","~$cats.core/fmap","^7","cats/core.cljc","^;",11,"^4D",["^ ","^4>",false,"^4E",2,"^4A",2,"^4;",["^P",[["~$f"],["~$f","^6X"]]],"^O",["^P",[["~$f"],["~$f","^6X"]]],"^4=",["^P",[null,null]]],"^4;",["^P",[["~$f"],["~$f","^6X"]]],"^4<",null,"^4E",2,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^4G",[["^ ","^4E",1,"^4>",false,"^4H","^52"],["^ ","^4E",2,"^4>",false]],"^8",122,"^:",122,"^4A",2,"^4B",true,"^O",["^P",[["~$f"],["~$f","^6X"]]],"^6","Apply a function `f` to the value wrapped in functor `fv`,\n  preserving the context type."],"~$mempty",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",44,"^9",7,"^:",44,"^;",13,"^O",["^P",["^48",["^P",[[],["^1M"]]]]],"^4D",["^ ","^4>",false,"^4E",1,"^4A",1,"^4;",["^P",[[],["^1M"]]],"^O",["^P",[[],["^1M"]]],"^4=",["^P",[null,null]]]],"^T","~$cats.core/mempty","^7","cats/core.cljc","^;",13,"^4D",["^ ","^4>",false,"^4E",1,"^4A",1,"^4;",["^P",[[],["^1M"]]],"^O",["^P",[[],["^1M"]]],"^4=",["^P",[null,null]]],"^4;",["^P",[[],["^1M"]]],"^4<",null,"^4E",1,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^4G",[["^ ","^4E",0,"^4>",false,"^4H","^4I"],["^ ","^4E",1,"^4>",false,"^4H","^4I"]],"^8",44,"^:",44,"^4A",1,"^4B",true,"^O",["^P",[[],["^1M"]]]],"~$remove-deps",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",341,"^9",8,"^:",341,"^;",19,"^47",true,"^O",["^P",["^48",["^P",[["^55","~$symset"]]]]]],"^47",true,"^T","~$cats.core/remove-deps","^7","cats/core.cljc","^;",19,"^4;",["^P",[["^55","^71"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",341,"^4?",["^H",[null,"^5?","^4I"]],"^:",341,"^4A",2,"^4B",true,"^O",["^P",["^48",["^P",[["^55","^71"]]]]]],"~$extract",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",924,"^9",7,"^:",924,"^;",14,"^O",["^P",["^48",["^P",[["~$v"]]]]],"^6","Generic function to unwrap/extract\n  the inner value of a container."],"^T","~$cats.core/extract","^7","cats/core.cljc","^;",14,"^4;",["^P",[["~$v"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",924,"^4?","^4I","^:",924,"^4A",1,"^4B",true,"^O",["^P",["^48",["^P",[["~$v"]]]]],"^6","Generic function to unwrap/extract\n  the inner value of a container."],"^L",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",772,"^9",7,"^:",772,"^;",15,"^O",["^P",["^48",["^P",[["^5["]]]]],"^6","Given a collection of monadic values, collect\n  their values in a seq returned in the monadic context.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/sequence [(maybe/just 2) (maybe/just 3)])\n      ;; => #<Just [[2, 3]]>\n\n      (m/sequence [(maybe/nothing) (maybe/just 3)])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (m/sequence []))\n      ;; => #<Just [()]>\n  "],"^T","~$cats.core/sequence","^7","cats/core.cljc","^;",15,"^4;",["^P",[["^5["]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",772,"^4?",["^H",[null,"^4I"]],"^:",772,"^4A",1,"^4B",true,"^O",["^P",["^48",["^P",[["^5["]]]]],"^6","Given a collection of monadic values, collect\n  their values in a seq returned in the monadic context.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/sequence [(maybe/just 2) (maybe/just 3)])\n      ;; => #<Just [[2, 3]]>\n\n      (m/sequence [(maybe/nothing) (maybe/just 3)])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (m/sequence []))\n      ;; => #<Just [()]>\n  "],"~$foldm",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",946,"^9",7,"^:",946,"^;",12,"^O",["^P",["^48",["^P",[["~$f","~$z","^4N"],["^1M","~$f","~$z","^4N"]]]]],"^6","Given an optional monadic context, a function that takes two non-monadic\n  arguments and returns a value inside the given monadic context, an initial\n  value, and a collection of values, perform a left-associative fold.\n\n      (require '[cats.context :as ctx]\n               '[cats.core :as m]\n               '[cats.monad.maybe :as maybe])\n\n      (defn m-div [x y]\n        (if (zero? y)\n          (maybe/nothing)\n          (maybe/just (/ x y))))\n\n      (m/foldm m-div 1 [1 2 3])\n      (m/foldm maybe/context m-div 1 [1 2 3])\n      ;; => #<Just 1/6>\n\n      (m/foldm maybe/context m-div 1 [1 0 3])\n      ;; => #<Nothing>\n\n      (foldm m-div 1 [])\n      ;; => Exception\n\n      (m/foldm maybe/context m-div 1 [])\n      (ctx/with-context maybe/context\n        (foldm m-div 1 []))\n      ;; => #<Just 1>\n  ","^4D",["^ ","^4>",false,"^4E",4,"^4A",4,"^4;",["^P",[["~$f","~$z","^4N"],["^1M","~$f","~$z","^4N"]]],"^O",["^P",[["~$f","~$z","^4N"],["^1M","~$f","~$z","^4N"]]],"^4=",["^P",[null,null]]]],"^T","~$cats.core/foldm","^7","cats/core.cljc","^;",12,"^4D",["^ ","^4>",false,"^4E",4,"^4A",4,"^4;",["^P",[["~$f","~$z","^4N"],["^1M","~$f","~$z","^4N"]]],"^O",["^P",[["~$f","~$z","^4N"],["^1M","~$f","~$z","^4N"]]],"^4=",["^P",[null,null]]],"^4;",["^P",[["~$f","~$z","^4N"],["^1M","~$f","~$z","^4N"]]],"^4<",null,"^4E",4,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^4G",[["^ ","^4E",3,"^4>",false,"^4H","^4I"],["^ ","^4E",4,"^4>",false,"^4H","^4I"]],"^8",946,"^:",946,"^4A",4,"^4B",true,"^O",["^P",[["~$f","~$z","^4N"],["^1M","~$f","~$z","^4N"]]],"^6","Given an optional monadic context, a function that takes two non-monadic\n  arguments and returns a value inside the given monadic context, an initial\n  value, and a collection of values, perform a left-associative fold.\n\n      (require '[cats.context :as ctx]\n               '[cats.core :as m]\n               '[cats.monad.maybe :as maybe])\n\n      (defn m-div [x y]\n        (if (zero? y)\n          (maybe/nothing)\n          (maybe/just (/ x y))))\n\n      (m/foldm m-div 1 [1 2 3])\n      (m/foldm maybe/context m-div 1 [1 2 3])\n      ;; => #<Just 1/6>\n\n      (m/foldm maybe/context m-div 1 [1 0 3])\n      ;; => #<Nothing>\n\n      (foldm m-div 1 [])\n      ;; => Exception\n\n      (m/foldm maybe/context m-div 1 [])\n      (ctx/with-context maybe/context\n        (foldm m-div 1 []))\n      ;; => #<Just 1>\n  "],"~$bindings->batches",["^ ","^46",null,"^5",["^ ","^7","cats/core.cljc","^8",369,"^9",8,"^:",369,"^;",25,"^47",true,"^O",["^P",["^48",["^P",[["^X"]]]]]],"^47",true,"^T","~$cats.core/bindings->batches","^7","cats/core.cljc","^;",25,"^4;",["^P",[["^X"]]],"^4<",null,"^4=",["^P",[null,null]],"^9",1,"^4>",false,"^8",369,"^4?","^5?","^:",369,"^4A",1,"^4B",true,"^O",["^P",["^48",["^P",[["^X"]]]]]]],"^1R",["^ ","^E","^E","^1L","^1L","^1M","^1L","^1N","^1N"],"~:cljs.analyzer/constants",["^ ","^1P",["^H",["~$&","^4","~:else","^6Y","~$do","~:syms","^4S","~:aps","^1P","^4Z","~$cljs.core/fn","^O","~:body"]],"~:order",["^7;","^7@","^7=","^7>","^1P","^4","^6Y","^7?","^4S","^7<","^4Z","^O","~$&"]],"^1[",["^ ","^1R",["^H",[]],"^1Q",["^H",[]]],"^20",["^ "],"^21",["^1O","^1N","^1J","^1K","^1L"]],"^V","^E","~:ns-specs",["^ "],"~:ns-spec-vars",["^H",[]],"~:compiler-options",["^2?",[["^7D","~:static-fns"],true,["^7D","~:shadow-tweaks"],null,["^7D","~:elide-asserts"],false,["^7D","~:optimize-constants"],null,["^7D","^26"],null,["^7D","~:external-config"],null,["^7D","~:tooling-config"],null,["^7D","~:emit-constants"],null,["^7D","~:load-tests"],null,["^7D","~:form-size-threshold"],null,["^7D","~:infer-externs"],"~:auto",["^7D","^28"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^7D","~:fn-invoke-direct"],null,["^7D","~:source-map"],"/dev/null"]]]