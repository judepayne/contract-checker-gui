["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/scheduler/cjs/scheduler-tracing.development.js"],"~:js","shadow$provide.module$node_modules$scheduler$cjs$scheduler_tracing_development=function(global,require,module,exports){(function(){function onInteractionTraced(interaction){var didCatchError=!1,caughtError=null;subscribers.forEach(function(subscriber){try{subscriber.onInteractionTraced(interaction)}catch(error){didCatchError||(didCatchError=!0,caughtError=error)}});if(didCatchError)throw caughtError;}function onInteractionScheduledWorkCompleted(interaction){var didCatchError=!1,caughtError=null;subscribers.forEach(function(subscriber){try{subscriber.onInteractionScheduledWorkCompleted(interaction)}catch(error){didCatchError||\n(didCatchError=!0,caughtError=error)}});if(didCatchError)throw caughtError;}function onWorkScheduled(interactions,threadID){var didCatchError=!1,caughtError=null;subscribers.forEach(function(subscriber){try{subscriber.onWorkScheduled(interactions,threadID)}catch(error){didCatchError||(didCatchError=!0,caughtError=error)}});if(didCatchError)throw caughtError;}function onWorkStarted(interactions,threadID){var didCatchError=!1,caughtError=null;subscribers.forEach(function(subscriber){try{subscriber.onWorkStarted(interactions,\nthreadID)}catch(error){didCatchError||(didCatchError=!0,caughtError=error)}});if(didCatchError)throw caughtError;}function onWorkStopped(interactions,threadID){var didCatchError=!1,caughtError=null;subscribers.forEach(function(subscriber){try{subscriber.onWorkStopped(interactions,threadID)}catch(error){didCatchError||(didCatchError=!0,caughtError=error)}});if(didCatchError)throw caughtError;}function onWorkCanceled(interactions,threadID){var didCatchError=!1,caughtError=null;subscribers.forEach(function(subscriber){try{subscriber.onWorkCanceled(interactions,\nthreadID)}catch(error){didCatchError||(didCatchError=!0,caughtError=error)}});if(didCatchError)throw caughtError;}Object.defineProperty(exports,\"__esModule\",{value:!0});var interactionIDCounter=0,threadIDCounter=0;exports.__interactionsRef=null;exports.__subscriberRef=null;exports.__interactionsRef={current:new Set};exports.__subscriberRef={current:null};var subscribers=null;subscribers=new Set;exports.unstable_clear=function(callback){var prevInteractions=exports.__interactionsRef.current;exports.__interactionsRef.current=\nnew Set;try{return callback()}finally{exports.__interactionsRef.current=prevInteractions}};exports.unstable_getCurrent=function(){return exports.__interactionsRef.current};exports.unstable_getThreadID=function(){return++threadIDCounter};exports.unstable_trace=function(name,timestamp,callback){var threadID=3<arguments.length&&void 0!==arguments[3]?arguments[3]:0,interaction={__count:1,id:interactionIDCounter++,name:name,timestamp:timestamp},prevInteractions=exports.__interactionsRef.current,interactions=\nnew Set(prevInteractions);interactions.add(interaction);exports.__interactionsRef.current=interactions;var subscriber=exports.__subscriberRef.current,returnValue=void 0;try{if(null!==subscriber)subscriber.onInteractionTraced(interaction)}finally{try{if(null!==subscriber)subscriber.onWorkStarted(interactions,threadID)}finally{try{returnValue=callback()}finally{exports.__interactionsRef.current=prevInteractions;try{if(null!==subscriber)subscriber.onWorkStopped(interactions,threadID)}finally{if(interaction.__count--,\nnull!==subscriber&&0===interaction.__count)subscriber.onInteractionScheduledWorkCompleted(interaction)}}}}return returnValue};exports.unstable_wrap=function(callback){function wrapped(){var prevInteractions=exports.__interactionsRef.current;exports.__interactionsRef.current=wrappedInteractions;subscriber=exports.__subscriberRef.current;try{var returnValue=void 0;try{if(null!==subscriber)subscriber.onWorkStarted(wrappedInteractions,threadID)}finally{try{returnValue=callback.apply(void 0,arguments)}finally{if(exports.__interactionsRef.current=\nprevInteractions,null!==subscriber)subscriber.onWorkStopped(wrappedInteractions,threadID)}}return returnValue}finally{hasRun||(hasRun=!0,wrappedInteractions.forEach(function(interaction){interaction.__count--;if(null!==subscriber&&0===interaction.__count)subscriber.onInteractionScheduledWorkCompleted(interaction)}))}}var threadID=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0,wrappedInteractions=exports.__interactionsRef.current,subscriber=exports.__subscriberRef.current;if(null!==subscriber)subscriber.onWorkScheduled(wrappedInteractions,\nthreadID);wrappedInteractions.forEach(function(interaction){interaction.__count++});var hasRun=!1;wrapped.cancel=function(){subscriber=exports.__subscriberRef.current;try{if(null!==subscriber)subscriber.onWorkCanceled(wrappedInteractions,threadID)}finally{wrappedInteractions.forEach(function(interaction){interaction.__count--;if(subscriber&&0===interaction.__count)subscriber.onInteractionScheduledWorkCompleted(interaction)})}};return wrapped};exports.unstable_subscribe=function(subscriber){subscribers.add(subscriber);\n1===subscribers.size&&(exports.__subscriberRef.current={onInteractionScheduledWorkCompleted:onInteractionScheduledWorkCompleted,onInteractionTraced:onInteractionTraced,onWorkCanceled:onWorkCanceled,onWorkScheduled:onWorkScheduled,onWorkStarted:onWorkStarted,onWorkStopped:onWorkStopped})};exports.unstable_unsubscribe=function(subscriber){subscribers.delete(subscriber);0===subscribers.size&&(exports.__subscriberRef.current=null)}})()}","~:source","shadow$provide[\"module$node_modules$scheduler$cjs$scheduler_tracing_development\"] = function(global,require,module,exports) {\n/** @license React v0.15.0\r\n * scheduler-tracing.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n'use strict';\r\n\r\n\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  (function() {\r\n'use strict';\r\n\r\nObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\r\n\r\n\r\n// In some cases, StrictMode should also double-render lifecycles.\r\n// This can be confusing for tests though,\r\n// And it can be bad for performance in production.\r\n// This feature flag can be used to control the behavior:\r\n\r\n\r\n// To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\r\n// replay the begin phase of a failed component inside invokeGuardedCallback.\r\n\r\n\r\n// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\r\n\r\n\r\n// Gather advanced timing metrics for Profiler subtrees.\r\n\r\n\r\n// Trace which interactions trigger each commit.\r\nvar enableSchedulerTracing = true;\r\n\r\n// Only used in www builds.\r\n // TODO: true? Here it might just be false.\r\n\r\n// Only used in www builds.\r\n\r\n\r\n// Only used in www builds.\r\n\r\n\r\n// Disable javascript: URL strings in href for XSS protection.\r\n\r\n\r\n// React Fire: prevent the value and checked attributes from syncing\r\n// with their related DOM properties\r\n\r\n\r\n// These APIs will no longer be \"unstable\" in the upcoming 16.7 release,\r\n// Control this behavior with a flag to support 16.6 minor releases in the meanwhile.\r\n\r\n\r\n\r\n\r\n// See https://github.com/react-native-community/discussions-and-proposals/issues/72 for more information\r\n// This is a flag so we can fix warnings in RN core before turning it on\r\n\r\n\r\n// Experimental React Flare event system and event components support.\r\n\r\n\r\n// Experimental Host Component support.\r\n\r\n\r\n// New API for JSX transforms to target - https://github.com/reactjs/rfcs/pull/107\r\n\r\n\r\n// We will enforce mocking scheduler with scheduler/unstable_mock at some point. (v17?)\r\n// Till then, we warn about the missing mock, but still fallback to a sync mode compatible version\r\n\r\n// Temporary flag to revert the fix in #15650\r\n\r\n\r\n// For tests, we flush suspense fallbacks in an act scope;\r\n// *except* in some of our own tests, where we test incremental loading states.\r\n\r\n\r\n// Changes priority of some events like mousemove to user-blocking priority,\r\n// but without making them discrete. The flag exists in case it causes\r\n// starvation problems.\r\n\r\n\r\n// Add a callback property to suspense to notify which promises are currently\r\n// in the update queue. This allows reporting and tracing of what is causing\r\n// the user to see a loading state.\r\n\r\n\r\n// Part of the simplification of React.createElement so we can eventually move\r\n// from React.createElement to React.jsx\r\n// https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md\r\n\r\nvar DEFAULT_THREAD_ID = 0;\r\n\r\n// Counters used to generate unique IDs.\r\nvar interactionIDCounter = 0;\r\nvar threadIDCounter = 0;\r\n\r\n// Set of currently traced interactions.\r\n// Interactions \"stack\"â€“\r\n// Meaning that newly traced interactions are appended to the previously active set.\r\n// When an interaction goes out of scope, the previous set (if any) is restored.\r\nexports.__interactionsRef = null;\r\n\r\n// Listener(s) to notify when interactions begin and end.\r\nexports.__subscriberRef = null;\r\n\r\nif (enableSchedulerTracing) {\r\n  exports.__interactionsRef = {\r\n    current: new Set()\r\n  };\r\n  exports.__subscriberRef = {\r\n    current: null\r\n  };\r\n}\r\n\r\nfunction unstable_clear(callback) {\r\n  if (!enableSchedulerTracing) {\r\n    return callback();\r\n  }\r\n\r\n  var prevInteractions = exports.__interactionsRef.current;\r\n  exports.__interactionsRef.current = new Set();\r\n\r\n  try {\r\n    return callback();\r\n  } finally {\r\n    exports.__interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\n\r\nfunction unstable_getCurrent() {\r\n  if (!enableSchedulerTracing) {\r\n    return null;\r\n  } else {\r\n    return exports.__interactionsRef.current;\r\n  }\r\n}\r\n\r\nfunction unstable_getThreadID() {\r\n  return ++threadIDCounter;\r\n}\r\n\r\nfunction unstable_trace(name, timestamp, callback) {\r\n  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\r\n\r\n  if (!enableSchedulerTracing) {\r\n    return callback();\r\n  }\r\n\r\n  var interaction = {\r\n    __count: 1,\r\n    id: interactionIDCounter++,\r\n    name: name,\r\n    timestamp: timestamp\r\n  };\r\n\r\n  var prevInteractions = exports.__interactionsRef.current;\r\n\r\n  // Traced interactions should stack/accumulate.\r\n  // To do that, clone the current interactions.\r\n  // The previous set will be restored upon completion.\r\n  var interactions = new Set(prevInteractions);\r\n  interactions.add(interaction);\r\n  exports.__interactionsRef.current = interactions;\r\n\r\n  var subscriber = exports.__subscriberRef.current;\r\n  var returnValue = void 0;\r\n\r\n  try {\r\n    if (subscriber !== null) {\r\n      subscriber.onInteractionTraced(interaction);\r\n    }\r\n  } finally {\r\n    try {\r\n      if (subscriber !== null) {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      }\r\n    } finally {\r\n      try {\r\n        returnValue = callback();\r\n      } finally {\r\n        exports.__interactionsRef.current = prevInteractions;\r\n\r\n        try {\r\n          if (subscriber !== null) {\r\n            subscriber.onWorkStopped(interactions, threadID);\r\n          }\r\n        } finally {\r\n          interaction.__count--;\r\n\r\n          // If no async work was scheduled for this interaction,\r\n          // Notify subscribers that it's completed.\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return returnValue;\r\n}\r\n\r\nfunction unstable_wrap(callback) {\r\n  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\r\n\r\n  if (!enableSchedulerTracing) {\r\n    return callback;\r\n  }\r\n\r\n  var wrappedInteractions = exports.__interactionsRef.current;\r\n\r\n  var subscriber = exports.__subscriberRef.current;\r\n  if (subscriber !== null) {\r\n    subscriber.onWorkScheduled(wrappedInteractions, threadID);\r\n  }\r\n\r\n  // Update the pending async work count for the current interactions.\r\n  // Update after calling subscribers in case of error.\r\n  wrappedInteractions.forEach(function (interaction) {\r\n    interaction.__count++;\r\n  });\r\n\r\n  var hasRun = false;\r\n\r\n  function wrapped() {\r\n    var prevInteractions = exports.__interactionsRef.current;\r\n    exports.__interactionsRef.current = wrappedInteractions;\r\n\r\n    subscriber = exports.__subscriberRef.current;\r\n\r\n    try {\r\n      var returnValue = void 0;\r\n\r\n      try {\r\n        if (subscriber !== null) {\r\n          subscriber.onWorkStarted(wrappedInteractions, threadID);\r\n        }\r\n      } finally {\r\n        try {\r\n          returnValue = callback.apply(undefined, arguments);\r\n        } finally {\r\n          exports.__interactionsRef.current = prevInteractions;\r\n\r\n          if (subscriber !== null) {\r\n            subscriber.onWorkStopped(wrappedInteractions, threadID);\r\n          }\r\n        }\r\n      }\r\n\r\n      return returnValue;\r\n    } finally {\r\n      if (!hasRun) {\r\n        // We only expect a wrapped function to be executed once,\r\n        // But in the event that it's executed more than onceâ€“\r\n        // Only decrement the outstanding interaction counts once.\r\n        hasRun = true;\r\n\r\n        // Update pending async counts for all wrapped interactions.\r\n        // If this was the last scheduled async work for any of them,\r\n        // Mark them as completed.\r\n        wrappedInteractions.forEach(function (interaction) {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  wrapped.cancel = function cancel() {\r\n    subscriber = exports.__subscriberRef.current;\r\n\r\n    try {\r\n      if (subscriber !== null) {\r\n        subscriber.onWorkCanceled(wrappedInteractions, threadID);\r\n      }\r\n    } finally {\r\n      // Update pending async counts for all wrapped interactions.\r\n      // If this was the last scheduled async work for any of them,\r\n      // Mark them as completed.\r\n      wrappedInteractions.forEach(function (interaction) {\r\n        interaction.__count--;\r\n\r\n        if (subscriber && interaction.__count === 0) {\r\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  return wrapped;\r\n}\r\n\r\nvar subscribers = null;\r\nif (enableSchedulerTracing) {\r\n  subscribers = new Set();\r\n}\r\n\r\nfunction unstable_subscribe(subscriber) {\r\n  if (enableSchedulerTracing) {\r\n    subscribers.add(subscriber);\r\n\r\n    if (subscribers.size === 1) {\r\n      exports.__subscriberRef.current = {\r\n        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\r\n        onInteractionTraced: onInteractionTraced,\r\n        onWorkCanceled: onWorkCanceled,\r\n        onWorkScheduled: onWorkScheduled,\r\n        onWorkStarted: onWorkStarted,\r\n        onWorkStopped: onWorkStopped\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nfunction unstable_unsubscribe(subscriber) {\r\n  if (enableSchedulerTracing) {\r\n    subscribers.delete(subscriber);\r\n\r\n    if (subscribers.size === 0) {\r\n      exports.__subscriberRef.current = null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction onInteractionTraced(interaction) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onInteractionTraced(interaction);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onInteractionScheduledWorkCompleted(interaction) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onWorkScheduled(interactions, threadID) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onWorkStarted(interactions, threadID) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onWorkStarted(interactions, threadID);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onWorkStopped(interactions, threadID) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onWorkStopped(interactions, threadID);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onWorkCanceled(interactions, threadID) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onWorkCanceled(interactions, threadID);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nexports.unstable_clear = unstable_clear;\r\nexports.unstable_getCurrent = unstable_getCurrent;\r\nexports.unstable_getThreadID = unstable_getThreadID;\r\nexports.unstable_trace = unstable_trace;\r\nexports.unstable_wrap = unstable_wrap;\r\nexports.unstable_subscribe = unstable_subscribe;\r\nexports.unstable_unsubscribe = unstable_unsubscribe;\r\n  })();\r\n}\r\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["unstable_subscribe","__interactionsRef","unstable_unsubscribe","cancel","__esModule","onWorkStopped","onWorkStarted","id","timestamp","unstable_wrap","__subscriberRef","onWorkCanceled","name","value","onInteractionScheduledWorkCompleted","unstable_getCurrent","current","onInteractionTraced","unstable_trace","unstable_clear","onWorkScheduled","unstable_getThreadID","__count"]],"~:compiled-at",1579687540717,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$scheduler$cjs$scheduler_tracing_development.js\",\n\"lineCount\":10,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/scheduler/cjs/scheduler-tracing.development.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$scheduler$cjs$scheduler_tracing_development\\\"] = function(global,require,module,exports) {\\n/** @license React v0.15.0\\r\\n * scheduler-tracing.development.js\\r\\n *\\r\\n * Copyright (c) Facebook, Inc. and its affiliates.\\r\\n *\\r\\n * This source code is licensed under the MIT license found in the\\r\\n * LICENSE file in the root directory of this source tree.\\r\\n */\\r\\n\\r\\n'use strict';\\r\\n\\r\\n\\r\\n\\r\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\r\\n  (function() {\\r\\n'use strict';\\r\\n\\r\\nObject.defineProperty(exports, '__esModule', { value: true });\\r\\n\\r\\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\\r\\n\\r\\n\\r\\n// In some cases, StrictMode should also double-render lifecycles.\\r\\n// This can be confusing for tests though,\\r\\n// And it can be bad for performance in production.\\r\\n// This feature flag can be used to control the behavior:\\r\\n\\r\\n\\r\\n// To preserve the \\\"Pause on caught exceptions\\\" behavior of the debugger, we\\r\\n// replay the begin phase of a failed component inside invokeGuardedCallback.\\r\\n\\r\\n\\r\\n// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\\r\\n\\r\\n\\r\\n// Gather advanced timing metrics for Profiler subtrees.\\r\\n\\r\\n\\r\\n// Trace which interactions trigger each commit.\\r\\nvar enableSchedulerTracing = true;\\r\\n\\r\\n// Only used in www builds.\\r\\n // TODO: true? Here it might just be false.\\r\\n\\r\\n// Only used in www builds.\\r\\n\\r\\n\\r\\n// Only used in www builds.\\r\\n\\r\\n\\r\\n// Disable javascript: URL strings in href for XSS protection.\\r\\n\\r\\n\\r\\n// React Fire: prevent the value and checked attributes from syncing\\r\\n// with their related DOM properties\\r\\n\\r\\n\\r\\n// These APIs will no longer be \\\"unstable\\\" in the upcoming 16.7 release,\\r\\n// Control this behavior with a flag to support 16.6 minor releases in the meanwhile.\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n// See https://github.com/react-native-community/discussions-and-proposals/issues/72 for more information\\r\\n// This is a flag so we can fix warnings in RN core before turning it on\\r\\n\\r\\n\\r\\n// Experimental React Flare event system and event components support.\\r\\n\\r\\n\\r\\n// Experimental Host Component support.\\r\\n\\r\\n\\r\\n// New API for JSX transforms to target - https://github.com/reactjs/rfcs/pull/107\\r\\n\\r\\n\\r\\n// We will enforce mocking scheduler with scheduler/unstable_mock at some point. (v17?)\\r\\n// Till then, we warn about the missing mock, but still fallback to a sync mode compatible version\\r\\n\\r\\n// Temporary flag to revert the fix in #15650\\r\\n\\r\\n\\r\\n// For tests, we flush suspense fallbacks in an act scope;\\r\\n// *except* in some of our own tests, where we test incremental loading states.\\r\\n\\r\\n\\r\\n// Changes priority of some events like mousemove to user-blocking priority,\\r\\n// but without making them discrete. The flag exists in case it causes\\r\\n// starvation problems.\\r\\n\\r\\n\\r\\n// Add a callback property to suspense to notify which promises are currently\\r\\n// in the update queue. This allows reporting and tracing of what is causing\\r\\n// the user to see a loading state.\\r\\n\\r\\n\\r\\n// Part of the simplification of React.createElement so we can eventually move\\r\\n// from React.createElement to React.jsx\\r\\n// https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md\\r\\n\\r\\nvar DEFAULT_THREAD_ID = 0;\\r\\n\\r\\n// Counters used to generate unique IDs.\\r\\nvar interactionIDCounter = 0;\\r\\nvar threadIDCounter = 0;\\r\\n\\r\\n// Set of currently traced interactions.\\r\\n// Interactions \\\"stack\\\"\\u2013\\r\\n// Meaning that newly traced interactions are appended to the previously active set.\\r\\n// When an interaction goes out of scope, the previous set (if any) is restored.\\r\\nexports.__interactionsRef = null;\\r\\n\\r\\n// Listener(s) to notify when interactions begin and end.\\r\\nexports.__subscriberRef = null;\\r\\n\\r\\nif (enableSchedulerTracing) {\\r\\n  exports.__interactionsRef = {\\r\\n    current: new Set()\\r\\n  };\\r\\n  exports.__subscriberRef = {\\r\\n    current: null\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction unstable_clear(callback) {\\r\\n  if (!enableSchedulerTracing) {\\r\\n    return callback();\\r\\n  }\\r\\n\\r\\n  var prevInteractions = exports.__interactionsRef.current;\\r\\n  exports.__interactionsRef.current = new Set();\\r\\n\\r\\n  try {\\r\\n    return callback();\\r\\n  } finally {\\r\\n    exports.__interactionsRef.current = prevInteractions;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction unstable_getCurrent() {\\r\\n  if (!enableSchedulerTracing) {\\r\\n    return null;\\r\\n  } else {\\r\\n    return exports.__interactionsRef.current;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction unstable_getThreadID() {\\r\\n  return ++threadIDCounter;\\r\\n}\\r\\n\\r\\nfunction unstable_trace(name, timestamp, callback) {\\r\\n  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\\r\\n\\r\\n  if (!enableSchedulerTracing) {\\r\\n    return callback();\\r\\n  }\\r\\n\\r\\n  var interaction = {\\r\\n    __count: 1,\\r\\n    id: interactionIDCounter++,\\r\\n    name: name,\\r\\n    timestamp: timestamp\\r\\n  };\\r\\n\\r\\n  var prevInteractions = exports.__interactionsRef.current;\\r\\n\\r\\n  // Traced interactions should stack/accumulate.\\r\\n  // To do that, clone the current interactions.\\r\\n  // The previous set will be restored upon completion.\\r\\n  var interactions = new Set(prevInteractions);\\r\\n  interactions.add(interaction);\\r\\n  exports.__interactionsRef.current = interactions;\\r\\n\\r\\n  var subscriber = exports.__subscriberRef.current;\\r\\n  var returnValue = void 0;\\r\\n\\r\\n  try {\\r\\n    if (subscriber !== null) {\\r\\n      subscriber.onInteractionTraced(interaction);\\r\\n    }\\r\\n  } finally {\\r\\n    try {\\r\\n      if (subscriber !== null) {\\r\\n        subscriber.onWorkStarted(interactions, threadID);\\r\\n      }\\r\\n    } finally {\\r\\n      try {\\r\\n        returnValue = callback();\\r\\n      } finally {\\r\\n        exports.__interactionsRef.current = prevInteractions;\\r\\n\\r\\n        try {\\r\\n          if (subscriber !== null) {\\r\\n            subscriber.onWorkStopped(interactions, threadID);\\r\\n          }\\r\\n        } finally {\\r\\n          interaction.__count--;\\r\\n\\r\\n          // If no async work was scheduled for this interaction,\\r\\n          // Notify subscribers that it's completed.\\r\\n          if (subscriber !== null && interaction.__count === 0) {\\r\\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return returnValue;\\r\\n}\\r\\n\\r\\nfunction unstable_wrap(callback) {\\r\\n  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\\r\\n\\r\\n  if (!enableSchedulerTracing) {\\r\\n    return callback;\\r\\n  }\\r\\n\\r\\n  var wrappedInteractions = exports.__interactionsRef.current;\\r\\n\\r\\n  var subscriber = exports.__subscriberRef.current;\\r\\n  if (subscriber !== null) {\\r\\n    subscriber.onWorkScheduled(wrappedInteractions, threadID);\\r\\n  }\\r\\n\\r\\n  // Update the pending async work count for the current interactions.\\r\\n  // Update after calling subscribers in case of error.\\r\\n  wrappedInteractions.forEach(function (interaction) {\\r\\n    interaction.__count++;\\r\\n  });\\r\\n\\r\\n  var hasRun = false;\\r\\n\\r\\n  function wrapped() {\\r\\n    var prevInteractions = exports.__interactionsRef.current;\\r\\n    exports.__interactionsRef.current = wrappedInteractions;\\r\\n\\r\\n    subscriber = exports.__subscriberRef.current;\\r\\n\\r\\n    try {\\r\\n      var returnValue = void 0;\\r\\n\\r\\n      try {\\r\\n        if (subscriber !== null) {\\r\\n          subscriber.onWorkStarted(wrappedInteractions, threadID);\\r\\n        }\\r\\n      } finally {\\r\\n        try {\\r\\n          returnValue = callback.apply(undefined, arguments);\\r\\n        } finally {\\r\\n          exports.__interactionsRef.current = prevInteractions;\\r\\n\\r\\n          if (subscriber !== null) {\\r\\n            subscriber.onWorkStopped(wrappedInteractions, threadID);\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n\\r\\n      return returnValue;\\r\\n    } finally {\\r\\n      if (!hasRun) {\\r\\n        // We only expect a wrapped function to be executed once,\\r\\n        // But in the event that it's executed more than once\\u2013\\r\\n        // Only decrement the outstanding interaction counts once.\\r\\n        hasRun = true;\\r\\n\\r\\n        // Update pending async counts for all wrapped interactions.\\r\\n        // If this was the last scheduled async work for any of them,\\r\\n        // Mark them as completed.\\r\\n        wrappedInteractions.forEach(function (interaction) {\\r\\n          interaction.__count--;\\r\\n\\r\\n          if (subscriber !== null && interaction.__count === 0) {\\r\\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\\r\\n          }\\r\\n        });\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  wrapped.cancel = function cancel() {\\r\\n    subscriber = exports.__subscriberRef.current;\\r\\n\\r\\n    try {\\r\\n      if (subscriber !== null) {\\r\\n        subscriber.onWorkCanceled(wrappedInteractions, threadID);\\r\\n      }\\r\\n    } finally {\\r\\n      // Update pending async counts for all wrapped interactions.\\r\\n      // If this was the last scheduled async work for any of them,\\r\\n      // Mark them as completed.\\r\\n      wrappedInteractions.forEach(function (interaction) {\\r\\n        interaction.__count--;\\r\\n\\r\\n        if (subscriber && interaction.__count === 0) {\\r\\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\\r\\n        }\\r\\n      });\\r\\n    }\\r\\n  };\\r\\n\\r\\n  return wrapped;\\r\\n}\\r\\n\\r\\nvar subscribers = null;\\r\\nif (enableSchedulerTracing) {\\r\\n  subscribers = new Set();\\r\\n}\\r\\n\\r\\nfunction unstable_subscribe(subscriber) {\\r\\n  if (enableSchedulerTracing) {\\r\\n    subscribers.add(subscriber);\\r\\n\\r\\n    if (subscribers.size === 1) {\\r\\n      exports.__subscriberRef.current = {\\r\\n        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\\r\\n        onInteractionTraced: onInteractionTraced,\\r\\n        onWorkCanceled: onWorkCanceled,\\r\\n        onWorkScheduled: onWorkScheduled,\\r\\n        onWorkStarted: onWorkStarted,\\r\\n        onWorkStopped: onWorkStopped\\r\\n      };\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction unstable_unsubscribe(subscriber) {\\r\\n  if (enableSchedulerTracing) {\\r\\n    subscribers.delete(subscriber);\\r\\n\\r\\n    if (subscribers.size === 0) {\\r\\n      exports.__subscriberRef.current = null;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction onInteractionTraced(interaction) {\\r\\n  var didCatchError = false;\\r\\n  var caughtError = null;\\r\\n\\r\\n  subscribers.forEach(function (subscriber) {\\r\\n    try {\\r\\n      subscriber.onInteractionTraced(interaction);\\r\\n    } catch (error) {\\r\\n      if (!didCatchError) {\\r\\n        didCatchError = true;\\r\\n        caughtError = error;\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  if (didCatchError) {\\r\\n    throw caughtError;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction onInteractionScheduledWorkCompleted(interaction) {\\r\\n  var didCatchError = false;\\r\\n  var caughtError = null;\\r\\n\\r\\n  subscribers.forEach(function (subscriber) {\\r\\n    try {\\r\\n      subscriber.onInteractionScheduledWorkCompleted(interaction);\\r\\n    } catch (error) {\\r\\n      if (!didCatchError) {\\r\\n        didCatchError = true;\\r\\n        caughtError = error;\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  if (didCatchError) {\\r\\n    throw caughtError;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction onWorkScheduled(interactions, threadID) {\\r\\n  var didCatchError = false;\\r\\n  var caughtError = null;\\r\\n\\r\\n  subscribers.forEach(function (subscriber) {\\r\\n    try {\\r\\n      subscriber.onWorkScheduled(interactions, threadID);\\r\\n    } catch (error) {\\r\\n      if (!didCatchError) {\\r\\n        didCatchError = true;\\r\\n        caughtError = error;\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  if (didCatchError) {\\r\\n    throw caughtError;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction onWorkStarted(interactions, threadID) {\\r\\n  var didCatchError = false;\\r\\n  var caughtError = null;\\r\\n\\r\\n  subscribers.forEach(function (subscriber) {\\r\\n    try {\\r\\n      subscriber.onWorkStarted(interactions, threadID);\\r\\n    } catch (error) {\\r\\n      if (!didCatchError) {\\r\\n        didCatchError = true;\\r\\n        caughtError = error;\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  if (didCatchError) {\\r\\n    throw caughtError;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction onWorkStopped(interactions, threadID) {\\r\\n  var didCatchError = false;\\r\\n  var caughtError = null;\\r\\n\\r\\n  subscribers.forEach(function (subscriber) {\\r\\n    try {\\r\\n      subscriber.onWorkStopped(interactions, threadID);\\r\\n    } catch (error) {\\r\\n      if (!didCatchError) {\\r\\n        didCatchError = true;\\r\\n        caughtError = error;\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  if (didCatchError) {\\r\\n    throw caughtError;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction onWorkCanceled(interactions, threadID) {\\r\\n  var didCatchError = false;\\r\\n  var caughtError = null;\\r\\n\\r\\n  subscribers.forEach(function (subscriber) {\\r\\n    try {\\r\\n      subscriber.onWorkCanceled(interactions, threadID);\\r\\n    } catch (error) {\\r\\n      if (!didCatchError) {\\r\\n        didCatchError = true;\\r\\n        caughtError = error;\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  if (didCatchError) {\\r\\n    throw caughtError;\\r\\n  }\\r\\n}\\r\\n\\r\\nexports.unstable_clear = unstable_clear;\\r\\nexports.unstable_getCurrent = unstable_getCurrent;\\r\\nexports.unstable_getThreadID = unstable_getThreadID;\\r\\nexports.unstable_trace = unstable_trace;\\r\\nexports.unstable_wrap = unstable_wrap;\\r\\nexports.unstable_subscribe = unstable_subscribe;\\r\\nexports.unstable_unsubscribe = unstable_unsubscribe;\\r\\n  })();\\r\\n}\\r\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"onInteractionTraced\",\"interaction\",\"didCatchError\",\"caughtError\",\"subscribers\",\"forEach\",\"subscriber\",\"error\",\"onInteractionScheduledWorkCompleted\",\"onWorkScheduled\",\"interactions\",\"threadID\",\"onWorkStarted\",\"onWorkStopped\",\"onWorkCanceled\",\"Object\",\"defineProperty\",\"value\",\"interactionIDCounter\",\"threadIDCounter\",\"__interactionsRef\",\"__subscriberRef\",\"current\",\"Set\",\"unstable_clear\",\"callback\",\"prevInteractions\",\"unstable_getCurrent\",\"unstable_getThreadID\",\"unstable_trace\",\"name\",\"timestamp\",\"arguments\",\"length\",\"undefined\",\"DEFAULT_THREAD_ID\",\"__count\",\"id\",\"add\",\"returnValue\",\"unstable_wrap\",\"wrapped\",\"wrappedInteractions\",\"apply\",\"hasRun\",\"cancel\",\"wrapped.cancel\",\"unstable_subscribe\",\"size\",\"unstable_unsubscribe\",\"delete\"]\n}\n"]