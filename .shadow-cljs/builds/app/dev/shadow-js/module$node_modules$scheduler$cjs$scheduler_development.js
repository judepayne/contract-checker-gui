["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/scheduler/cjs/scheduler.development.js"],"~:js","shadow$provide.module$node_modules$scheduler$cjs$scheduler_development=function(global,require,module,exports){(function(){function flushTask(task,currentTime){var next=task.next;if(next===task)firstTask=null;else{task===firstTask&&(firstTask=next);var previous=task.previous;previous.next=next;next.previous=previous}task.next=task.previous=null;next=task.callback;previous=currentPriorityLevel;var previousTask=currentTask;currentPriorityLevel=task.priorityLevel;currentTask=task;try{var didUserCallbackTimeout=\ntask.expirationTime<=currentTime;switch(currentPriorityLevel){case 1:var continuationCallback=next(didUserCallbackTimeout);break;case 2:continuationCallback=next(didUserCallbackTimeout);break;case 3:continuationCallback=next(didUserCallbackTimeout);break;case 4:continuationCallback=next(didUserCallbackTimeout);break;case 5:continuationCallback=next(didUserCallbackTimeout)}}catch(error){throw error;}finally{currentPriorityLevel=previous,currentTask=previousTask}if(\"function\"===typeof continuationCallback)if(currentTime=\ntask.expirationTime,task.callback=continuationCallback,null===firstTask)firstTask=task.next=task.previous=task;else{continuationCallback=null;didUserCallbackTimeout=firstTask;do{if(currentTime<=didUserCallbackTimeout.expirationTime){continuationCallback=didUserCallbackTimeout;break}didUserCallbackTimeout=didUserCallbackTimeout.next}while(didUserCallbackTimeout!==firstTask);null===continuationCallback?continuationCallback=firstTask:continuationCallback===firstTask&&(firstTask=task);currentTime=continuationCallback.previous;\ncurrentTime.next=continuationCallback.previous=task;task.next=continuationCallback;task.previous=currentTime}}function advanceTimers(currentTime){if(null!==firstDelayedTask&&firstDelayedTask.startTime<=currentTime){do{var task=firstDelayedTask,next=task.next;if(task===next)firstDelayedTask=null;else{firstDelayedTask=next;var previous=task.previous;previous.next=next;next.previous=previous}task.next=task.previous=null;insertScheduledTask(task,task.expirationTime)}while(null!==firstDelayedTask&&firstDelayedTask.startTime<=\ncurrentTime)}}function handleTimeout(currentTime){isHostTimeoutScheduled=!1;advanceTimers(currentTime);isHostCallbackScheduled||(null!==firstTask?(isHostCallbackScheduled=!0,requestHostCallback(flushWork)):null!==firstDelayedTask&&requestHostTimeout(handleTimeout,firstDelayedTask.startTime-currentTime))}function flushWork(hasTimeRemaining,initialTime){isHostCallbackScheduled=!1;isHostTimeoutScheduled&&(isHostTimeoutScheduled=!1,cancelHostTimeout());advanceTimers(initialTime);isPerformingWork=!0;try{if(!hasTimeRemaining)for(;null!==\nfirstTask&&firstTask.expirationTime<=initialTime;)flushTask(firstTask,initialTime),initialTime=exports.unstable_now(),advanceTimers(initialTime);else if(null!==firstTask){do flushTask(firstTask,initialTime),initialTime=exports.unstable_now(),advanceTimers(initialTime);while(null!==firstTask&&!shouldYieldToHost())}if(null!==firstTask)return!0;null!==firstDelayedTask&&requestHostTimeout(handleTimeout,firstDelayedTask.startTime-initialTime);return!1}finally{isPerformingWork=!1}}function timeoutForPriorityLevel(priorityLevel){switch(priorityLevel){case 1:return-1;\ncase 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}function insertScheduledTask(newTask,expirationTime){if(null===firstTask)firstTask=newTask.next=newTask.previous=newTask;else{var next=null,task=firstTask;do{if(expirationTime<task.expirationTime){next=task;break}task=task.next}while(task!==firstTask);null===next?next=firstTask:next===firstTask&&(firstTask=newTask);expirationTime=next.previous;expirationTime.next=next.previous=newTask;newTask.next=next;newTask.previous=\nexpirationTime}}Object.defineProperty(exports,\"__esModule\",{value:!0});var requestHostCallback=void 0,requestHostTimeout=void 0,cancelHostTimeout=void 0,shouldYieldToHost=void 0,requestPaint=void 0;exports.unstable_now=void 0;exports.unstable_forceFrameRate=void 0;if(\"undefined\"===typeof window||\"function\"!==typeof MessageChannel){var _callback=null,_timeoutID=null,_flushCallback=function(){if(null!==_callback)try{var currentTime=exports.unstable_now();_callback(!0,currentTime);_callback=null}catch(e){throw setTimeout(_flushCallback,\n0),e;}};exports.unstable_now=function(){return Date.now()};requestHostCallback=function(cb){null!==_callback?setTimeout(requestHostCallback,0,cb):(_callback=cb,setTimeout(_flushCallback,0))};requestHostTimeout=function(cb,ms){_timeoutID=setTimeout(cb,ms)};cancelHostTimeout=function(){clearTimeout(_timeoutID)};shouldYieldToHost=function(){return!1};requestPaint=exports.unstable_forceFrameRate=function(){}}else{var performance=window.performance,_Date=window.Date,_setTimeout=window.setTimeout,_clearTimeout=\nwindow.clearTimeout,requestAnimationFrame=window.requestAnimationFrame;requestPaint=window.cancelAnimationFrame;\"undefined\"!==typeof console&&(\"function\"!==typeof requestAnimationFrame&&console.error(\"This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills\"),\"function\"!==typeof requestPaint&&console.error(\"This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills\"));\nexports.unstable_now=\"object\"===typeof performance&&\"function\"===typeof performance.now?function(){return performance.now()}:function(){return _Date.now()};var isRAFLoopRunning=!1,scheduledHostCallback=null,rAFTimeoutID=-1,taskTimeoutID=-1,frameLength=33.33,prevRAFTime=-1,prevRAFInterval=-1,frameDeadline=0,fpsLocked=!1;shouldYieldToHost=function(){return exports.unstable_now()>=frameDeadline};requestPaint=function(){};exports.unstable_forceFrameRate=function(fps){0>fps||125<fps?console.error(\"forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported\"):\n0<fps?(frameLength=Math.floor(1E3/fps),fpsLocked=!0):(frameLength=33.33,fpsLocked=!1)};var performWorkUntilDeadline=function(){if(null!==scheduledHostCallback){var _currentTime=exports.unstable_now(),_hasTimeRemaining=0<frameDeadline-_currentTime;try{scheduledHostCallback(_hasTimeRemaining,_currentTime)||(scheduledHostCallback=null)}catch(error$0){throw port.postMessage(null),error$0;}}},channel=new MessageChannel,port=channel.port2;channel.port1.onmessage=performWorkUntilDeadline;var onAnimationFrame=\nfunction(rAFTime){if(null===scheduledHostCallback)prevRAFInterval=prevRAFTime=-1,isRAFLoopRunning=!1;else{isRAFLoopRunning=!0;requestAnimationFrame(function(nextRAFTime){_clearTimeout(rAFTimeoutID);onAnimationFrame(nextRAFTime)});var onTimeout=function(){frameDeadline=exports.unstable_now()+frameLength/2;performWorkUntilDeadline();rAFTimeoutID=_setTimeout(onTimeout,3*frameLength)};rAFTimeoutID=_setTimeout(onTimeout,3*frameLength);if(-1!==prevRAFTime&&.1<rAFTime-prevRAFTime){var rAFInterval=rAFTime-\nprevRAFTime;!fpsLocked&&-1!==prevRAFInterval&&rAFInterval<frameLength&&prevRAFInterval<frameLength&&(frameLength=rAFInterval<prevRAFInterval?prevRAFInterval:rAFInterval,8.33>frameLength&&(frameLength=8.33));prevRAFInterval=rAFInterval}prevRAFTime=rAFTime;frameDeadline=rAFTime+frameLength;port.postMessage(null)}};requestHostCallback=function(callback){scheduledHostCallback=callback;isRAFLoopRunning||(isRAFLoopRunning=!0,requestAnimationFrame(function(rAFTime){onAnimationFrame(rAFTime)}))};requestHostTimeout=\nfunction(callback,ms){taskTimeoutID=_setTimeout(function(){callback(exports.unstable_now())},ms)};cancelHostTimeout=function(){_clearTimeout(taskTimeoutID);taskTimeoutID=-1}}var firstTask=null,firstDelayedTask=null,currentTask=null,currentPriorityLevel=3,isPerformingWork=!1,isHostCallbackScheduled=!1,isHostTimeoutScheduled=!1;exports.unstable_ImmediatePriority=1;exports.unstable_UserBlockingPriority=2;exports.unstable_NormalPriority=3;exports.unstable_IdlePriority=5;exports.unstable_LowPriority=4;\nexports.unstable_runWithPriority=function(priorityLevel,eventHandler){switch(priorityLevel){case 1:case 2:case 3:case 4:case 5:break;default:priorityLevel=3}var previousPriorityLevel=currentPriorityLevel;currentPriorityLevel=priorityLevel;try{return eventHandler()}finally{currentPriorityLevel=previousPriorityLevel}};exports.unstable_next=function(eventHandler){switch(currentPriorityLevel){case 1:case 2:case 3:var priorityLevel=3;break;default:priorityLevel=currentPriorityLevel}var previousPriorityLevel=\ncurrentPriorityLevel;currentPriorityLevel=priorityLevel;try{return eventHandler()}finally{currentPriorityLevel=previousPriorityLevel}};exports.unstable_scheduleCallback=function(priorityLevel,callback,options){var currentTime=exports.unstable_now();if(\"object\"===typeof options&&null!==options){var startTime=options.delay;startTime=\"number\"===typeof startTime&&0<startTime?currentTime+startTime:currentTime;options=\"number\"===typeof options.timeout?options.timeout:timeoutForPriorityLevel(priorityLevel)}else options=\ntimeoutForPriorityLevel(priorityLevel),startTime=currentTime;options=startTime+options;priorityLevel={callback:callback,priorityLevel:priorityLevel,startTime:startTime,expirationTime:options,next:null,previous:null};if(startTime>currentTime){options=startTime;if(null===firstDelayedTask)firstDelayedTask=priorityLevel.next=priorityLevel.previous=priorityLevel;else{callback=null;var task=firstDelayedTask;do{if(options<task.startTime){callback=task;break}task=task.next}while(task!==firstDelayedTask);\nnull===callback?callback=firstDelayedTask:callback===firstDelayedTask&&(firstDelayedTask=priorityLevel);options=callback.previous;options.next=callback.previous=priorityLevel;priorityLevel.next=callback;priorityLevel.previous=options}null===firstTask&&firstDelayedTask===priorityLevel&&(isHostTimeoutScheduled?cancelHostTimeout():isHostTimeoutScheduled=!0,requestHostTimeout(handleTimeout,startTime-currentTime))}else insertScheduledTask(priorityLevel,options),isHostCallbackScheduled||isPerformingWork||\n(isHostCallbackScheduled=!0,requestHostCallback(flushWork));return priorityLevel};exports.unstable_cancelCallback=function(task){var next=task.next;if(null!==next){if(task===next)task===firstTask?firstTask=null:task===firstDelayedTask&&(firstDelayedTask=null);else{task===firstTask?firstTask=next:task===firstDelayedTask&&(firstDelayedTask=next);var previous=task.previous;previous.next=next;next.previous=previous}task.next=task.previous=null}};exports.unstable_wrapCallback=function(callback){var parentPriorityLevel=\ncurrentPriorityLevel;return function(){var previousPriorityLevel=currentPriorityLevel;currentPriorityLevel=parentPriorityLevel;try{return callback.apply(this,arguments)}finally{currentPriorityLevel=previousPriorityLevel}}};exports.unstable_getCurrentPriorityLevel=function(){return currentPriorityLevel};exports.unstable_shouldYield=function(){var currentTime=exports.unstable_now();advanceTimers(currentTime);return null!==currentTask&&null!==firstTask&&firstTask.startTime<=currentTime&&firstTask.expirationTime<\ncurrentTask.expirationTime||shouldYieldToHost()};exports.unstable_requestPaint=requestPaint;exports.unstable_continueExecution=function(){isHostCallbackScheduled||isPerformingWork||(isHostCallbackScheduled=!0,requestHostCallback(flushWork))};exports.unstable_pauseExecution=function(){};exports.unstable_getFirstCallbackNode=function(){return firstTask}})()}","~:source","shadow$provide[\"module$node_modules$scheduler$cjs$scheduler_development\"] = function(global,require,module,exports) {\n/** @license React v0.15.0\r\n * scheduler.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n'use strict';\r\n\r\n\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  (function() {\r\n'use strict';\r\n\r\nObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\nvar enableSchedulerDebugging = false;\r\nvar enableIsInputPending = false;\r\nvar requestIdleCallbackBeforeFirstFrame = false;\r\nvar requestTimerEventBeforeFirstFrame = false;\r\nvar enableMessageLoopImplementation = false;\r\n\r\n// The DOM Scheduler implementation is similar to requestIdleCallback. It\r\n// works by scheduling a requestAnimationFrame, storing the time for the start\r\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\r\n// Within the postMessage handler do as much work as possible until time + frame\r\n// rate. By separating the idle call into a separate event tick we ensure that\r\n// layout, paint and other browser work is counted against the available time.\r\n// The frame rate is dynamically adjusted.\r\n\r\nvar requestHostCallback = void 0;\r\n\r\nvar requestHostTimeout = void 0;\r\nvar cancelHostTimeout = void 0;\r\nvar shouldYieldToHost = void 0;\r\nvar requestPaint = void 0;\r\nexports.unstable_now = void 0;\r\nexports.unstable_forceFrameRate = void 0;\r\n\r\nif (\r\n// If Scheduler runs in a non-DOM environment, it falls back to a naive\r\n// implementation using setTimeout.\r\ntypeof window === 'undefined' ||\r\n// Check if MessageChannel is supported, too.\r\ntypeof MessageChannel !== 'function') {\r\n  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\r\n  // fallback to a naive implementation.\r\n  var _callback = null;\r\n  var _timeoutID = null;\r\n  var _flushCallback = function () {\r\n    if (_callback !== null) {\r\n      try {\r\n        var currentTime = exports.unstable_now();\r\n        var hasRemainingTime = true;\r\n        _callback(hasRemainingTime, currentTime);\r\n        _callback = null;\r\n      } catch (e) {\r\n        setTimeout(_flushCallback, 0);\r\n        throw e;\r\n      }\r\n    }\r\n  };\r\n  exports.unstable_now = function () {\r\n    return Date.now();\r\n  };\r\n  requestHostCallback = function (cb) {\r\n    if (_callback !== null) {\r\n      // Protect against re-entrancy.\r\n      setTimeout(requestHostCallback, 0, cb);\r\n    } else {\r\n      _callback = cb;\r\n      setTimeout(_flushCallback, 0);\r\n    }\r\n  };\r\n  requestHostTimeout = function (cb, ms) {\r\n    _timeoutID = setTimeout(cb, ms);\r\n  };\r\n  cancelHostTimeout = function () {\r\n    clearTimeout(_timeoutID);\r\n  };\r\n  shouldYieldToHost = function () {\r\n    return false;\r\n  };\r\n  requestPaint = exports.unstable_forceFrameRate = function () {};\r\n} else {\r\n  // Capture local references to native APIs, in case a polyfill overrides them.\r\n  var performance = window.performance;\r\n  var _Date = window.Date;\r\n  var _setTimeout = window.setTimeout;\r\n  var _clearTimeout = window.clearTimeout;\r\n  var requestAnimationFrame = window.requestAnimationFrame;\r\n  var cancelAnimationFrame = window.cancelAnimationFrame;\r\n  var requestIdleCallback = window.requestIdleCallback;\r\n\r\n  if (typeof console !== 'undefined') {\r\n    // TODO: Remove fb.me link\r\n    if (typeof requestAnimationFrame !== 'function') {\r\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\r\n    }\r\n    if (typeof cancelAnimationFrame !== 'function') {\r\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\r\n    }\r\n  }\r\n\r\n  var requestIdleCallbackBeforeFirstFrame$1 = requestIdleCallbackBeforeFirstFrame && typeof requestIdleCallback === 'function' && typeof cancelIdleCallback === 'function';\r\n\r\n  exports.unstable_now = typeof performance === 'object' && typeof performance.now === 'function' ? function () {\r\n    return performance.now();\r\n  } : function () {\r\n    return _Date.now();\r\n  };\r\n\r\n  var isRAFLoopRunning = false;\r\n  var isMessageLoopRunning = false;\r\n  var scheduledHostCallback = null;\r\n  var rAFTimeoutID = -1;\r\n  var taskTimeoutID = -1;\r\n\r\n  var frameLength = enableMessageLoopImplementation ? // We won't attempt to align with the vsync. Instead we'll yield multiple\r\n  // times per frame, often enough to keep it responsive even at really\r\n  // high frame rates > 120.\r\n  5 : // Use a heuristic to measure the frame rate and yield at the end of the\r\n  // frame. We start out assuming that we run at 30fps but then the\r\n  // heuristic tracking will adjust this value to a faster fps if we get\r\n  // more frequent animation frames.\r\n  33.33;\r\n\r\n  var prevRAFTime = -1;\r\n  var prevRAFInterval = -1;\r\n  var frameDeadline = 0;\r\n\r\n  var fpsLocked = false;\r\n\r\n  // TODO: Make this configurable\r\n  // TODO: Adjust this based on priority?\r\n  var maxFrameLength = 300;\r\n  var needsPaint = false;\r\n\r\n  if (enableIsInputPending && navigator !== undefined && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined) {\r\n    var scheduling = navigator.scheduling;\r\n    shouldYieldToHost = function () {\r\n      var currentTime = exports.unstable_now();\r\n      if (currentTime >= frameDeadline) {\r\n        // There's no time left in the frame. We may want to yield control of\r\n        // the main thread, so the browser can perform high priority tasks. The\r\n        // main ones are painting and user input. If there's a pending paint or\r\n        // a pending input, then we should yield. But if there's neither, then\r\n        // we can yield less often while remaining responsive. We'll eventually\r\n        // yield regardless, since there could be a pending paint that wasn't\r\n        // accompanied by a call to `requestPaint`, or other main thread tasks\r\n        // like network events.\r\n        if (needsPaint || scheduling.isInputPending()) {\r\n          // There is either a pending paint or a pending input.\r\n          return true;\r\n        }\r\n        // There's no pending input. Only yield if we've reached the max\r\n        // frame length.\r\n        return currentTime >= frameDeadline + maxFrameLength;\r\n      } else {\r\n        // There's still time left in the frame.\r\n        return false;\r\n      }\r\n    };\r\n\r\n    requestPaint = function () {\r\n      needsPaint = true;\r\n    };\r\n  } else {\r\n    // `isInputPending` is not available. Since we have no way of knowing if\r\n    // there's pending input, always yield at the end of the frame.\r\n    shouldYieldToHost = function () {\r\n      return exports.unstable_now() >= frameDeadline;\r\n    };\r\n\r\n    // Since we yield every frame regardless, `requestPaint` has no effect.\r\n    requestPaint = function () {};\r\n  }\r\n\r\n  exports.unstable_forceFrameRate = function (fps) {\r\n    if (fps < 0 || fps > 125) {\r\n      console.error('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing framerates higher than 125 fps is not unsupported');\r\n      return;\r\n    }\r\n    if (fps > 0) {\r\n      frameLength = Math.floor(1000 / fps);\r\n      fpsLocked = true;\r\n    } else {\r\n      // reset the framerate\r\n      frameLength = 33.33;\r\n      fpsLocked = false;\r\n    }\r\n  };\r\n\r\n  var performWorkUntilDeadline = function () {\r\n    if (enableMessageLoopImplementation) {\r\n      if (scheduledHostCallback !== null) {\r\n        var currentTime = exports.unstable_now();\r\n        // Yield after `frameLength` ms, regardless of where we are in the vsync\r\n        // cycle. This means there's always time remaining at the beginning of\r\n        // the message event.\r\n        frameDeadline = currentTime + frameLength;\r\n        var hasTimeRemaining = true;\r\n        try {\r\n          var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\r\n          if (!hasMoreWork) {\r\n            isMessageLoopRunning = false;\r\n            scheduledHostCallback = null;\r\n          } else {\r\n            // If there's more work, schedule the next message event at the end\r\n            // of the preceding one.\r\n            port.postMessage(null);\r\n          }\r\n        } catch (error) {\r\n          // If a scheduler task throws, exit the current browser task so the\r\n          // error can be observed.\r\n          port.postMessage(null);\r\n          throw error;\r\n        }\r\n      }\r\n      // Yielding to the browser will give it a chance to paint, so we can\r\n      // reset this.\r\n      needsPaint = false;\r\n    } else {\r\n      if (scheduledHostCallback !== null) {\r\n        var _currentTime = exports.unstable_now();\r\n        var _hasTimeRemaining = frameDeadline - _currentTime > 0;\r\n        try {\r\n          var _hasMoreWork = scheduledHostCallback(_hasTimeRemaining, _currentTime);\r\n          if (!_hasMoreWork) {\r\n            scheduledHostCallback = null;\r\n          }\r\n        } catch (error) {\r\n          // If a scheduler task throws, exit the current browser task so the\r\n          // error can be observed, and post a new task as soon as possible\r\n          // so we can continue where we left off.\r\n          port.postMessage(null);\r\n          throw error;\r\n        }\r\n      }\r\n      // Yielding to the browser will give it a chance to paint, so we can\r\n      // reset this.\r\n      needsPaint = false;\r\n    }\r\n  };\r\n\r\n  var channel = new MessageChannel();\r\n  var port = channel.port2;\r\n  channel.port1.onmessage = performWorkUntilDeadline;\r\n\r\n  var onAnimationFrame = function (rAFTime) {\r\n    if (scheduledHostCallback === null) {\r\n      // No scheduled work. Exit.\r\n      prevRAFTime = -1;\r\n      prevRAFInterval = -1;\r\n      isRAFLoopRunning = false;\r\n      return;\r\n    }\r\n\r\n    // Eagerly schedule the next animation callback at the beginning of the\r\n    // frame. If the scheduler queue is not empty at the end of the frame, it\r\n    // will continue flushing inside that callback. If the queue *is* empty,\r\n    // then it will exit immediately. Posting the callback at the start of the\r\n    // frame ensures it's fired within the earliest possible frame. If we\r\n    // waited until the end of the frame to post the callback, we risk the\r\n    // browser skipping a frame and not firing the callback until the frame\r\n    // after that.\r\n    isRAFLoopRunning = true;\r\n    requestAnimationFrame(function (nextRAFTime) {\r\n      _clearTimeout(rAFTimeoutID);\r\n      onAnimationFrame(nextRAFTime);\r\n    });\r\n\r\n    // requestAnimationFrame is throttled when the tab is backgrounded. We\r\n    // don't want to stop working entirely. So we'll fallback to a timeout loop.\r\n    // TODO: Need a better heuristic for backgrounded work.\r\n    var onTimeout = function () {\r\n      frameDeadline = exports.unstable_now() + frameLength / 2;\r\n      performWorkUntilDeadline();\r\n      rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);\r\n    };\r\n    rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);\r\n\r\n    if (prevRAFTime !== -1 &&\r\n    // Make sure this rAF time is different from the previous one. This check\r\n    // could fail if two rAFs fire in the same frame.\r\n    rAFTime - prevRAFTime > 0.1) {\r\n      var rAFInterval = rAFTime - prevRAFTime;\r\n      if (!fpsLocked && prevRAFInterval !== -1) {\r\n        // We've observed two consecutive frame intervals. We'll use this to\r\n        // dynamically adjust the frame rate.\r\n        //\r\n        // If one frame goes long, then the next one can be short to catch up.\r\n        // If two frames are short in a row, then that's an indication that we\r\n        // actually have a higher frame rate than what we're currently\r\n        // optimizing. For example, if we're running on 120hz display or 90hz VR\r\n        // display. Take the max of the two in case one of them was an anomaly\r\n        // due to missed frame deadlines.\r\n        if (rAFInterval < frameLength && prevRAFInterval < frameLength) {\r\n          frameLength = rAFInterval < prevRAFInterval ? prevRAFInterval : rAFInterval;\r\n          if (frameLength < 8.33) {\r\n            // Defensive coding. We don't support higher frame rates than 120hz.\r\n            // If the calculated frame length gets lower than 8, it is probably\r\n            // a bug.\r\n            frameLength = 8.33;\r\n          }\r\n        }\r\n      }\r\n      prevRAFInterval = rAFInterval;\r\n    }\r\n    prevRAFTime = rAFTime;\r\n    frameDeadline = rAFTime + frameLength;\r\n\r\n    // We use the postMessage trick to defer idle work until after the repaint.\r\n    port.postMessage(null);\r\n  };\r\n\r\n  requestHostCallback = function (callback) {\r\n    scheduledHostCallback = callback;\r\n    if (enableMessageLoopImplementation) {\r\n      if (!isMessageLoopRunning) {\r\n        isMessageLoopRunning = true;\r\n        port.postMessage(null);\r\n      }\r\n    } else {\r\n      if (!isRAFLoopRunning) {\r\n        // Start a rAF loop.\r\n        isRAFLoopRunning = true;\r\n        requestAnimationFrame(function (rAFTime) {\r\n          if (requestIdleCallbackBeforeFirstFrame$1) {\r\n            cancelIdleCallback(idleCallbackID);\r\n          }\r\n          if (requestTimerEventBeforeFirstFrame) {\r\n            _clearTimeout(idleTimeoutID);\r\n          }\r\n          onAnimationFrame(rAFTime);\r\n        });\r\n\r\n        // If we just missed the last vsync, the next rAF might not happen for\r\n        // another frame. To claim as much idle time as possible, post a\r\n        // callback with `requestIdleCallback`, which should fire if there's\r\n        // idle time left in the frame.\r\n        //\r\n        // This should only be an issue for the first rAF in the loop;\r\n        // subsequent rAFs are scheduled at the beginning of the\r\n        // preceding frame.\r\n        var idleCallbackID = void 0;\r\n        if (requestIdleCallbackBeforeFirstFrame$1) {\r\n          idleCallbackID = requestIdleCallback(function onIdleCallbackBeforeFirstFrame() {\r\n            if (requestTimerEventBeforeFirstFrame) {\r\n              _clearTimeout(idleTimeoutID);\r\n            }\r\n            frameDeadline = exports.unstable_now() + frameLength;\r\n            performWorkUntilDeadline();\r\n          });\r\n        }\r\n        // Alternate strategy to address the same problem. Scheduler a timer\r\n        // with no delay. If this fires before the rAF, that likely indicates\r\n        // that there's idle time before the next vsync. This isn't always the\r\n        // case, but we'll be aggressive and assume it is, as a trade off to\r\n        // prevent idle periods.\r\n        var idleTimeoutID = void 0;\r\n        if (requestTimerEventBeforeFirstFrame) {\r\n          idleTimeoutID = _setTimeout(function onTimerEventBeforeFirstFrame() {\r\n            if (requestIdleCallbackBeforeFirstFrame$1) {\r\n              cancelIdleCallback(idleCallbackID);\r\n            }\r\n            frameDeadline = exports.unstable_now() + frameLength;\r\n            performWorkUntilDeadline();\r\n          }, 0);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  requestHostTimeout = function (callback, ms) {\r\n    taskTimeoutID = _setTimeout(function () {\r\n      callback(exports.unstable_now());\r\n    }, ms);\r\n  };\r\n\r\n  cancelHostTimeout = function () {\r\n    _clearTimeout(taskTimeoutID);\r\n    taskTimeoutID = -1;\r\n  };\r\n}\r\n\r\n/* eslint-disable no-var */\r\n\r\n// TODO: Use symbols?\r\nvar ImmediatePriority = 1;\r\nvar UserBlockingPriority = 2;\r\nvar NormalPriority = 3;\r\nvar LowPriority = 4;\r\nvar IdlePriority = 5;\r\n\r\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\r\n// Math.pow(2, 30) - 1\r\n// 0b111111111111111111111111111111\r\nvar maxSigned31BitInt = 1073741823;\r\n\r\n// Times out immediately\r\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\r\n// Eventually times out\r\nvar USER_BLOCKING_PRIORITY = 250;\r\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\r\nvar LOW_PRIORITY_TIMEOUT = 10000;\r\n// Never times out\r\nvar IDLE_PRIORITY = maxSigned31BitInt;\r\n\r\n// Tasks are stored as a circular, doubly linked list.\r\nvar firstTask = null;\r\nvar firstDelayedTask = null;\r\n\r\n// Pausing the scheduler is useful for debugging.\r\nvar isSchedulerPaused = false;\r\n\r\nvar currentTask = null;\r\nvar currentPriorityLevel = NormalPriority;\r\n\r\n// This is set while performing work, to prevent re-entrancy.\r\nvar isPerformingWork = false;\r\n\r\nvar isHostCallbackScheduled = false;\r\nvar isHostTimeoutScheduled = false;\r\n\r\nfunction scheduler_flushTaskAtPriority_Immediate(callback, didTimeout) {\r\n  return callback(didTimeout);\r\n}\r\nfunction scheduler_flushTaskAtPriority_UserBlocking(callback, didTimeout) {\r\n  return callback(didTimeout);\r\n}\r\nfunction scheduler_flushTaskAtPriority_Normal(callback, didTimeout) {\r\n  return callback(didTimeout);\r\n}\r\nfunction scheduler_flushTaskAtPriority_Low(callback, didTimeout) {\r\n  return callback(didTimeout);\r\n}\r\nfunction scheduler_flushTaskAtPriority_Idle(callback, didTimeout) {\r\n  return callback(didTimeout);\r\n}\r\n\r\nfunction flushTask(task, currentTime) {\r\n  // Remove the task from the list before calling the callback. That way the\r\n  // list is in a consistent state even if the callback throws.\r\n  var next = task.next;\r\n  if (next === task) {\r\n    // This is the only scheduled task. Clear the list.\r\n    firstTask = null;\r\n  } else {\r\n    // Remove the task from its position in the list.\r\n    if (task === firstTask) {\r\n      firstTask = next;\r\n    }\r\n    var previous = task.previous;\r\n    previous.next = next;\r\n    next.previous = previous;\r\n  }\r\n  task.next = task.previous = null;\r\n\r\n  // Now it's safe to execute the task.\r\n  var callback = task.callback;\r\n  var previousPriorityLevel = currentPriorityLevel;\r\n  var previousTask = currentTask;\r\n  currentPriorityLevel = task.priorityLevel;\r\n  currentTask = task;\r\n  var continuationCallback;\r\n  try {\r\n    var didUserCallbackTimeout = task.expirationTime <= currentTime;\r\n    // Add an extra function to the callstack. Profiling tools can use this\r\n    // to infer the priority of work that appears higher in the stack.\r\n    switch (currentPriorityLevel) {\r\n      case ImmediatePriority:\r\n        continuationCallback = scheduler_flushTaskAtPriority_Immediate(callback, didUserCallbackTimeout);\r\n        break;\r\n      case UserBlockingPriority:\r\n        continuationCallback = scheduler_flushTaskAtPriority_UserBlocking(callback, didUserCallbackTimeout);\r\n        break;\r\n      case NormalPriority:\r\n        continuationCallback = scheduler_flushTaskAtPriority_Normal(callback, didUserCallbackTimeout);\r\n        break;\r\n      case LowPriority:\r\n        continuationCallback = scheduler_flushTaskAtPriority_Low(callback, didUserCallbackTimeout);\r\n        break;\r\n      case IdlePriority:\r\n        continuationCallback = scheduler_flushTaskAtPriority_Idle(callback, didUserCallbackTimeout);\r\n        break;\r\n    }\r\n  } catch (error) {\r\n    throw error;\r\n  } finally {\r\n    currentPriorityLevel = previousPriorityLevel;\r\n    currentTask = previousTask;\r\n  }\r\n\r\n  // A callback may return a continuation. The continuation should be scheduled\r\n  // with the same priority and expiration as the just-finished callback.\r\n  if (typeof continuationCallback === 'function') {\r\n    var expirationTime = task.expirationTime;\r\n    var continuationTask = task;\r\n    continuationTask.callback = continuationCallback;\r\n\r\n    // Insert the new callback into the list, sorted by its timeout. This is\r\n    // almost the same as the code in `scheduleCallback`, except the callback\r\n    // is inserted into the list *before* callbacks of equal timeout instead\r\n    // of after.\r\n    if (firstTask === null) {\r\n      // This is the first callback in the list.\r\n      firstTask = continuationTask.next = continuationTask.previous = continuationTask;\r\n    } else {\r\n      var nextAfterContinuation = null;\r\n      var t = firstTask;\r\n      do {\r\n        if (expirationTime <= t.expirationTime) {\r\n          // This task times out at or after the continuation. We will insert\r\n          // the continuation *before* this task.\r\n          nextAfterContinuation = t;\r\n          break;\r\n        }\r\n        t = t.next;\r\n      } while (t !== firstTask);\r\n      if (nextAfterContinuation === null) {\r\n        // No equal or lower priority task was found, which means the new task\r\n        // is the lowest priority task in the list.\r\n        nextAfterContinuation = firstTask;\r\n      } else if (nextAfterContinuation === firstTask) {\r\n        // The new task is the highest priority task in the list.\r\n        firstTask = continuationTask;\r\n      }\r\n\r\n      var _previous = nextAfterContinuation.previous;\r\n      _previous.next = nextAfterContinuation.previous = continuationTask;\r\n      continuationTask.next = nextAfterContinuation;\r\n      continuationTask.previous = _previous;\r\n    }\r\n  }\r\n}\r\n\r\nfunction advanceTimers(currentTime) {\r\n  // Check for tasks that are no longer delayed and add them to the queue.\r\n  if (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime) {\r\n    do {\r\n      var task = firstDelayedTask;\r\n      var next = task.next;\r\n      if (task === next) {\r\n        firstDelayedTask = null;\r\n      } else {\r\n        firstDelayedTask = next;\r\n        var previous = task.previous;\r\n        previous.next = next;\r\n        next.previous = previous;\r\n      }\r\n      task.next = task.previous = null;\r\n      insertScheduledTask(task, task.expirationTime);\r\n    } while (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime);\r\n  }\r\n}\r\n\r\nfunction handleTimeout(currentTime) {\r\n  isHostTimeoutScheduled = false;\r\n  advanceTimers(currentTime);\r\n\r\n  if (!isHostCallbackScheduled) {\r\n    if (firstTask !== null) {\r\n      isHostCallbackScheduled = true;\r\n      requestHostCallback(flushWork);\r\n    } else if (firstDelayedTask !== null) {\r\n      requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWork(hasTimeRemaining, initialTime) {\r\n  // Exit right away if we're currently paused\r\n  if (enableSchedulerDebugging && isSchedulerPaused) {\r\n    return;\r\n  }\r\n\r\n  // We'll need a host callback the next time work is scheduled.\r\n  isHostCallbackScheduled = false;\r\n  if (isHostTimeoutScheduled) {\r\n    // We scheduled a timeout but it's no longer needed. Cancel it.\r\n    isHostTimeoutScheduled = false;\r\n    cancelHostTimeout();\r\n  }\r\n\r\n  var currentTime = initialTime;\r\n  advanceTimers(currentTime);\r\n\r\n  isPerformingWork = true;\r\n  try {\r\n    if (!hasTimeRemaining) {\r\n      // Flush all the expired callbacks without yielding.\r\n      // TODO: Split flushWork into two separate functions instead of using\r\n      // a boolean argument?\r\n      while (firstTask !== null && firstTask.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused)) {\r\n        flushTask(firstTask, currentTime);\r\n        currentTime = exports.unstable_now();\r\n        advanceTimers(currentTime);\r\n      }\r\n    } else {\r\n      // Keep flushing callbacks until we run out of time in the frame.\r\n      if (firstTask !== null) {\r\n        do {\r\n          flushTask(firstTask, currentTime);\r\n          currentTime = exports.unstable_now();\r\n          advanceTimers(currentTime);\r\n        } while (firstTask !== null && !shouldYieldToHost() && !(enableSchedulerDebugging && isSchedulerPaused));\r\n      }\r\n    }\r\n    // Return whether there's additional work\r\n    if (firstTask !== null) {\r\n      return true;\r\n    } else {\r\n      if (firstDelayedTask !== null) {\r\n        requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\r\n      }\r\n      return false;\r\n    }\r\n  } finally {\r\n    isPerformingWork = false;\r\n  }\r\n}\r\n\r\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\r\n  switch (priorityLevel) {\r\n    case ImmediatePriority:\r\n    case UserBlockingPriority:\r\n    case NormalPriority:\r\n    case LowPriority:\r\n    case IdlePriority:\r\n      break;\r\n    default:\r\n      priorityLevel = NormalPriority;\r\n  }\r\n\r\n  var previousPriorityLevel = currentPriorityLevel;\r\n  currentPriorityLevel = priorityLevel;\r\n\r\n  try {\r\n    return eventHandler();\r\n  } finally {\r\n    currentPriorityLevel = previousPriorityLevel;\r\n  }\r\n}\r\n\r\nfunction unstable_next(eventHandler) {\r\n  var priorityLevel;\r\n  switch (currentPriorityLevel) {\r\n    case ImmediatePriority:\r\n    case UserBlockingPriority:\r\n    case NormalPriority:\r\n      // Shift down to normal priority\r\n      priorityLevel = NormalPriority;\r\n      break;\r\n    default:\r\n      // Anything lower than normal priority should remain at the current level.\r\n      priorityLevel = currentPriorityLevel;\r\n      break;\r\n  }\r\n\r\n  var previousPriorityLevel = currentPriorityLevel;\r\n  currentPriorityLevel = priorityLevel;\r\n\r\n  try {\r\n    return eventHandler();\r\n  } finally {\r\n    currentPriorityLevel = previousPriorityLevel;\r\n  }\r\n}\r\n\r\nfunction unstable_wrapCallback(callback) {\r\n  var parentPriorityLevel = currentPriorityLevel;\r\n  return function () {\r\n    // This is a fork of runWithPriority, inlined for performance.\r\n    var previousPriorityLevel = currentPriorityLevel;\r\n    currentPriorityLevel = parentPriorityLevel;\r\n\r\n    try {\r\n      return callback.apply(this, arguments);\r\n    } finally {\r\n      currentPriorityLevel = previousPriorityLevel;\r\n    }\r\n  };\r\n}\r\n\r\nfunction timeoutForPriorityLevel(priorityLevel) {\r\n  switch (priorityLevel) {\r\n    case ImmediatePriority:\r\n      return IMMEDIATE_PRIORITY_TIMEOUT;\r\n    case UserBlockingPriority:\r\n      return USER_BLOCKING_PRIORITY;\r\n    case IdlePriority:\r\n      return IDLE_PRIORITY;\r\n    case LowPriority:\r\n      return LOW_PRIORITY_TIMEOUT;\r\n    case NormalPriority:\r\n    default:\r\n      return NORMAL_PRIORITY_TIMEOUT;\r\n  }\r\n}\r\n\r\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\r\n  var currentTime = exports.unstable_now();\r\n\r\n  var startTime;\r\n  var timeout;\r\n  if (typeof options === 'object' && options !== null) {\r\n    var delay = options.delay;\r\n    if (typeof delay === 'number' && delay > 0) {\r\n      startTime = currentTime + delay;\r\n    } else {\r\n      startTime = currentTime;\r\n    }\r\n    timeout = typeof options.timeout === 'number' ? options.timeout : timeoutForPriorityLevel(priorityLevel);\r\n  } else {\r\n    timeout = timeoutForPriorityLevel(priorityLevel);\r\n    startTime = currentTime;\r\n  }\r\n\r\n  var expirationTime = startTime + timeout;\r\n\r\n  var newTask = {\r\n    callback: callback,\r\n    priorityLevel: priorityLevel,\r\n    startTime: startTime,\r\n    expirationTime: expirationTime,\r\n    next: null,\r\n    previous: null\r\n  };\r\n\r\n  if (startTime > currentTime) {\r\n    // This is a delayed task.\r\n    insertDelayedTask(newTask, startTime);\r\n    if (firstTask === null && firstDelayedTask === newTask) {\r\n      // All tasks are delayed, and this is the task with the earliest delay.\r\n      if (isHostTimeoutScheduled) {\r\n        // Cancel an existing timeout.\r\n        cancelHostTimeout();\r\n      } else {\r\n        isHostTimeoutScheduled = true;\r\n      }\r\n      // Schedule a timeout.\r\n      requestHostTimeout(handleTimeout, startTime - currentTime);\r\n    }\r\n  } else {\r\n    insertScheduledTask(newTask, expirationTime);\r\n    // Schedule a host callback, if needed. If we're already performing work,\r\n    // wait until the next time we yield.\r\n    if (!isHostCallbackScheduled && !isPerformingWork) {\r\n      isHostCallbackScheduled = true;\r\n      requestHostCallback(flushWork);\r\n    }\r\n  }\r\n\r\n  return newTask;\r\n}\r\n\r\nfunction insertScheduledTask(newTask, expirationTime) {\r\n  // Insert the new task into the list, ordered first by its timeout, then by\r\n  // insertion. So the new task is inserted after any other task the\r\n  // same timeout\r\n  if (firstTask === null) {\r\n    // This is the first task in the list.\r\n    firstTask = newTask.next = newTask.previous = newTask;\r\n  } else {\r\n    var next = null;\r\n    var task = firstTask;\r\n    do {\r\n      if (expirationTime < task.expirationTime) {\r\n        // The new task times out before this one.\r\n        next = task;\r\n        break;\r\n      }\r\n      task = task.next;\r\n    } while (task !== firstTask);\r\n\r\n    if (next === null) {\r\n      // No task with a later timeout was found, which means the new task has\r\n      // the latest timeout in the list.\r\n      next = firstTask;\r\n    } else if (next === firstTask) {\r\n      // The new task has the earliest expiration in the entire list.\r\n      firstTask = newTask;\r\n    }\r\n\r\n    var previous = next.previous;\r\n    previous.next = next.previous = newTask;\r\n    newTask.next = next;\r\n    newTask.previous = previous;\r\n  }\r\n}\r\n\r\nfunction insertDelayedTask(newTask, startTime) {\r\n  // Insert the new task into the list, ordered by its start time.\r\n  if (firstDelayedTask === null) {\r\n    // This is the first task in the list.\r\n    firstDelayedTask = newTask.next = newTask.previous = newTask;\r\n  } else {\r\n    var next = null;\r\n    var task = firstDelayedTask;\r\n    do {\r\n      if (startTime < task.startTime) {\r\n        // The new task times out before this one.\r\n        next = task;\r\n        break;\r\n      }\r\n      task = task.next;\r\n    } while (task !== firstDelayedTask);\r\n\r\n    if (next === null) {\r\n      // No task with a later timeout was found, which means the new task has\r\n      // the latest timeout in the list.\r\n      next = firstDelayedTask;\r\n    } else if (next === firstDelayedTask) {\r\n      // The new task has the earliest expiration in the entire list.\r\n      firstDelayedTask = newTask;\r\n    }\r\n\r\n    var previous = next.previous;\r\n    previous.next = next.previous = newTask;\r\n    newTask.next = next;\r\n    newTask.previous = previous;\r\n  }\r\n}\r\n\r\nfunction unstable_pauseExecution() {\r\n  isSchedulerPaused = true;\r\n}\r\n\r\nfunction unstable_continueExecution() {\r\n  isSchedulerPaused = false;\r\n  if (!isHostCallbackScheduled && !isPerformingWork) {\r\n    isHostCallbackScheduled = true;\r\n    requestHostCallback(flushWork);\r\n  }\r\n}\r\n\r\nfunction unstable_getFirstCallbackNode() {\r\n  return firstTask;\r\n}\r\n\r\nfunction unstable_cancelCallback(task) {\r\n  var next = task.next;\r\n  if (next === null) {\r\n    // Already cancelled.\r\n    return;\r\n  }\r\n\r\n  if (task === next) {\r\n    if (task === firstTask) {\r\n      firstTask = null;\r\n    } else if (task === firstDelayedTask) {\r\n      firstDelayedTask = null;\r\n    }\r\n  } else {\r\n    if (task === firstTask) {\r\n      firstTask = next;\r\n    } else if (task === firstDelayedTask) {\r\n      firstDelayedTask = next;\r\n    }\r\n    var previous = task.previous;\r\n    previous.next = next;\r\n    next.previous = previous;\r\n  }\r\n\r\n  task.next = task.previous = null;\r\n}\r\n\r\nfunction unstable_getCurrentPriorityLevel() {\r\n  return currentPriorityLevel;\r\n}\r\n\r\nfunction unstable_shouldYield() {\r\n  var currentTime = exports.unstable_now();\r\n  advanceTimers(currentTime);\r\n  return currentTask !== null && firstTask !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();\r\n}\r\n\r\nvar unstable_requestPaint = requestPaint;\r\n\r\nexports.unstable_ImmediatePriority = ImmediatePriority;\r\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\r\nexports.unstable_NormalPriority = NormalPriority;\r\nexports.unstable_IdlePriority = IdlePriority;\r\nexports.unstable_LowPriority = LowPriority;\r\nexports.unstable_runWithPriority = unstable_runWithPriority;\r\nexports.unstable_next = unstable_next;\r\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\r\nexports.unstable_cancelCallback = unstable_cancelCallback;\r\nexports.unstable_wrapCallback = unstable_wrapCallback;\r\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\r\nexports.unstable_shouldYield = unstable_shouldYield;\r\nexports.unstable_requestPaint = unstable_requestPaint;\r\nexports.unstable_continueExecution = unstable_continueExecution;\r\nexports.unstable_pauseExecution = unstable_pauseExecution;\r\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\r\n  })();\r\n}\r\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["unstable_runWithPriority","callback","unstable_LowPriority","unstable_getCurrentPriorityLevel","unstable_forceFrameRate","next","unstable_pauseExecution","priorityLevel","__esModule","unstable_UserBlockingPriority","unstable_shouldYield","unstable_requestPaint","expirationTime","value","unstable_NormalPriority","startTime","unstable_cancelCallback","previous","unstable_scheduleCallback","unstable_now","unstable_getFirstCallbackNode","unstable_continueExecution","unstable_ImmediatePriority","unstable_wrapCallback","unstable_next","onmessage","unstable_IdlePriority"]],"~:compiled-at",1579687540648,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$scheduler$cjs$scheduler_development.js\",\n\"lineCount\":22,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/scheduler/cjs/scheduler.development.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$scheduler$cjs$scheduler_development\\\"] = function(global,require,module,exports) {\\n/** @license React v0.15.0\\r\\n * scheduler.development.js\\r\\n *\\r\\n * Copyright (c) Facebook, Inc. and its affiliates.\\r\\n *\\r\\n * This source code is licensed under the MIT license found in the\\r\\n * LICENSE file in the root directory of this source tree.\\r\\n */\\r\\n\\r\\n'use strict';\\r\\n\\r\\n\\r\\n\\r\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\r\\n  (function() {\\r\\n'use strict';\\r\\n\\r\\nObject.defineProperty(exports, '__esModule', { value: true });\\r\\n\\r\\nvar enableSchedulerDebugging = false;\\r\\nvar enableIsInputPending = false;\\r\\nvar requestIdleCallbackBeforeFirstFrame = false;\\r\\nvar requestTimerEventBeforeFirstFrame = false;\\r\\nvar enableMessageLoopImplementation = false;\\r\\n\\r\\n// The DOM Scheduler implementation is similar to requestIdleCallback. It\\r\\n// works by scheduling a requestAnimationFrame, storing the time for the start\\r\\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\\r\\n// Within the postMessage handler do as much work as possible until time + frame\\r\\n// rate. By separating the idle call into a separate event tick we ensure that\\r\\n// layout, paint and other browser work is counted against the available time.\\r\\n// The frame rate is dynamically adjusted.\\r\\n\\r\\nvar requestHostCallback = void 0;\\r\\n\\r\\nvar requestHostTimeout = void 0;\\r\\nvar cancelHostTimeout = void 0;\\r\\nvar shouldYieldToHost = void 0;\\r\\nvar requestPaint = void 0;\\r\\nexports.unstable_now = void 0;\\r\\nexports.unstable_forceFrameRate = void 0;\\r\\n\\r\\nif (\\r\\n// If Scheduler runs in a non-DOM environment, it falls back to a naive\\r\\n// implementation using setTimeout.\\r\\ntypeof window === 'undefined' ||\\r\\n// Check if MessageChannel is supported, too.\\r\\ntypeof MessageChannel !== 'function') {\\r\\n  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\\r\\n  // fallback to a naive implementation.\\r\\n  var _callback = null;\\r\\n  var _timeoutID = null;\\r\\n  var _flushCallback = function () {\\r\\n    if (_callback !== null) {\\r\\n      try {\\r\\n        var currentTime = exports.unstable_now();\\r\\n        var hasRemainingTime = true;\\r\\n        _callback(hasRemainingTime, currentTime);\\r\\n        _callback = null;\\r\\n      } catch (e) {\\r\\n        setTimeout(_flushCallback, 0);\\r\\n        throw e;\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n  exports.unstable_now = function () {\\r\\n    return Date.now();\\r\\n  };\\r\\n  requestHostCallback = function (cb) {\\r\\n    if (_callback !== null) {\\r\\n      // Protect against re-entrancy.\\r\\n      setTimeout(requestHostCallback, 0, cb);\\r\\n    } else {\\r\\n      _callback = cb;\\r\\n      setTimeout(_flushCallback, 0);\\r\\n    }\\r\\n  };\\r\\n  requestHostTimeout = function (cb, ms) {\\r\\n    _timeoutID = setTimeout(cb, ms);\\r\\n  };\\r\\n  cancelHostTimeout = function () {\\r\\n    clearTimeout(_timeoutID);\\r\\n  };\\r\\n  shouldYieldToHost = function () {\\r\\n    return false;\\r\\n  };\\r\\n  requestPaint = exports.unstable_forceFrameRate = function () {};\\r\\n} else {\\r\\n  // Capture local references to native APIs, in case a polyfill overrides them.\\r\\n  var performance = window.performance;\\r\\n  var _Date = window.Date;\\r\\n  var _setTimeout = window.setTimeout;\\r\\n  var _clearTimeout = window.clearTimeout;\\r\\n  var requestAnimationFrame = window.requestAnimationFrame;\\r\\n  var cancelAnimationFrame = window.cancelAnimationFrame;\\r\\n  var requestIdleCallback = window.requestIdleCallback;\\r\\n\\r\\n  if (typeof console !== 'undefined') {\\r\\n    // TODO: Remove fb.me link\\r\\n    if (typeof requestAnimationFrame !== 'function') {\\r\\n      console.error(\\\"This browser doesn't support requestAnimationFrame. \\\" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\\r\\n    }\\r\\n    if (typeof cancelAnimationFrame !== 'function') {\\r\\n      console.error(\\\"This browser doesn't support cancelAnimationFrame. \\\" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var requestIdleCallbackBeforeFirstFrame$1 = requestIdleCallbackBeforeFirstFrame && typeof requestIdleCallback === 'function' && typeof cancelIdleCallback === 'function';\\r\\n\\r\\n  exports.unstable_now = typeof performance === 'object' && typeof performance.now === 'function' ? function () {\\r\\n    return performance.now();\\r\\n  } : function () {\\r\\n    return _Date.now();\\r\\n  };\\r\\n\\r\\n  var isRAFLoopRunning = false;\\r\\n  var isMessageLoopRunning = false;\\r\\n  var scheduledHostCallback = null;\\r\\n  var rAFTimeoutID = -1;\\r\\n  var taskTimeoutID = -1;\\r\\n\\r\\n  var frameLength = enableMessageLoopImplementation ? // We won't attempt to align with the vsync. Instead we'll yield multiple\\r\\n  // times per frame, often enough to keep it responsive even at really\\r\\n  // high frame rates > 120.\\r\\n  5 : // Use a heuristic to measure the frame rate and yield at the end of the\\r\\n  // frame. We start out assuming that we run at 30fps but then the\\r\\n  // heuristic tracking will adjust this value to a faster fps if we get\\r\\n  // more frequent animation frames.\\r\\n  33.33;\\r\\n\\r\\n  var prevRAFTime = -1;\\r\\n  var prevRAFInterval = -1;\\r\\n  var frameDeadline = 0;\\r\\n\\r\\n  var fpsLocked = false;\\r\\n\\r\\n  // TODO: Make this configurable\\r\\n  // TODO: Adjust this based on priority?\\r\\n  var maxFrameLength = 300;\\r\\n  var needsPaint = false;\\r\\n\\r\\n  if (enableIsInputPending && navigator !== undefined && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined) {\\r\\n    var scheduling = navigator.scheduling;\\r\\n    shouldYieldToHost = function () {\\r\\n      var currentTime = exports.unstable_now();\\r\\n      if (currentTime >= frameDeadline) {\\r\\n        // There's no time left in the frame. We may want to yield control of\\r\\n        // the main thread, so the browser can perform high priority tasks. The\\r\\n        // main ones are painting and user input. If there's a pending paint or\\r\\n        // a pending input, then we should yield. But if there's neither, then\\r\\n        // we can yield less often while remaining responsive. We'll eventually\\r\\n        // yield regardless, since there could be a pending paint that wasn't\\r\\n        // accompanied by a call to `requestPaint`, or other main thread tasks\\r\\n        // like network events.\\r\\n        if (needsPaint || scheduling.isInputPending()) {\\r\\n          // There is either a pending paint or a pending input.\\r\\n          return true;\\r\\n        }\\r\\n        // There's no pending input. Only yield if we've reached the max\\r\\n        // frame length.\\r\\n        return currentTime >= frameDeadline + maxFrameLength;\\r\\n      } else {\\r\\n        // There's still time left in the frame.\\r\\n        return false;\\r\\n      }\\r\\n    };\\r\\n\\r\\n    requestPaint = function () {\\r\\n      needsPaint = true;\\r\\n    };\\r\\n  } else {\\r\\n    // `isInputPending` is not available. Since we have no way of knowing if\\r\\n    // there's pending input, always yield at the end of the frame.\\r\\n    shouldYieldToHost = function () {\\r\\n      return exports.unstable_now() >= frameDeadline;\\r\\n    };\\r\\n\\r\\n    // Since we yield every frame regardless, `requestPaint` has no effect.\\r\\n    requestPaint = function () {};\\r\\n  }\\r\\n\\r\\n  exports.unstable_forceFrameRate = function (fps) {\\r\\n    if (fps < 0 || fps > 125) {\\r\\n      console.error('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing framerates higher than 125 fps is not unsupported');\\r\\n      return;\\r\\n    }\\r\\n    if (fps > 0) {\\r\\n      frameLength = Math.floor(1000 / fps);\\r\\n      fpsLocked = true;\\r\\n    } else {\\r\\n      // reset the framerate\\r\\n      frameLength = 33.33;\\r\\n      fpsLocked = false;\\r\\n    }\\r\\n  };\\r\\n\\r\\n  var performWorkUntilDeadline = function () {\\r\\n    if (enableMessageLoopImplementation) {\\r\\n      if (scheduledHostCallback !== null) {\\r\\n        var currentTime = exports.unstable_now();\\r\\n        // Yield after `frameLength` ms, regardless of where we are in the vsync\\r\\n        // cycle. This means there's always time remaining at the beginning of\\r\\n        // the message event.\\r\\n        frameDeadline = currentTime + frameLength;\\r\\n        var hasTimeRemaining = true;\\r\\n        try {\\r\\n          var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\\r\\n          if (!hasMoreWork) {\\r\\n            isMessageLoopRunning = false;\\r\\n            scheduledHostCallback = null;\\r\\n          } else {\\r\\n            // If there's more work, schedule the next message event at the end\\r\\n            // of the preceding one.\\r\\n            port.postMessage(null);\\r\\n          }\\r\\n        } catch (error) {\\r\\n          // If a scheduler task throws, exit the current browser task so the\\r\\n          // error can be observed.\\r\\n          port.postMessage(null);\\r\\n          throw error;\\r\\n        }\\r\\n      }\\r\\n      // Yielding to the browser will give it a chance to paint, so we can\\r\\n      // reset this.\\r\\n      needsPaint = false;\\r\\n    } else {\\r\\n      if (scheduledHostCallback !== null) {\\r\\n        var _currentTime = exports.unstable_now();\\r\\n        var _hasTimeRemaining = frameDeadline - _currentTime > 0;\\r\\n        try {\\r\\n          var _hasMoreWork = scheduledHostCallback(_hasTimeRemaining, _currentTime);\\r\\n          if (!_hasMoreWork) {\\r\\n            scheduledHostCallback = null;\\r\\n          }\\r\\n        } catch (error) {\\r\\n          // If a scheduler task throws, exit the current browser task so the\\r\\n          // error can be observed, and post a new task as soon as possible\\r\\n          // so we can continue where we left off.\\r\\n          port.postMessage(null);\\r\\n          throw error;\\r\\n        }\\r\\n      }\\r\\n      // Yielding to the browser will give it a chance to paint, so we can\\r\\n      // reset this.\\r\\n      needsPaint = false;\\r\\n    }\\r\\n  };\\r\\n\\r\\n  var channel = new MessageChannel();\\r\\n  var port = channel.port2;\\r\\n  channel.port1.onmessage = performWorkUntilDeadline;\\r\\n\\r\\n  var onAnimationFrame = function (rAFTime) {\\r\\n    if (scheduledHostCallback === null) {\\r\\n      // No scheduled work. Exit.\\r\\n      prevRAFTime = -1;\\r\\n      prevRAFInterval = -1;\\r\\n      isRAFLoopRunning = false;\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    // Eagerly schedule the next animation callback at the beginning of the\\r\\n    // frame. If the scheduler queue is not empty at the end of the frame, it\\r\\n    // will continue flushing inside that callback. If the queue *is* empty,\\r\\n    // then it will exit immediately. Posting the callback at the start of the\\r\\n    // frame ensures it's fired within the earliest possible frame. If we\\r\\n    // waited until the end of the frame to post the callback, we risk the\\r\\n    // browser skipping a frame and not firing the callback until the frame\\r\\n    // after that.\\r\\n    isRAFLoopRunning = true;\\r\\n    requestAnimationFrame(function (nextRAFTime) {\\r\\n      _clearTimeout(rAFTimeoutID);\\r\\n      onAnimationFrame(nextRAFTime);\\r\\n    });\\r\\n\\r\\n    // requestAnimationFrame is throttled when the tab is backgrounded. We\\r\\n    // don't want to stop working entirely. So we'll fallback to a timeout loop.\\r\\n    // TODO: Need a better heuristic for backgrounded work.\\r\\n    var onTimeout = function () {\\r\\n      frameDeadline = exports.unstable_now() + frameLength / 2;\\r\\n      performWorkUntilDeadline();\\r\\n      rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);\\r\\n    };\\r\\n    rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);\\r\\n\\r\\n    if (prevRAFTime !== -1 &&\\r\\n    // Make sure this rAF time is different from the previous one. This check\\r\\n    // could fail if two rAFs fire in the same frame.\\r\\n    rAFTime - prevRAFTime > 0.1) {\\r\\n      var rAFInterval = rAFTime - prevRAFTime;\\r\\n      if (!fpsLocked && prevRAFInterval !== -1) {\\r\\n        // We've observed two consecutive frame intervals. We'll use this to\\r\\n        // dynamically adjust the frame rate.\\r\\n        //\\r\\n        // If one frame goes long, then the next one can be short to catch up.\\r\\n        // If two frames are short in a row, then that's an indication that we\\r\\n        // actually have a higher frame rate than what we're currently\\r\\n        // optimizing. For example, if we're running on 120hz display or 90hz VR\\r\\n        // display. Take the max of the two in case one of them was an anomaly\\r\\n        // due to missed frame deadlines.\\r\\n        if (rAFInterval < frameLength && prevRAFInterval < frameLength) {\\r\\n          frameLength = rAFInterval < prevRAFInterval ? prevRAFInterval : rAFInterval;\\r\\n          if (frameLength < 8.33) {\\r\\n            // Defensive coding. We don't support higher frame rates than 120hz.\\r\\n            // If the calculated frame length gets lower than 8, it is probably\\r\\n            // a bug.\\r\\n            frameLength = 8.33;\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n      prevRAFInterval = rAFInterval;\\r\\n    }\\r\\n    prevRAFTime = rAFTime;\\r\\n    frameDeadline = rAFTime + frameLength;\\r\\n\\r\\n    // We use the postMessage trick to defer idle work until after the repaint.\\r\\n    port.postMessage(null);\\r\\n  };\\r\\n\\r\\n  requestHostCallback = function (callback) {\\r\\n    scheduledHostCallback = callback;\\r\\n    if (enableMessageLoopImplementation) {\\r\\n      if (!isMessageLoopRunning) {\\r\\n        isMessageLoopRunning = true;\\r\\n        port.postMessage(null);\\r\\n      }\\r\\n    } else {\\r\\n      if (!isRAFLoopRunning) {\\r\\n        // Start a rAF loop.\\r\\n        isRAFLoopRunning = true;\\r\\n        requestAnimationFrame(function (rAFTime) {\\r\\n          if (requestIdleCallbackBeforeFirstFrame$1) {\\r\\n            cancelIdleCallback(idleCallbackID);\\r\\n          }\\r\\n          if (requestTimerEventBeforeFirstFrame) {\\r\\n            _clearTimeout(idleTimeoutID);\\r\\n          }\\r\\n          onAnimationFrame(rAFTime);\\r\\n        });\\r\\n\\r\\n        // If we just missed the last vsync, the next rAF might not happen for\\r\\n        // another frame. To claim as much idle time as possible, post a\\r\\n        // callback with `requestIdleCallback`, which should fire if there's\\r\\n        // idle time left in the frame.\\r\\n        //\\r\\n        // This should only be an issue for the first rAF in the loop;\\r\\n        // subsequent rAFs are scheduled at the beginning of the\\r\\n        // preceding frame.\\r\\n        var idleCallbackID = void 0;\\r\\n        if (requestIdleCallbackBeforeFirstFrame$1) {\\r\\n          idleCallbackID = requestIdleCallback(function onIdleCallbackBeforeFirstFrame() {\\r\\n            if (requestTimerEventBeforeFirstFrame) {\\r\\n              _clearTimeout(idleTimeoutID);\\r\\n            }\\r\\n            frameDeadline = exports.unstable_now() + frameLength;\\r\\n            performWorkUntilDeadline();\\r\\n          });\\r\\n        }\\r\\n        // Alternate strategy to address the same problem. Scheduler a timer\\r\\n        // with no delay. If this fires before the rAF, that likely indicates\\r\\n        // that there's idle time before the next vsync. This isn't always the\\r\\n        // case, but we'll be aggressive and assume it is, as a trade off to\\r\\n        // prevent idle periods.\\r\\n        var idleTimeoutID = void 0;\\r\\n        if (requestTimerEventBeforeFirstFrame) {\\r\\n          idleTimeoutID = _setTimeout(function onTimerEventBeforeFirstFrame() {\\r\\n            if (requestIdleCallbackBeforeFirstFrame$1) {\\r\\n              cancelIdleCallback(idleCallbackID);\\r\\n            }\\r\\n            frameDeadline = exports.unstable_now() + frameLength;\\r\\n            performWorkUntilDeadline();\\r\\n          }, 0);\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n\\r\\n  requestHostTimeout = function (callback, ms) {\\r\\n    taskTimeoutID = _setTimeout(function () {\\r\\n      callback(exports.unstable_now());\\r\\n    }, ms);\\r\\n  };\\r\\n\\r\\n  cancelHostTimeout = function () {\\r\\n    _clearTimeout(taskTimeoutID);\\r\\n    taskTimeoutID = -1;\\r\\n  };\\r\\n}\\r\\n\\r\\n/* eslint-disable no-var */\\r\\n\\r\\n// TODO: Use symbols?\\r\\nvar ImmediatePriority = 1;\\r\\nvar UserBlockingPriority = 2;\\r\\nvar NormalPriority = 3;\\r\\nvar LowPriority = 4;\\r\\nvar IdlePriority = 5;\\r\\n\\r\\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\\r\\n// Math.pow(2, 30) - 1\\r\\n// 0b111111111111111111111111111111\\r\\nvar maxSigned31BitInt = 1073741823;\\r\\n\\r\\n// Times out immediately\\r\\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\\r\\n// Eventually times out\\r\\nvar USER_BLOCKING_PRIORITY = 250;\\r\\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\\r\\nvar LOW_PRIORITY_TIMEOUT = 10000;\\r\\n// Never times out\\r\\nvar IDLE_PRIORITY = maxSigned31BitInt;\\r\\n\\r\\n// Tasks are stored as a circular, doubly linked list.\\r\\nvar firstTask = null;\\r\\nvar firstDelayedTask = null;\\r\\n\\r\\n// Pausing the scheduler is useful for debugging.\\r\\nvar isSchedulerPaused = false;\\r\\n\\r\\nvar currentTask = null;\\r\\nvar currentPriorityLevel = NormalPriority;\\r\\n\\r\\n// This is set while performing work, to prevent re-entrancy.\\r\\nvar isPerformingWork = false;\\r\\n\\r\\nvar isHostCallbackScheduled = false;\\r\\nvar isHostTimeoutScheduled = false;\\r\\n\\r\\nfunction scheduler_flushTaskAtPriority_Immediate(callback, didTimeout) {\\r\\n  return callback(didTimeout);\\r\\n}\\r\\nfunction scheduler_flushTaskAtPriority_UserBlocking(callback, didTimeout) {\\r\\n  return callback(didTimeout);\\r\\n}\\r\\nfunction scheduler_flushTaskAtPriority_Normal(callback, didTimeout) {\\r\\n  return callback(didTimeout);\\r\\n}\\r\\nfunction scheduler_flushTaskAtPriority_Low(callback, didTimeout) {\\r\\n  return callback(didTimeout);\\r\\n}\\r\\nfunction scheduler_flushTaskAtPriority_Idle(callback, didTimeout) {\\r\\n  return callback(didTimeout);\\r\\n}\\r\\n\\r\\nfunction flushTask(task, currentTime) {\\r\\n  // Remove the task from the list before calling the callback. That way the\\r\\n  // list is in a consistent state even if the callback throws.\\r\\n  var next = task.next;\\r\\n  if (next === task) {\\r\\n    // This is the only scheduled task. Clear the list.\\r\\n    firstTask = null;\\r\\n  } else {\\r\\n    // Remove the task from its position in the list.\\r\\n    if (task === firstTask) {\\r\\n      firstTask = next;\\r\\n    }\\r\\n    var previous = task.previous;\\r\\n    previous.next = next;\\r\\n    next.previous = previous;\\r\\n  }\\r\\n  task.next = task.previous = null;\\r\\n\\r\\n  // Now it's safe to execute the task.\\r\\n  var callback = task.callback;\\r\\n  var previousPriorityLevel = currentPriorityLevel;\\r\\n  var previousTask = currentTask;\\r\\n  currentPriorityLevel = task.priorityLevel;\\r\\n  currentTask = task;\\r\\n  var continuationCallback;\\r\\n  try {\\r\\n    var didUserCallbackTimeout = task.expirationTime <= currentTime;\\r\\n    // Add an extra function to the callstack. Profiling tools can use this\\r\\n    // to infer the priority of work that appears higher in the stack.\\r\\n    switch (currentPriorityLevel) {\\r\\n      case ImmediatePriority:\\r\\n        continuationCallback = scheduler_flushTaskAtPriority_Immediate(callback, didUserCallbackTimeout);\\r\\n        break;\\r\\n      case UserBlockingPriority:\\r\\n        continuationCallback = scheduler_flushTaskAtPriority_UserBlocking(callback, didUserCallbackTimeout);\\r\\n        break;\\r\\n      case NormalPriority:\\r\\n        continuationCallback = scheduler_flushTaskAtPriority_Normal(callback, didUserCallbackTimeout);\\r\\n        break;\\r\\n      case LowPriority:\\r\\n        continuationCallback = scheduler_flushTaskAtPriority_Low(callback, didUserCallbackTimeout);\\r\\n        break;\\r\\n      case IdlePriority:\\r\\n        continuationCallback = scheduler_flushTaskAtPriority_Idle(callback, didUserCallbackTimeout);\\r\\n        break;\\r\\n    }\\r\\n  } catch (error) {\\r\\n    throw error;\\r\\n  } finally {\\r\\n    currentPriorityLevel = previousPriorityLevel;\\r\\n    currentTask = previousTask;\\r\\n  }\\r\\n\\r\\n  // A callback may return a continuation. The continuation should be scheduled\\r\\n  // with the same priority and expiration as the just-finished callback.\\r\\n  if (typeof continuationCallback === 'function') {\\r\\n    var expirationTime = task.expirationTime;\\r\\n    var continuationTask = task;\\r\\n    continuationTask.callback = continuationCallback;\\r\\n\\r\\n    // Insert the new callback into the list, sorted by its timeout. This is\\r\\n    // almost the same as the code in `scheduleCallback`, except the callback\\r\\n    // is inserted into the list *before* callbacks of equal timeout instead\\r\\n    // of after.\\r\\n    if (firstTask === null) {\\r\\n      // This is the first callback in the list.\\r\\n      firstTask = continuationTask.next = continuationTask.previous = continuationTask;\\r\\n    } else {\\r\\n      var nextAfterContinuation = null;\\r\\n      var t = firstTask;\\r\\n      do {\\r\\n        if (expirationTime <= t.expirationTime) {\\r\\n          // This task times out at or after the continuation. We will insert\\r\\n          // the continuation *before* this task.\\r\\n          nextAfterContinuation = t;\\r\\n          break;\\r\\n        }\\r\\n        t = t.next;\\r\\n      } while (t !== firstTask);\\r\\n      if (nextAfterContinuation === null) {\\r\\n        // No equal or lower priority task was found, which means the new task\\r\\n        // is the lowest priority task in the list.\\r\\n        nextAfterContinuation = firstTask;\\r\\n      } else if (nextAfterContinuation === firstTask) {\\r\\n        // The new task is the highest priority task in the list.\\r\\n        firstTask = continuationTask;\\r\\n      }\\r\\n\\r\\n      var _previous = nextAfterContinuation.previous;\\r\\n      _previous.next = nextAfterContinuation.previous = continuationTask;\\r\\n      continuationTask.next = nextAfterContinuation;\\r\\n      continuationTask.previous = _previous;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction advanceTimers(currentTime) {\\r\\n  // Check for tasks that are no longer delayed and add them to the queue.\\r\\n  if (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime) {\\r\\n    do {\\r\\n      var task = firstDelayedTask;\\r\\n      var next = task.next;\\r\\n      if (task === next) {\\r\\n        firstDelayedTask = null;\\r\\n      } else {\\r\\n        firstDelayedTask = next;\\r\\n        var previous = task.previous;\\r\\n        previous.next = next;\\r\\n        next.previous = previous;\\r\\n      }\\r\\n      task.next = task.previous = null;\\r\\n      insertScheduledTask(task, task.expirationTime);\\r\\n    } while (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction handleTimeout(currentTime) {\\r\\n  isHostTimeoutScheduled = false;\\r\\n  advanceTimers(currentTime);\\r\\n\\r\\n  if (!isHostCallbackScheduled) {\\r\\n    if (firstTask !== null) {\\r\\n      isHostCallbackScheduled = true;\\r\\n      requestHostCallback(flushWork);\\r\\n    } else if (firstDelayedTask !== null) {\\r\\n      requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction flushWork(hasTimeRemaining, initialTime) {\\r\\n  // Exit right away if we're currently paused\\r\\n  if (enableSchedulerDebugging && isSchedulerPaused) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // We'll need a host callback the next time work is scheduled.\\r\\n  isHostCallbackScheduled = false;\\r\\n  if (isHostTimeoutScheduled) {\\r\\n    // We scheduled a timeout but it's no longer needed. Cancel it.\\r\\n    isHostTimeoutScheduled = false;\\r\\n    cancelHostTimeout();\\r\\n  }\\r\\n\\r\\n  var currentTime = initialTime;\\r\\n  advanceTimers(currentTime);\\r\\n\\r\\n  isPerformingWork = true;\\r\\n  try {\\r\\n    if (!hasTimeRemaining) {\\r\\n      // Flush all the expired callbacks without yielding.\\r\\n      // TODO: Split flushWork into two separate functions instead of using\\r\\n      // a boolean argument?\\r\\n      while (firstTask !== null && firstTask.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused)) {\\r\\n        flushTask(firstTask, currentTime);\\r\\n        currentTime = exports.unstable_now();\\r\\n        advanceTimers(currentTime);\\r\\n      }\\r\\n    } else {\\r\\n      // Keep flushing callbacks until we run out of time in the frame.\\r\\n      if (firstTask !== null) {\\r\\n        do {\\r\\n          flushTask(firstTask, currentTime);\\r\\n          currentTime = exports.unstable_now();\\r\\n          advanceTimers(currentTime);\\r\\n        } while (firstTask !== null && !shouldYieldToHost() && !(enableSchedulerDebugging && isSchedulerPaused));\\r\\n      }\\r\\n    }\\r\\n    // Return whether there's additional work\\r\\n    if (firstTask !== null) {\\r\\n      return true;\\r\\n    } else {\\r\\n      if (firstDelayedTask !== null) {\\r\\n        requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\\r\\n      }\\r\\n      return false;\\r\\n    }\\r\\n  } finally {\\r\\n    isPerformingWork = false;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\\r\\n  switch (priorityLevel) {\\r\\n    case ImmediatePriority:\\r\\n    case UserBlockingPriority:\\r\\n    case NormalPriority:\\r\\n    case LowPriority:\\r\\n    case IdlePriority:\\r\\n      break;\\r\\n    default:\\r\\n      priorityLevel = NormalPriority;\\r\\n  }\\r\\n\\r\\n  var previousPriorityLevel = currentPriorityLevel;\\r\\n  currentPriorityLevel = priorityLevel;\\r\\n\\r\\n  try {\\r\\n    return eventHandler();\\r\\n  } finally {\\r\\n    currentPriorityLevel = previousPriorityLevel;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction unstable_next(eventHandler) {\\r\\n  var priorityLevel;\\r\\n  switch (currentPriorityLevel) {\\r\\n    case ImmediatePriority:\\r\\n    case UserBlockingPriority:\\r\\n    case NormalPriority:\\r\\n      // Shift down to normal priority\\r\\n      priorityLevel = NormalPriority;\\r\\n      break;\\r\\n    default:\\r\\n      // Anything lower than normal priority should remain at the current level.\\r\\n      priorityLevel = currentPriorityLevel;\\r\\n      break;\\r\\n  }\\r\\n\\r\\n  var previousPriorityLevel = currentPriorityLevel;\\r\\n  currentPriorityLevel = priorityLevel;\\r\\n\\r\\n  try {\\r\\n    return eventHandler();\\r\\n  } finally {\\r\\n    currentPriorityLevel = previousPriorityLevel;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction unstable_wrapCallback(callback) {\\r\\n  var parentPriorityLevel = currentPriorityLevel;\\r\\n  return function () {\\r\\n    // This is a fork of runWithPriority, inlined for performance.\\r\\n    var previousPriorityLevel = currentPriorityLevel;\\r\\n    currentPriorityLevel = parentPriorityLevel;\\r\\n\\r\\n    try {\\r\\n      return callback.apply(this, arguments);\\r\\n    } finally {\\r\\n      currentPriorityLevel = previousPriorityLevel;\\r\\n    }\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction timeoutForPriorityLevel(priorityLevel) {\\r\\n  switch (priorityLevel) {\\r\\n    case ImmediatePriority:\\r\\n      return IMMEDIATE_PRIORITY_TIMEOUT;\\r\\n    case UserBlockingPriority:\\r\\n      return USER_BLOCKING_PRIORITY;\\r\\n    case IdlePriority:\\r\\n      return IDLE_PRIORITY;\\r\\n    case LowPriority:\\r\\n      return LOW_PRIORITY_TIMEOUT;\\r\\n    case NormalPriority:\\r\\n    default:\\r\\n      return NORMAL_PRIORITY_TIMEOUT;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\\r\\n  var currentTime = exports.unstable_now();\\r\\n\\r\\n  var startTime;\\r\\n  var timeout;\\r\\n  if (typeof options === 'object' && options !== null) {\\r\\n    var delay = options.delay;\\r\\n    if (typeof delay === 'number' && delay > 0) {\\r\\n      startTime = currentTime + delay;\\r\\n    } else {\\r\\n      startTime = currentTime;\\r\\n    }\\r\\n    timeout = typeof options.timeout === 'number' ? options.timeout : timeoutForPriorityLevel(priorityLevel);\\r\\n  } else {\\r\\n    timeout = timeoutForPriorityLevel(priorityLevel);\\r\\n    startTime = currentTime;\\r\\n  }\\r\\n\\r\\n  var expirationTime = startTime + timeout;\\r\\n\\r\\n  var newTask = {\\r\\n    callback: callback,\\r\\n    priorityLevel: priorityLevel,\\r\\n    startTime: startTime,\\r\\n    expirationTime: expirationTime,\\r\\n    next: null,\\r\\n    previous: null\\r\\n  };\\r\\n\\r\\n  if (startTime > currentTime) {\\r\\n    // This is a delayed task.\\r\\n    insertDelayedTask(newTask, startTime);\\r\\n    if (firstTask === null && firstDelayedTask === newTask) {\\r\\n      // All tasks are delayed, and this is the task with the earliest delay.\\r\\n      if (isHostTimeoutScheduled) {\\r\\n        // Cancel an existing timeout.\\r\\n        cancelHostTimeout();\\r\\n      } else {\\r\\n        isHostTimeoutScheduled = true;\\r\\n      }\\r\\n      // Schedule a timeout.\\r\\n      requestHostTimeout(handleTimeout, startTime - currentTime);\\r\\n    }\\r\\n  } else {\\r\\n    insertScheduledTask(newTask, expirationTime);\\r\\n    // Schedule a host callback, if needed. If we're already performing work,\\r\\n    // wait until the next time we yield.\\r\\n    if (!isHostCallbackScheduled && !isPerformingWork) {\\r\\n      isHostCallbackScheduled = true;\\r\\n      requestHostCallback(flushWork);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return newTask;\\r\\n}\\r\\n\\r\\nfunction insertScheduledTask(newTask, expirationTime) {\\r\\n  // Insert the new task into the list, ordered first by its timeout, then by\\r\\n  // insertion. So the new task is inserted after any other task the\\r\\n  // same timeout\\r\\n  if (firstTask === null) {\\r\\n    // This is the first task in the list.\\r\\n    firstTask = newTask.next = newTask.previous = newTask;\\r\\n  } else {\\r\\n    var next = null;\\r\\n    var task = firstTask;\\r\\n    do {\\r\\n      if (expirationTime < task.expirationTime) {\\r\\n        // The new task times out before this one.\\r\\n        next = task;\\r\\n        break;\\r\\n      }\\r\\n      task = task.next;\\r\\n    } while (task !== firstTask);\\r\\n\\r\\n    if (next === null) {\\r\\n      // No task with a later timeout was found, which means the new task has\\r\\n      // the latest timeout in the list.\\r\\n      next = firstTask;\\r\\n    } else if (next === firstTask) {\\r\\n      // The new task has the earliest expiration in the entire list.\\r\\n      firstTask = newTask;\\r\\n    }\\r\\n\\r\\n    var previous = next.previous;\\r\\n    previous.next = next.previous = newTask;\\r\\n    newTask.next = next;\\r\\n    newTask.previous = previous;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction insertDelayedTask(newTask, startTime) {\\r\\n  // Insert the new task into the list, ordered by its start time.\\r\\n  if (firstDelayedTask === null) {\\r\\n    // This is the first task in the list.\\r\\n    firstDelayedTask = newTask.next = newTask.previous = newTask;\\r\\n  } else {\\r\\n    var next = null;\\r\\n    var task = firstDelayedTask;\\r\\n    do {\\r\\n      if (startTime < task.startTime) {\\r\\n        // The new task times out before this one.\\r\\n        next = task;\\r\\n        break;\\r\\n      }\\r\\n      task = task.next;\\r\\n    } while (task !== firstDelayedTask);\\r\\n\\r\\n    if (next === null) {\\r\\n      // No task with a later timeout was found, which means the new task has\\r\\n      // the latest timeout in the list.\\r\\n      next = firstDelayedTask;\\r\\n    } else if (next === firstDelayedTask) {\\r\\n      // The new task has the earliest expiration in the entire list.\\r\\n      firstDelayedTask = newTask;\\r\\n    }\\r\\n\\r\\n    var previous = next.previous;\\r\\n    previous.next = next.previous = newTask;\\r\\n    newTask.next = next;\\r\\n    newTask.previous = previous;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction unstable_pauseExecution() {\\r\\n  isSchedulerPaused = true;\\r\\n}\\r\\n\\r\\nfunction unstable_continueExecution() {\\r\\n  isSchedulerPaused = false;\\r\\n  if (!isHostCallbackScheduled && !isPerformingWork) {\\r\\n    isHostCallbackScheduled = true;\\r\\n    requestHostCallback(flushWork);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction unstable_getFirstCallbackNode() {\\r\\n  return firstTask;\\r\\n}\\r\\n\\r\\nfunction unstable_cancelCallback(task) {\\r\\n  var next = task.next;\\r\\n  if (next === null) {\\r\\n    // Already cancelled.\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  if (task === next) {\\r\\n    if (task === firstTask) {\\r\\n      firstTask = null;\\r\\n    } else if (task === firstDelayedTask) {\\r\\n      firstDelayedTask = null;\\r\\n    }\\r\\n  } else {\\r\\n    if (task === firstTask) {\\r\\n      firstTask = next;\\r\\n    } else if (task === firstDelayedTask) {\\r\\n      firstDelayedTask = next;\\r\\n    }\\r\\n    var previous = task.previous;\\r\\n    previous.next = next;\\r\\n    next.previous = previous;\\r\\n  }\\r\\n\\r\\n  task.next = task.previous = null;\\r\\n}\\r\\n\\r\\nfunction unstable_getCurrentPriorityLevel() {\\r\\n  return currentPriorityLevel;\\r\\n}\\r\\n\\r\\nfunction unstable_shouldYield() {\\r\\n  var currentTime = exports.unstable_now();\\r\\n  advanceTimers(currentTime);\\r\\n  return currentTask !== null && firstTask !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();\\r\\n}\\r\\n\\r\\nvar unstable_requestPaint = requestPaint;\\r\\n\\r\\nexports.unstable_ImmediatePriority = ImmediatePriority;\\r\\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\\r\\nexports.unstable_NormalPriority = NormalPriority;\\r\\nexports.unstable_IdlePriority = IdlePriority;\\r\\nexports.unstable_LowPriority = LowPriority;\\r\\nexports.unstable_runWithPriority = unstable_runWithPriority;\\r\\nexports.unstable_next = unstable_next;\\r\\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\\r\\nexports.unstable_cancelCallback = unstable_cancelCallback;\\r\\nexports.unstable_wrapCallback = unstable_wrapCallback;\\r\\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\\r\\nexports.unstable_shouldYield = unstable_shouldYield;\\r\\nexports.unstable_requestPaint = unstable_requestPaint;\\r\\nexports.unstable_continueExecution = unstable_continueExecution;\\r\\nexports.unstable_pauseExecution = unstable_pauseExecution;\\r\\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\\r\\n  })();\\r\\n}\\r\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"flushTask\",\"task\",\"currentTime\",\"next\",\"firstTask\",\"previous\",\"callback\",\"previousPriorityLevel\",\"currentPriorityLevel\",\"previousTask\",\"currentTask\",\"priorityLevel\",\"didUserCallbackTimeout\",\"expirationTime\",\"ImmediatePriority\",\"continuationCallback\",\"UserBlockingPriority\",\"NormalPriority\",\"LowPriority\",\"IdlePriority\",\"error\",\"nextAfterContinuation\",\"t\",\"_previous\",\"advanceTimers\",\"firstDelayedTask\",\"startTime\",\"insertScheduledTask\",\"handleTimeout\",\"isHostTimeoutScheduled\",\"isHostCallbackScheduled\",\"requestHostCallback\",\"flushWork\",\"requestHostTimeout\",\"hasTimeRemaining\",\"initialTime\",\"cancelHostTimeout\",\"isPerformingWork\",\"unstable_now\",\"shouldYieldToHost\",\"timeoutForPriorityLevel\",\"IMMEDIATE_PRIORITY_TIMEOUT\",\"USER_BLOCKING_PRIORITY\",\"maxSigned31BitInt\",\"LOW_PRIORITY_TIMEOUT\",\"NORMAL_PRIORITY_TIMEOUT\",\"newTask\",\"Object\",\"defineProperty\",\"value\",\"requestPaint\",\"unstable_forceFrameRate\",\"window\",\"MessageChannel\",\"_callback\",\"_timeoutID\",\"_flushCallback\",\"hasRemainingTime\",\"e\",\"setTimeout\",\"exports.unstable_now\",\"Date\",\"now\",\"cb\",\"ms\",\"clearTimeout\",\"exports.unstable_forceFrameRate\",\"performance\",\"_Date\",\"_setTimeout\",\"_clearTimeout\",\"requestAnimationFrame\",\"cancelAnimationFrame\",\"console\",\"isRAFLoopRunning\",\"scheduledHostCallback\",\"rAFTimeoutID\",\"taskTimeoutID\",\"frameLength\",\"prevRAFTime\",\"prevRAFInterval\",\"frameDeadline\",\"fpsLocked\",\"fps\",\"Math\",\"floor\",\"performWorkUntilDeadline\",\"_currentTime\",\"_hasTimeRemaining\",\"_hasMoreWork\",\"port\",\"postMessage\",\"channel\",\"port2\",\"port1\",\"onmessage\",\"onAnimationFrame\",\"rAFTime\",\"nextRAFTime\",\"onTimeout\",\"rAFInterval\",\"unstable_ImmediatePriority\",\"unstable_UserBlockingPriority\",\"unstable_NormalPriority\",\"unstable_IdlePriority\",\"unstable_LowPriority\",\"unstable_runWithPriority\",\"eventHandler\",\"unstable_next\",\"unstable_scheduleCallback\",\"options\",\"delay\",\"timeout\",\"unstable_cancelCallback\",\"unstable_wrapCallback\",\"parentPriorityLevel\",\"apply\",\"arguments\",\"unstable_getCurrentPriorityLevel\",\"unstable_shouldYield\",\"unstable_requestPaint\",\"unstable_continueExecution\",\"unstable_pauseExecution\",\"unstable_getFirstCallbackNode\"]\n}\n"]